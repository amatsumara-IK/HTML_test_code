function Y9(t, e) {
    for (var n = 0; n < e.length; n++) {
        const r = e[n];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const o in r)
                if (o !== "default" && !(o in t)) {
                    const l = Object.getOwnPropertyDescriptor(r, o);
                    l && Object.defineProperty(t, o, l.get ? l : {
                        enumerable: !0,
                        get: () => r[o]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]'))
        r(o);
    new MutationObserver(o => {
        for (const l of o)
            if (l.type === "childList")
                for (const a of l.addedNodes)
                    a.tagName === "LINK" && a.rel === "modulepreload" && r(a)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function n(o) {
        const l = {};
        return o.integrity && (l.integrity = o.integrity),
        o.referrerPolicy && (l.referrerPolicy = o.referrerPolicy),
        o.crossOrigin === "use-credentials" ? l.credentials = "include" : o.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin",
        l
    }
    function r(o) {
        if (o.ep)
            return;
        o.ep = !0;
        const l = n(o);
        fetch(o.href, l)
    }
}
)();
function yS(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var gp = {
    exports: {}
}
  , js = {};
var kv;
function Z9() {
    if (kv)
        return js;
    kv = 1;
    var t = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.fragment");
    function n(r, o, l) {
        var a = null;
        if (l !== void 0 && (a = "" + l),
        o.key !== void 0 && (a = "" + o.key),
        "key"in o) {
            l = {};
            for (var u in o)
                u !== "key" && (l[u] = o[u])
        } else
            l = o;
        return o = l.ref,
        {
            $$typeof: t,
            type: r,
            key: a,
            ref: o !== void 0 ? o : null,
            props: l
        }
    }
    return js.Fragment = e,
    js.jsx = n,
    js.jsxs = n,
    js
}
var Mv;
function W9() {
    return Mv || (Mv = 1,
    gp.exports = Z9()),
    gp.exports
}
var E = W9()
  , yp = {
    exports: {}
}
  , Ce = {};
var Av;
function X9() {
    if (Av)
        return Ce;
    Av = 1;
    var t = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.portal")
      , n = Symbol.for("react.fragment")
      , r = Symbol.for("react.strict_mode")
      , o = Symbol.for("react.profiler")
      , l = Symbol.for("react.consumer")
      , a = Symbol.for("react.context")
      , u = Symbol.for("react.forward_ref")
      , f = Symbol.for("react.suspense")
      , h = Symbol.for("react.memo")
      , p = Symbol.for("react.lazy")
      , m = Symbol.for("react.activity")
      , y = Symbol.iterator;
    function b(R) {
        return R === null || typeof R != "object" ? null : (R = y && R[y] || R["@@iterator"],
        typeof R == "function" ? R : null)
    }
    var C = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , S = Object.assign
      , w = {};
    function k(R, U, X) {
        this.props = R,
        this.context = U,
        this.refs = w,
        this.updater = X || C
    }
    k.prototype.isReactComponent = {},
    k.prototype.setState = function(R, U) {
        if (typeof R != "object" && typeof R != "function" && R != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, R, U, "setState")
    }
    ,
    k.prototype.forceUpdate = function(R) {
        this.updater.enqueueForceUpdate(this, R, "forceUpdate")
    }
    ;
    function A() {}
    A.prototype = k.prototype;
    function O(R, U, X) {
        this.props = R,
        this.context = U,
        this.refs = w,
        this.updater = X || C
    }
    var B = O.prototype = new A;
    B.constructor = O,
    S(B, k.prototype),
    B.isPureReactComponent = !0;
    var z = Array.isArray;
    function $() {}
    var _ = {
        H: null,
        A: null,
        T: null,
        S: null
    }
      , W = Object.prototype.hasOwnProperty;
    function ne(R, U, X) {
        var re = X.ref;
        return {
            $$typeof: t,
            type: R,
            key: U,
            ref: re !== void 0 ? re : null,
            props: X
        }
    }
    function de(R, U) {
        return ne(R.type, U, R.props)
    }
    function ve(R) {
        return typeof R == "object" && R !== null && R.$$typeof === t
    }
    function pe(R) {
        var U = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + R.replace(/[=:]/g, function(X) {
            return U[X]
        })
    }
    var be = /\/+/g;
    function Q(R, U) {
        return typeof R == "object" && R !== null && R.key != null ? pe("" + R.key) : U.toString(36)
    }
    function ae(R) {
        switch (R.status) {
        case "fulfilled":
            return R.value;
        case "rejected":
            throw R.reason;
        default:
            switch (typeof R.status == "string" ? R.then($, $) : (R.status = "pending",
            R.then(function(U) {
                R.status === "pending" && (R.status = "fulfilled",
                R.value = U)
            }, function(U) {
                R.status === "pending" && (R.status = "rejected",
                R.reason = U)
            })),
            R.status) {
            case "fulfilled":
                return R.value;
            case "rejected":
                throw R.reason
            }
        }
        throw R
    }
    function j(R, U, X, re, ce) {
        var ge = typeof R;
        (ge === "undefined" || ge === "boolean") && (R = null);
        var Se = !1;
        if (R === null)
            Se = !0;
        else
            switch (ge) {
            case "bigint":
            case "string":
            case "number":
                Se = !0;
                break;
            case "object":
                switch (R.$$typeof) {
                case t:
                case e:
                    Se = !0;
                    break;
                case p:
                    return Se = R._init,
                    j(Se(R._payload), U, X, re, ce)
                }
            }
        if (Se)
            return ce = ce(R),
            Se = re === "" ? "." + Q(R, 0) : re,
            z(ce) ? (X = "",
            Se != null && (X = Se.replace(be, "$&/") + "/"),
            j(ce, U, X, "", function(er) {
                return er
            })) : ce != null && (ve(ce) && (ce = de(ce, X + (ce.key == null || R && R.key === ce.key ? "" : ("" + ce.key).replace(be, "$&/") + "/") + Se)),
            U.push(ce)),
            1;
        Se = 0;
        var lt = re === "" ? "." : re + ":";
        if (z(R))
            for (var qe = 0; qe < R.length; qe++)
                re = R[qe],
                ge = lt + Q(re, qe),
                Se += j(re, U, X, ge, ce);
        else if (qe = b(R),
        typeof qe == "function")
            for (R = qe.call(R),
            qe = 0; !(re = R.next()).done; )
                re = re.value,
                ge = lt + Q(re, qe++),
                Se += j(re, U, X, ge, ce);
        else if (ge === "object") {
            if (typeof R.then == "function")
                return j(ae(R), U, X, re, ce);
            throw U = String(R),
            Error("Objects are not valid as a React child (found: " + (U === "[object Object]" ? "object with keys {" + Object.keys(R).join(", ") + "}" : U) + "). If you meant to render a collection of children, use an array instead.")
        }
        return Se
    }
    function P(R, U, X) {
        if (R == null)
            return R;
        var re = []
          , ce = 0;
        return j(R, re, "", "", function(ge) {
            return U.call(X, ge, ce++)
        }),
        re
    }
    function q(R) {
        if (R._status === -1) {
            var U = R._result;
            U = U(),
            U.then(function(X) {
                (R._status === 0 || R._status === -1) && (R._status = 1,
                R._result = X)
            }, function(X) {
                (R._status === 0 || R._status === -1) && (R._status = 2,
                R._result = X)
            }),
            R._status === -1 && (R._status = 0,
            R._result = U)
        }
        if (R._status === 1)
            return R._result.default;
        throw R._result
    }
    var ee = typeof reportError == "function" ? reportError : function(R) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var U = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof R == "object" && R !== null && typeof R.message == "string" ? String(R.message) : String(R),
                error: R
            });
            if (!window.dispatchEvent(U))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", R);
            return
        }
        console.error(R)
    }
      , ie = {
        map: P,
        forEach: function(R, U, X) {
            P(R, function() {
                U.apply(this, arguments)
            }, X)
        },
        count: function(R) {
            var U = 0;
            return P(R, function() {
                U++
            }),
            U
        },
        toArray: function(R) {
            return P(R, function(U) {
                return U
            }) || []
        },
        only: function(R) {
            if (!ve(R))
                throw Error("React.Children.only expected to receive a single React element child.");
            return R
        }
    };
    return Ce.Activity = m,
    Ce.Children = ie,
    Ce.Component = k,
    Ce.Fragment = n,
    Ce.Profiler = o,
    Ce.PureComponent = O,
    Ce.StrictMode = r,
    Ce.Suspense = f,
    Ce.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _,
    Ce.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(R) {
            return _.H.useMemoCache(R)
        }
    },
    Ce.cache = function(R) {
        return function() {
            return R.apply(null, arguments)
        }
    }
    ,
    Ce.cacheSignal = function() {
        return null
    }
    ,
    Ce.cloneElement = function(R, U, X) {
        if (R == null)
            throw Error("The argument must be a React element, but you passed " + R + ".");
        var re = S({}, R.props)
          , ce = R.key;
        if (U != null)
            for (ge in U.key !== void 0 && (ce = "" + U.key),
            U)
                !W.call(U, ge) || ge === "key" || ge === "__self" || ge === "__source" || ge === "ref" && U.ref === void 0 || (re[ge] = U[ge]);
        var ge = arguments.length - 2;
        if (ge === 1)
            re.children = X;
        else if (1 < ge) {
            for (var Se = Array(ge), lt = 0; lt < ge; lt++)
                Se[lt] = arguments[lt + 2];
            re.children = Se
        }
        return ne(R.type, ce, re)
    }
    ,
    Ce.createContext = function(R) {
        return R = {
            $$typeof: a,
            _currentValue: R,
            _currentValue2: R,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        R.Provider = R,
        R.Consumer = {
            $$typeof: l,
            _context: R
        },
        R
    }
    ,
    Ce.createElement = function(R, U, X) {
        var re, ce = {}, ge = null;
        if (U != null)
            for (re in U.key !== void 0 && (ge = "" + U.key),
            U)
                W.call(U, re) && re !== "key" && re !== "__self" && re !== "__source" && (ce[re] = U[re]);
        var Se = arguments.length - 2;
        if (Se === 1)
            ce.children = X;
        else if (1 < Se) {
            for (var lt = Array(Se), qe = 0; qe < Se; qe++)
                lt[qe] = arguments[qe + 2];
            ce.children = lt
        }
        if (R && R.defaultProps)
            for (re in Se = R.defaultProps,
            Se)
                ce[re] === void 0 && (ce[re] = Se[re]);
        return ne(R, ge, ce)
    }
    ,
    Ce.createRef = function() {
        return {
            current: null
        }
    }
    ,
    Ce.forwardRef = function(R) {
        return {
            $$typeof: u,
            render: R
        }
    }
    ,
    Ce.isValidElement = ve,
    Ce.lazy = function(R) {
        return {
            $$typeof: p,
            _payload: {
                _status: -1,
                _result: R
            },
            _init: q
        }
    }
    ,
    Ce.memo = function(R, U) {
        return {
            $$typeof: h,
            type: R,
            compare: U === void 0 ? null : U
        }
    }
    ,
    Ce.startTransition = function(R) {
        var U = _.T
          , X = {};
        _.T = X;
        try {
            var re = R()
              , ce = _.S;
            ce !== null && ce(X, re),
            typeof re == "object" && re !== null && typeof re.then == "function" && re.then($, ee)
        } catch (ge) {
            ee(ge)
        } finally {
            U !== null && X.types !== null && (U.types = X.types),
            _.T = U
        }
    }
    ,
    Ce.unstable_useCacheRefresh = function() {
        return _.H.useCacheRefresh()
    }
    ,
    Ce.use = function(R) {
        return _.H.use(R)
    }
    ,
    Ce.useActionState = function(R, U, X) {
        return _.H.useActionState(R, U, X)
    }
    ,
    Ce.useCallback = function(R, U) {
        return _.H.useCallback(R, U)
    }
    ,
    Ce.useContext = function(R) {
        return _.H.useContext(R)
    }
    ,
    Ce.useDebugValue = function() {}
    ,
    Ce.useDeferredValue = function(R, U) {
        return _.H.useDeferredValue(R, U)
    }
    ,
    Ce.useEffect = function(R, U) {
        return _.H.useEffect(R, U)
    }
    ,
    Ce.useEffectEvent = function(R) {
        return _.H.useEffectEvent(R)
    }
    ,
    Ce.useId = function() {
        return _.H.useId()
    }
    ,
    Ce.useImperativeHandle = function(R, U, X) {
        return _.H.useImperativeHandle(R, U, X)
    }
    ,
    Ce.useInsertionEffect = function(R, U) {
        return _.H.useInsertionEffect(R, U)
    }
    ,
    Ce.useLayoutEffect = function(R, U) {
        return _.H.useLayoutEffect(R, U)
    }
    ,
    Ce.useMemo = function(R, U) {
        return _.H.useMemo(R, U)
    }
    ,
    Ce.useOptimistic = function(R, U) {
        return _.H.useOptimistic(R, U)
    }
    ,
    Ce.useReducer = function(R, U, X) {
        return _.H.useReducer(R, U, X)
    }
    ,
    Ce.useRef = function(R) {
        return _.H.useRef(R)
    }
    ,
    Ce.useState = function(R) {
        return _.H.useState(R)
    }
    ,
    Ce.useSyncExternalStore = function(R, U, X) {
        return _.H.useSyncExternalStore(R, U, X)
    }
    ,
    Ce.useTransition = function() {
        return _.H.useTransition()
    }
    ,
    Ce.version = "19.2.4",
    Ce
}
var Nv;
function Sa() {
    return Nv || (Nv = 1,
    yp.exports = X9()),
    yp.exports
}
var T = Sa();
const Mi = yS(T)
  , kf = Y9({
    __proto__: null,
    default: Mi
}, [T]);
var vp = {
    exports: {}
}
  , Hs = {}
  , bp = {
    exports: {}
}
  , Cp = {};
var Rv;
function J9() {
    return Rv || (Rv = 1,
    (function(t) {
        function e(j, P) {
            var q = j.length;
            j.push(P);
            e: for (; 0 < q; ) {
                var ee = q - 1 >>> 1
                  , ie = j[ee];
                if (0 < o(ie, P))
                    j[ee] = P,
                    j[q] = ie,
                    q = ee;
                else
                    break e
            }
        }
        function n(j) {
            return j.length === 0 ? null : j[0]
        }
        function r(j) {
            if (j.length === 0)
                return null;
            var P = j[0]
              , q = j.pop();
            if (q !== P) {
                j[0] = q;
                e: for (var ee = 0, ie = j.length, R = ie >>> 1; ee < R; ) {
                    var U = 2 * (ee + 1) - 1
                      , X = j[U]
                      , re = U + 1
                      , ce = j[re];
                    if (0 > o(X, q))
                        re < ie && 0 > o(ce, X) ? (j[ee] = ce,
                        j[re] = q,
                        ee = re) : (j[ee] = X,
                        j[U] = q,
                        ee = U);
                    else if (re < ie && 0 > o(ce, q))
                        j[ee] = ce,
                        j[re] = q,
                        ee = re;
                    else
                        break e
                }
            }
            return P
        }
        function o(j, P) {
            var q = j.sortIndex - P.sortIndex;
            return q !== 0 ? q : j.id - P.id
        }
        if (t.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var l = performance;
            t.unstable_now = function() {
                return l.now()
            }
        } else {
            var a = Date
              , u = a.now();
            t.unstable_now = function() {
                return a.now() - u
            }
        }
        var f = []
          , h = []
          , p = 1
          , m = null
          , y = 3
          , b = !1
          , C = !1
          , S = !1
          , w = !1
          , k = typeof setTimeout == "function" ? setTimeout : null
          , A = typeof clearTimeout == "function" ? clearTimeout : null
          , O = typeof setImmediate < "u" ? setImmediate : null;
        function B(j) {
            for (var P = n(h); P !== null; ) {
                if (P.callback === null)
                    r(h);
                else if (P.startTime <= j)
                    r(h),
                    P.sortIndex = P.expirationTime,
                    e(f, P);
                else
                    break;
                P = n(h)
            }
        }
        function z(j) {
            if (S = !1,
            B(j),
            !C)
                if (n(f) !== null)
                    C = !0,
                    $ || ($ = !0,
                    pe());
                else {
                    var P = n(h);
                    P !== null && ae(z, P.startTime - j)
                }
        }
        var $ = !1
          , _ = -1
          , W = 5
          , ne = -1;
        function de() {
            return w ? !0 : !(t.unstable_now() - ne < W)
        }
        function ve() {
            if (w = !1,
            $) {
                var j = t.unstable_now();
                ne = j;
                var P = !0;
                try {
                    e: {
                        C = !1,
                        S && (S = !1,
                        A(_),
                        _ = -1),
                        b = !0;
                        var q = y;
                        try {
                            t: {
                                for (B(j),
                                m = n(f); m !== null && !(m.expirationTime > j && de()); ) {
                                    var ee = m.callback;
                                    if (typeof ee == "function") {
                                        m.callback = null,
                                        y = m.priorityLevel;
                                        var ie = ee(m.expirationTime <= j);
                                        if (j = t.unstable_now(),
                                        typeof ie == "function") {
                                            m.callback = ie,
                                            B(j),
                                            P = !0;
                                            break t
                                        }
                                        m === n(f) && r(f),
                                        B(j)
                                    } else
                                        r(f);
                                    m = n(f)
                                }
                                if (m !== null)
                                    P = !0;
                                else {
                                    var R = n(h);
                                    R !== null && ae(z, R.startTime - j),
                                    P = !1
                                }
                            }
                            break e
                        } finally {
                            m = null,
                            y = q,
                            b = !1
                        }
                        P = void 0
                    }
                } finally {
                    P ? pe() : $ = !1
                }
            }
        }
        var pe;
        if (typeof O == "function")
            pe = function() {
                O(ve)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var be = new MessageChannel
              , Q = be.port2;
            be.port1.onmessage = ve,
            pe = function() {
                Q.postMessage(null)
            }
        } else
            pe = function() {
                k(ve, 0)
            }
            ;
        function ae(j, P) {
            _ = k(function() {
                j(t.unstable_now())
            }, P)
        }
        t.unstable_IdlePriority = 5,
        t.unstable_ImmediatePriority = 1,
        t.unstable_LowPriority = 4,
        t.unstable_NormalPriority = 3,
        t.unstable_Profiling = null,
        t.unstable_UserBlockingPriority = 2,
        t.unstable_cancelCallback = function(j) {
            j.callback = null
        }
        ,
        t.unstable_forceFrameRate = function(j) {
            0 > j || 125 < j ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : W = 0 < j ? Math.floor(1e3 / j) : 5
        }
        ,
        t.unstable_getCurrentPriorityLevel = function() {
            return y
        }
        ,
        t.unstable_next = function(j) {
            switch (y) {
            case 1:
            case 2:
            case 3:
                var P = 3;
                break;
            default:
                P = y
            }
            var q = y;
            y = P;
            try {
                return j()
            } finally {
                y = q
            }
        }
        ,
        t.unstable_requestPaint = function() {
            w = !0
        }
        ,
        t.unstable_runWithPriority = function(j, P) {
            switch (j) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                j = 3
            }
            var q = y;
            y = j;
            try {
                return P()
            } finally {
                y = q
            }
        }
        ,
        t.unstable_scheduleCallback = function(j, P, q) {
            var ee = t.unstable_now();
            switch (typeof q == "object" && q !== null ? (q = q.delay,
            q = typeof q == "number" && 0 < q ? ee + q : ee) : q = ee,
            j) {
            case 1:
                var ie = -1;
                break;
            case 2:
                ie = 250;
                break;
            case 5:
                ie = 1073741823;
                break;
            case 4:
                ie = 1e4;
                break;
            default:
                ie = 5e3
            }
            return ie = q + ie,
            j = {
                id: p++,
                callback: P,
                priorityLevel: j,
                startTime: q,
                expirationTime: ie,
                sortIndex: -1
            },
            q > ee ? (j.sortIndex = q,
            e(h, j),
            n(f) === null && j === n(h) && (S ? (A(_),
            _ = -1) : S = !0,
            ae(z, q - ee))) : (j.sortIndex = ie,
            e(f, j),
            C || b || (C = !0,
            $ || ($ = !0,
            pe()))),
            j
        }
        ,
        t.unstable_shouldYield = de,
        t.unstable_wrapCallback = function(j) {
            var P = y;
            return function() {
                var q = y;
                y = P;
                try {
                    return j.apply(this, arguments)
                } finally {
                    y = q
                }
            }
        }
    }
    )(Cp)),
    Cp
}
var Ov;
function Q9() {
    return Ov || (Ov = 1,
    bp.exports = J9()),
    bp.exports
}
var Sp = {
    exports: {}
}
  , Rt = {};
var Dv;
function eE() {
    if (Dv)
        return Rt;
    Dv = 1;
    var t = Sa();
    function e(f) {
        var h = "https://react.dev/errors/" + f;
        if (1 < arguments.length) {
            h += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var p = 2; p < arguments.length; p++)
                h += "&args[]=" + encodeURIComponent(arguments[p])
        }
        return "Minified React error #" + f + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function n() {}
    var r = {
        d: {
            f: n,
            r: function() {
                throw Error(e(522))
            },
            D: n,
            C: n,
            L: n,
            m: n,
            X: n,
            S: n,
            M: n
        },
        p: 0,
        findDOMNode: null
    }
      , o = Symbol.for("react.portal");
    function l(f, h, p) {
        var m = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: o,
            key: m == null ? null : "" + m,
            children: f,
            containerInfo: h,
            implementation: p
        }
    }
    var a = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function u(f, h) {
        if (f === "font")
            return "";
        if (typeof h == "string")
            return h === "use-credentials" ? h : ""
    }
    return Rt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r,
    Rt.createPortal = function(f, h) {
        var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
            throw Error(e(299));
        return l(f, h, null, p)
    }
    ,
    Rt.flushSync = function(f) {
        var h = a.T
          , p = r.p;
        try {
            if (a.T = null,
            r.p = 2,
            f)
                return f()
        } finally {
            a.T = h,
            r.p = p,
            r.d.f()
        }
    }
    ,
    Rt.preconnect = function(f, h) {
        typeof f == "string" && (h ? (h = h.crossOrigin,
        h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null,
        r.d.C(f, h))
    }
    ,
    Rt.prefetchDNS = function(f) {
        typeof f == "string" && r.d.D(f)
    }
    ,
    Rt.preinit = function(f, h) {
        if (typeof f == "string" && h && typeof h.as == "string") {
            var p = h.as
              , m = u(p, h.crossOrigin)
              , y = typeof h.integrity == "string" ? h.integrity : void 0
              , b = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
            p === "style" ? r.d.S(f, typeof h.precedence == "string" ? h.precedence : void 0, {
                crossOrigin: m,
                integrity: y,
                fetchPriority: b
            }) : p === "script" && r.d.X(f, {
                crossOrigin: m,
                integrity: y,
                fetchPriority: b,
                nonce: typeof h.nonce == "string" ? h.nonce : void 0
            })
        }
    }
    ,
    Rt.preinitModule = function(f, h) {
        if (typeof f == "string")
            if (typeof h == "object" && h !== null) {
                if (h.as == null || h.as === "script") {
                    var p = u(h.as, h.crossOrigin);
                    r.d.M(f, {
                        crossOrigin: p,
                        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
                        nonce: typeof h.nonce == "string" ? h.nonce : void 0
                    })
                }
            } else
                h == null && r.d.M(f)
    }
    ,
    Rt.preload = function(f, h) {
        if (typeof f == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
            var p = h.as
              , m = u(p, h.crossOrigin);
            r.d.L(f, p, {
                crossOrigin: m,
                integrity: typeof h.integrity == "string" ? h.integrity : void 0,
                nonce: typeof h.nonce == "string" ? h.nonce : void 0,
                type: typeof h.type == "string" ? h.type : void 0,
                fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
                referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
                imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
                imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
                media: typeof h.media == "string" ? h.media : void 0
            })
        }
    }
    ,
    Rt.preloadModule = function(f, h) {
        if (typeof f == "string")
            if (h) {
                var p = u(h.as, h.crossOrigin);
                r.d.m(f, {
                    as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
                    crossOrigin: p,
                    integrity: typeof h.integrity == "string" ? h.integrity : void 0
                })
            } else
                r.d.m(f)
    }
    ,
    Rt.requestFormReset = function(f) {
        r.d.r(f)
    }
    ,
    Rt.unstable_batchedUpdates = function(f, h) {
        return f(h)
    }
    ,
    Rt.useFormState = function(f, h, p) {
        return a.H.useFormState(f, h, p)
    }
    ,
    Rt.useFormStatus = function() {
        return a.H.useHostTransitionStatus()
    }
    ,
    Rt.version = "19.2.4",
    Rt
}
var Lv;
function vS() {
    if (Lv)
        return Sp.exports;
    Lv = 1;
    function t() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
            } catch (e) {
                console.error(e)
            }
    }
    return t(),
    Sp.exports = eE(),
    Sp.exports
}
var zv;
function tE() {
    if (zv)
        return Hs;
    zv = 1;
    var t = Q9()
      , e = Sa()
      , n = vS();
    function r(i) {
        var s = "https://react.dev/errors/" + i;
        if (1 < arguments.length) {
            s += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var c = 2; c < arguments.length; c++)
                s += "&args[]=" + encodeURIComponent(arguments[c])
        }
        return "Minified React error #" + i + "; visit " + s + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function o(i) {
        return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11)
    }
    function l(i) {
        var s = i
          , c = i;
        if (i.alternate)
            for (; s.return; )
                s = s.return;
        else {
            i = s;
            do
                s = i,
                (s.flags & 4098) !== 0 && (c = s.return),
                i = s.return;
            while (i)
        }
        return s.tag === 3 ? c : null
    }
    function a(i) {
        if (i.tag === 13) {
            var s = i.memoizedState;
            if (s === null && (i = i.alternate,
            i !== null && (s = i.memoizedState)),
            s !== null)
                return s.dehydrated
        }
        return null
    }
    function u(i) {
        if (i.tag === 31) {
            var s = i.memoizedState;
            if (s === null && (i = i.alternate,
            i !== null && (s = i.memoizedState)),
            s !== null)
                return s.dehydrated
        }
        return null
    }
    function f(i) {
        if (l(i) !== i)
            throw Error(r(188))
    }
    function h(i) {
        var s = i.alternate;
        if (!s) {
            if (s = l(i),
            s === null)
                throw Error(r(188));
            return s !== i ? null : i
        }
        for (var c = i, d = s; ; ) {
            var g = c.return;
            if (g === null)
                break;
            var v = g.alternate;
            if (v === null) {
                if (d = g.return,
                d !== null) {
                    c = d;
                    continue
                }
                break
            }
            if (g.child === v.child) {
                for (v = g.child; v; ) {
                    if (v === c)
                        return f(g),
                        i;
                    if (v === d)
                        return f(g),
                        s;
                    v = v.sibling
                }
                throw Error(r(188))
            }
            if (c.return !== d.return)
                c = g,
                d = v;
            else {
                for (var x = !1, M = g.child; M; ) {
                    if (M === c) {
                        x = !0,
                        c = g,
                        d = v;
                        break
                    }
                    if (M === d) {
                        x = !0,
                        d = g,
                        c = v;
                        break
                    }
                    M = M.sibling
                }
                if (!x) {
                    for (M = v.child; M; ) {
                        if (M === c) {
                            x = !0,
                            c = v,
                            d = g;
                            break
                        }
                        if (M === d) {
                            x = !0,
                            d = v,
                            c = g;
                            break
                        }
                        M = M.sibling
                    }
                    if (!x)
                        throw Error(r(189))
                }
            }
            if (c.alternate !== d)
                throw Error(r(190))
        }
        if (c.tag !== 3)
            throw Error(r(188));
        return c.stateNode.current === c ? i : s
    }
    function p(i) {
        var s = i.tag;
        if (s === 5 || s === 26 || s === 27 || s === 6)
            return i;
        for (i = i.child; i !== null; ) {
            if (s = p(i),
            s !== null)
                return s;
            i = i.sibling
        }
        return null
    }
    var m = Object.assign
      , y = Symbol.for("react.element")
      , b = Symbol.for("react.transitional.element")
      , C = Symbol.for("react.portal")
      , S = Symbol.for("react.fragment")
      , w = Symbol.for("react.strict_mode")
      , k = Symbol.for("react.profiler")
      , A = Symbol.for("react.consumer")
      , O = Symbol.for("react.context")
      , B = Symbol.for("react.forward_ref")
      , z = Symbol.for("react.suspense")
      , $ = Symbol.for("react.suspense_list")
      , _ = Symbol.for("react.memo")
      , W = Symbol.for("react.lazy")
      , ne = Symbol.for("react.activity")
      , de = Symbol.for("react.memo_cache_sentinel")
      , ve = Symbol.iterator;
    function pe(i) {
        return i === null || typeof i != "object" ? null : (i = ve && i[ve] || i["@@iterator"],
        typeof i == "function" ? i : null)
    }
    var be = Symbol.for("react.client.reference");
    function Q(i) {
        if (i == null)
            return null;
        if (typeof i == "function")
            return i.$$typeof === be ? null : i.displayName || i.name || null;
        if (typeof i == "string")
            return i;
        switch (i) {
        case S:
            return "Fragment";
        case k:
            return "Profiler";
        case w:
            return "StrictMode";
        case z:
            return "Suspense";
        case $:
            return "SuspenseList";
        case ne:
            return "Activity"
        }
        if (typeof i == "object")
            switch (i.$$typeof) {
            case C:
                return "Portal";
            case O:
                return i.displayName || "Context";
            case A:
                return (i._context.displayName || "Context") + ".Consumer";
            case B:
                var s = i.render;
                return i = i.displayName,
                i || (i = s.displayName || s.name || "",
                i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"),
                i;
            case _:
                return s = i.displayName || null,
                s !== null ? s : Q(i.type) || "Memo";
            case W:
                s = i._payload,
                i = i._init;
                try {
                    return Q(i(s))
                } catch {}
            }
        return null
    }
    var ae = Array.isArray
      , j = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , P = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , q = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , ee = []
      , ie = -1;
    function R(i) {
        return {
            current: i
        }
    }
    function U(i) {
        0 > ie || (i.current = ee[ie],
        ee[ie] = null,
        ie--)
    }
    function X(i, s) {
        ie++,
        ee[ie] = i.current,
        i.current = s
    }
    var re = R(null)
      , ce = R(null)
      , ge = R(null)
      , Se = R(null);
    function lt(i, s) {
        switch (X(ge, s),
        X(ce, i),
        X(re, null),
        s.nodeType) {
        case 9:
        case 11:
            i = (i = s.documentElement) && (i = i.namespaceURI) ? Z2(i) : 0;
            break;
        default:
            if (i = s.tagName,
            s = s.namespaceURI)
                s = Z2(s),
                i = W2(s, i);
            else
                switch (i) {
                case "svg":
                    i = 1;
                    break;
                case "math":
                    i = 2;
                    break;
                default:
                    i = 0
                }
        }
        U(re),
        X(re, i)
    }
    function qe() {
        U(re),
        U(ce),
        U(ge)
    }
    function er(i) {
        i.memoizedState !== null && X(Se, i);
        var s = re.current
          , c = W2(s, i.type);
        s !== c && (X(ce, i),
        X(re, c))
    }
    function Br(i) {
        ce.current === i && (U(re),
        U(ce)),
        Se.current === i && (U(Se),
        Ls._currentValue = q)
    }
    var Ii, tr;
    function nr(i) {
        if (Ii === void 0)
            try {
                throw Error()
            } catch (c) {
                var s = c.stack.trim().match(/\n( *(at )?)/);
                Ii = s && s[1] || "",
                tr = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + Ii + i + tr
    }
    var Qf = !1;
    function ed(i, s) {
        if (!i || Qf)
            return "";
        Qf = !0;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var d = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (s) {
                            var Y = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(Y.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(Y, [])
                                } catch (F) {
                                    var V = F
                                }
                                Reflect.construct(i, [], Y)
                            } else {
                                try {
                                    Y.call()
                                } catch (F) {
                                    V = F
                                }
                                i.call(Y.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (F) {
                                V = F
                            }
                            (Y = i()) && typeof Y.catch == "function" && Y.catch(function() {})
                        }
                    } catch (F) {
                        if (F && V && typeof F.stack == "string")
                            return [F.stack, V.stack]
                    }
                    return [null, null]
                }
            };
            d.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var g = Object.getOwnPropertyDescriptor(d.DetermineComponentFrameRoot, "name");
            g && g.configurable && Object.defineProperty(d.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var v = d.DetermineComponentFrameRoot()
              , x = v[0]
              , M = v[1];
            if (x && M) {
                var N = x.split(`
`)
                  , I = M.split(`
`);
                for (g = d = 0; d < N.length && !N[d].includes("DetermineComponentFrameRoot"); )
                    d++;
                for (; g < I.length && !I[g].includes("DetermineComponentFrameRoot"); )
                    g++;
                if (d === N.length || g === I.length)
                    for (d = N.length - 1,
                    g = I.length - 1; 1 <= d && 0 <= g && N[d] !== I[g]; )
                        g--;
                for (; 1 <= d && 0 <= g; d--,
                g--)
                    if (N[d] !== I[g]) {
                        if (d !== 1 || g !== 1)
                            do
                                if (d--,
                                g--,
                                0 > g || N[d] !== I[g]) {
                                    var K = `
` + N[d].replace(" at new ", " at ");
                                    return i.displayName && K.includes("<anonymous>") && (K = K.replace("<anonymous>", i.displayName)),
                                    K
                                }
                            while (1 <= d && 0 <= g);
                        break
                    }
            }
        } finally {
            Qf = !1,
            Error.prepareStackTrace = c
        }
        return (c = i ? i.displayName || i.name : "") ? nr(c) : ""
    }
    function T7(i, s) {
        switch (i.tag) {
        case 26:
        case 27:
        case 5:
            return nr(i.type);
        case 16:
            return nr("Lazy");
        case 13:
            return i.child !== s && s !== null ? nr("Suspense Fallback") : nr("Suspense");
        case 19:
            return nr("SuspenseList");
        case 0:
        case 15:
            return ed(i.type, !1);
        case 11:
            return ed(i.type.render, !1);
        case 1:
            return ed(i.type, !0);
        case 31:
            return nr("Activity");
        default:
            return ""
        }
    }
    function kg(i) {
        try {
            var s = ""
              , c = null;
            do
                s += T7(i, c),
                c = i,
                i = i.return;
            while (i);
            return s
        } catch (d) {
            return `
Error generating stack: ` + d.message + `
` + d.stack
        }
    }
    var td = Object.prototype.hasOwnProperty
      , nd = t.unstable_scheduleCallback
      , rd = t.unstable_cancelCallback
      , k7 = t.unstable_shouldYield
      , M7 = t.unstable_requestPaint
      , Jt = t.unstable_now
      , A7 = t.unstable_getCurrentPriorityLevel
      , Mg = t.unstable_ImmediatePriority
      , Ag = t.unstable_UserBlockingPriority
      , Ra = t.unstable_NormalPriority
      , N7 = t.unstable_LowPriority
      , Ng = t.unstable_IdlePriority
      , R7 = t.log
      , O7 = t.unstable_setDisableYieldValue
      , $l = null
      , Qt = null;
    function jr(i) {
        if (typeof R7 == "function" && O7(i),
        Qt && typeof Qt.setStrictMode == "function")
            try {
                Qt.setStrictMode($l, i)
            } catch {}
    }
    var en = Math.clz32 ? Math.clz32 : z7
      , D7 = Math.log
      , L7 = Math.LN2;
    function z7(i) {
        return i >>>= 0,
        i === 0 ? 32 : 31 - (D7(i) / L7 | 0) | 0
    }
    var Oa = 256
      , Da = 262144
      , La = 4194304;
    function Vi(i) {
        var s = i & 42;
        if (s !== 0)
            return s;
        switch (i & -i) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
            return i & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return i & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return i & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return i
        }
    }
    function za(i, s, c) {
        var d = i.pendingLanes;
        if (d === 0)
            return 0;
        var g = 0
          , v = i.suspendedLanes
          , x = i.pingedLanes;
        i = i.warmLanes;
        var M = d & 134217727;
        return M !== 0 ? (d = M & ~v,
        d !== 0 ? g = Vi(d) : (x &= M,
        x !== 0 ? g = Vi(x) : c || (c = M & ~i,
        c !== 0 && (g = Vi(c))))) : (M = d & ~v,
        M !== 0 ? g = Vi(M) : x !== 0 ? g = Vi(x) : c || (c = d & ~i,
        c !== 0 && (g = Vi(c)))),
        g === 0 ? 0 : s !== 0 && s !== g && (s & v) === 0 && (v = g & -g,
        c = s & -s,
        v >= c || v === 32 && (c & 4194048) !== 0) ? s : g
    }
    function Fl(i, s) {
        return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & s) === 0
    }
    function _7(i, s) {
        switch (i) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return s + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return s + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function Rg() {
        var i = La;
        return La <<= 1,
        (La & 62914560) === 0 && (La = 4194304),
        i
    }
    function id(i) {
        for (var s = [], c = 0; 31 > c; c++)
            s.push(i);
        return s
    }
    function Kl(i, s) {
        i.pendingLanes |= s,
        s !== 268435456 && (i.suspendedLanes = 0,
        i.pingedLanes = 0,
        i.warmLanes = 0)
    }
    function B7(i, s, c, d, g, v) {
        var x = i.pendingLanes;
        i.pendingLanes = c,
        i.suspendedLanes = 0,
        i.pingedLanes = 0,
        i.warmLanes = 0,
        i.expiredLanes &= c,
        i.entangledLanes &= c,
        i.errorRecoveryDisabledLanes &= c,
        i.shellSuspendCounter = 0;
        var M = i.entanglements
          , N = i.expirationTimes
          , I = i.hiddenUpdates;
        for (c = x & ~c; 0 < c; ) {
            var K = 31 - en(c)
              , Y = 1 << K;
            M[K] = 0,
            N[K] = -1;
            var V = I[K];
            if (V !== null)
                for (I[K] = null,
                K = 0; K < V.length; K++) {
                    var F = V[K];
                    F !== null && (F.lane &= -536870913)
                }
            c &= ~Y
        }
        d !== 0 && Og(i, d, 0),
        v !== 0 && g === 0 && i.tag !== 0 && (i.suspendedLanes |= v & ~(x & ~s))
    }
    function Og(i, s, c) {
        i.pendingLanes |= s,
        i.suspendedLanes &= ~s;
        var d = 31 - en(s);
        i.entangledLanes |= s,
        i.entanglements[d] = i.entanglements[d] | 1073741824 | c & 261930
    }
    function Dg(i, s) {
        var c = i.entangledLanes |= s;
        for (i = i.entanglements; c; ) {
            var d = 31 - en(c)
              , g = 1 << d;
            g & s | i[d] & s && (i[d] |= s),
            c &= ~g
        }
    }
    function Lg(i, s) {
        var c = s & -s;
        return c = (c & 42) !== 0 ? 1 : od(c),
        (c & (i.suspendedLanes | s)) !== 0 ? 0 : c
    }
    function od(i) {
        switch (i) {
        case 2:
            i = 1;
            break;
        case 8:
            i = 4;
            break;
        case 32:
            i = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            i = 128;
            break;
        case 268435456:
            i = 134217728;
            break;
        default:
            i = 0
        }
        return i
    }
    function ld(i) {
        return i &= -i,
        2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function zg() {
        var i = P.p;
        return i !== 0 ? i : (i = window.event,
        i === void 0 ? 32 : bv(i.type))
    }
    function _g(i, s) {
        var c = P.p;
        try {
            return P.p = i,
            s()
        } finally {
            P.p = c
        }
    }
    var Hr = Math.random().toString(36).slice(2)
      , Ct = "__reactFiber$" + Hr
      , Ut = "__reactProps$" + Hr
      , Do = "__reactContainer$" + Hr
      , sd = "__reactEvents$" + Hr
      , j7 = "__reactListeners$" + Hr
      , H7 = "__reactHandles$" + Hr
      , Bg = "__reactResources$" + Hr
      , Gl = "__reactMarker$" + Hr;
    function ad(i) {
        delete i[Ct],
        delete i[Ut],
        delete i[sd],
        delete i[j7],
        delete i[H7]
    }
    function Lo(i) {
        var s = i[Ct];
        if (s)
            return s;
        for (var c = i.parentNode; c; ) {
            if (s = c[Do] || c[Ct]) {
                if (c = s.alternate,
                s.child !== null || c !== null && c.child !== null)
                    for (i = rv(i); i !== null; ) {
                        if (c = i[Ct])
                            return c;
                        i = rv(i)
                    }
                return s
            }
            i = c,
            c = i.parentNode
        }
        return null
    }
    function zo(i) {
        if (i = i[Ct] || i[Do]) {
            var s = i.tag;
            if (s === 5 || s === 6 || s === 13 || s === 31 || s === 26 || s === 27 || s === 3)
                return i
        }
        return null
    }
    function Yl(i) {
        var s = i.tag;
        if (s === 5 || s === 26 || s === 27 || s === 6)
            return i.stateNode;
        throw Error(r(33))
    }
    function _o(i) {
        var s = i[Bg];
        return s || (s = i[Bg] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        s
    }
    function pt(i) {
        i[Gl] = !0
    }
    var jg = new Set
      , Hg = {};
    function Ui(i, s) {
        Bo(i, s),
        Bo(i + "Capture", s)
    }
    function Bo(i, s) {
        for (Hg[i] = s,
        i = 0; i < s.length; i++)
            jg.add(s[i])
    }
    var I7 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , Ig = {}
      , Vg = {};
    function V7(i) {
        return td.call(Vg, i) ? !0 : td.call(Ig, i) ? !1 : I7.test(i) ? Vg[i] = !0 : (Ig[i] = !0,
        !1)
    }
    function _a(i, s, c) {
        if (V7(s))
            if (c === null)
                i.removeAttribute(s);
            else {
                switch (typeof c) {
                case "undefined":
                case "function":
                case "symbol":
                    i.removeAttribute(s);
                    return;
                case "boolean":
                    var d = s.toLowerCase().slice(0, 5);
                    if (d !== "data-" && d !== "aria-") {
                        i.removeAttribute(s);
                        return
                    }
                }
                i.setAttribute(s, "" + c)
            }
    }
    function Ba(i, s, c) {
        if (c === null)
            i.removeAttribute(s);
        else {
            switch (typeof c) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                i.removeAttribute(s);
                return
            }
            i.setAttribute(s, "" + c)
        }
    }
    function rr(i, s, c, d) {
        if (d === null)
            i.removeAttribute(c);
        else {
            switch (typeof d) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                i.removeAttribute(c);
                return
            }
            i.setAttributeNS(s, c, "" + d)
        }
    }
    function hn(i) {
        switch (typeof i) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return i;
        case "object":
            return i;
        default:
            return ""
        }
    }
    function Ug(i) {
        var s = i.type;
        return (i = i.nodeName) && i.toLowerCase() === "input" && (s === "checkbox" || s === "radio")
    }
    function U7(i, s, c) {
        var d = Object.getOwnPropertyDescriptor(i.constructor.prototype, s);
        if (!i.hasOwnProperty(s) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
            var g = d.get
              , v = d.set;
            return Object.defineProperty(i, s, {
                configurable: !0,
                get: function() {
                    return g.call(this)
                },
                set: function(x) {
                    c = "" + x,
                    v.call(this, x)
                }
            }),
            Object.defineProperty(i, s, {
                enumerable: d.enumerable
            }),
            {
                getValue: function() {
                    return c
                },
                setValue: function(x) {
                    c = "" + x
                },
                stopTracking: function() {
                    i._valueTracker = null,
                    delete i[s]
                }
            }
        }
    }
    function cd(i) {
        if (!i._valueTracker) {
            var s = Ug(i) ? "checked" : "value";
            i._valueTracker = U7(i, s, "" + i[s])
        }
    }
    function Pg(i) {
        if (!i)
            return !1;
        var s = i._valueTracker;
        if (!s)
            return !0;
        var c = s.getValue()
          , d = "";
        return i && (d = Ug(i) ? i.checked ? "true" : "false" : i.value),
        i = d,
        i !== c ? (s.setValue(i),
        !0) : !1
    }
    function ja(i) {
        if (i = i || (typeof document < "u" ? document : void 0),
        typeof i > "u")
            return null;
        try {
            return i.activeElement || i.body
        } catch {
            return i.body
        }
    }
    var P7 = /[\n"\\]/g;
    function pn(i) {
        return i.replace(P7, function(s) {
            return "\\" + s.charCodeAt(0).toString(16) + " "
        })
    }
    function ud(i, s, c, d, g, v, x, M) {
        i.name = "",
        x != null && typeof x != "function" && typeof x != "symbol" && typeof x != "boolean" ? i.type = x : i.removeAttribute("type"),
        s != null ? x === "number" ? (s === 0 && i.value === "" || i.value != s) && (i.value = "" + hn(s)) : i.value !== "" + hn(s) && (i.value = "" + hn(s)) : x !== "submit" && x !== "reset" || i.removeAttribute("value"),
        s != null ? fd(i, x, hn(s)) : c != null ? fd(i, x, hn(c)) : d != null && i.removeAttribute("value"),
        g == null && v != null && (i.defaultChecked = !!v),
        g != null && (i.checked = g && typeof g != "function" && typeof g != "symbol"),
        M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" ? i.name = "" + hn(M) : i.removeAttribute("name")
    }
    function qg(i, s, c, d, g, v, x, M) {
        if (v != null && typeof v != "function" && typeof v != "symbol" && typeof v != "boolean" && (i.type = v),
        s != null || c != null) {
            if (!(v !== "submit" && v !== "reset" || s != null)) {
                cd(i);
                return
            }
            c = c != null ? "" + hn(c) : "",
            s = s != null ? "" + hn(s) : c,
            M || s === i.value || (i.value = s),
            i.defaultValue = s
        }
        d = d ?? g,
        d = typeof d != "function" && typeof d != "symbol" && !!d,
        i.checked = M ? i.checked : !!d,
        i.defaultChecked = !!d,
        x != null && typeof x != "function" && typeof x != "symbol" && typeof x != "boolean" && (i.name = x),
        cd(i)
    }
    function fd(i, s, c) {
        s === "number" && ja(i.ownerDocument) === i || i.defaultValue === "" + c || (i.defaultValue = "" + c)
    }
    function jo(i, s, c, d) {
        if (i = i.options,
        s) {
            s = {};
            for (var g = 0; g < c.length; g++)
                s["$" + c[g]] = !0;
            for (c = 0; c < i.length; c++)
                g = s.hasOwnProperty("$" + i[c].value),
                i[c].selected !== g && (i[c].selected = g),
                g && d && (i[c].defaultSelected = !0)
        } else {
            for (c = "" + hn(c),
            s = null,
            g = 0; g < i.length; g++) {
                if (i[g].value === c) {
                    i[g].selected = !0,
                    d && (i[g].defaultSelected = !0);
                    return
                }
                s !== null || i[g].disabled || (s = i[g])
            }
            s !== null && (s.selected = !0)
        }
    }
    function $g(i, s, c) {
        if (s != null && (s = "" + hn(s),
        s !== i.value && (i.value = s),
        c == null)) {
            i.defaultValue !== s && (i.defaultValue = s);
            return
        }
        i.defaultValue = c != null ? "" + hn(c) : ""
    }
    function Fg(i, s, c, d) {
        if (s == null) {
            if (d != null) {
                if (c != null)
                    throw Error(r(92));
                if (ae(d)) {
                    if (1 < d.length)
                        throw Error(r(93));
                    d = d[0]
                }
                c = d
            }
            c == null && (c = ""),
            s = c
        }
        c = hn(s),
        i.defaultValue = c,
        d = i.textContent,
        d === c && d !== "" && d !== null && (i.value = d),
        cd(i)
    }
    function Ho(i, s) {
        if (s) {
            var c = i.firstChild;
            if (c && c === i.lastChild && c.nodeType === 3) {
                c.nodeValue = s;
                return
            }
        }
        i.textContent = s
    }
    var q7 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function Kg(i, s, c) {
        var d = s.indexOf("--") === 0;
        c == null || typeof c == "boolean" || c === "" ? d ? i.setProperty(s, "") : s === "float" ? i.cssFloat = "" : i[s] = "" : d ? i.setProperty(s, c) : typeof c != "number" || c === 0 || q7.has(s) ? s === "float" ? i.cssFloat = c : i[s] = ("" + c).trim() : i[s] = c + "px"
    }
    function Gg(i, s, c) {
        if (s != null && typeof s != "object")
            throw Error(r(62));
        if (i = i.style,
        c != null) {
            for (var d in c)
                !c.hasOwnProperty(d) || s != null && s.hasOwnProperty(d) || (d.indexOf("--") === 0 ? i.setProperty(d, "") : d === "float" ? i.cssFloat = "" : i[d] = "");
            for (var g in s)
                d = s[g],
                s.hasOwnProperty(g) && c[g] !== d && Kg(i, g, d)
        } else
            for (var v in s)
                s.hasOwnProperty(v) && Kg(i, v, s[v])
    }
    function dd(i) {
        if (i.indexOf("-") === -1)
            return !1;
        switch (i) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var $7 = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , F7 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Ha(i) {
        return F7.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i
    }
    function ir() {}
    var hd = null;
    function pd(i) {
        return i = i.target || i.srcElement || window,
        i.correspondingUseElement && (i = i.correspondingUseElement),
        i.nodeType === 3 ? i.parentNode : i
    }
    var Io = null
      , Vo = null;
    function Yg(i) {
        var s = zo(i);
        if (s && (i = s.stateNode)) {
            var c = i[Ut] || null;
            e: switch (i = s.stateNode,
            s.type) {
            case "input":
                if (ud(i, c.value, c.defaultValue, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name),
                s = c.name,
                c.type === "radio" && s != null) {
                    for (c = i; c.parentNode; )
                        c = c.parentNode;
                    for (c = c.querySelectorAll('input[name="' + pn("" + s) + '"][type="radio"]'),
                    s = 0; s < c.length; s++) {
                        var d = c[s];
                        if (d !== i && d.form === i.form) {
                            var g = d[Ut] || null;
                            if (!g)
                                throw Error(r(90));
                            ud(d, g.value, g.defaultValue, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name)
                        }
                    }
                    for (s = 0; s < c.length; s++)
                        d = c[s],
                        d.form === i.form && Pg(d)
                }
                break e;
            case "textarea":
                $g(i, c.value, c.defaultValue);
                break e;
            case "select":
                s = c.value,
                s != null && jo(i, !!c.multiple, s, !1)
            }
        }
    }
    var md = !1;
    function Zg(i, s, c) {
        if (md)
            return i(s, c);
        md = !0;
        try {
            var d = i(s);
            return d
        } finally {
            if (md = !1,
            (Io !== null || Vo !== null) && (Tc(),
            Io && (s = Io,
            i = Vo,
            Vo = Io = null,
            Yg(s),
            i)))
                for (s = 0; s < i.length; s++)
                    Yg(i[s])
        }
    }
    function Zl(i, s) {
        var c = i.stateNode;
        if (c === null)
            return null;
        var d = c[Ut] || null;
        if (d === null)
            return null;
        c = d[s];
        e: switch (s) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (d = !d.disabled) || (i = i.type,
            d = !(i === "button" || i === "input" || i === "select" || i === "textarea")),
            i = !d;
            break e;
        default:
            i = !1
        }
        if (i)
            return null;
        if (c && typeof c != "function")
            throw Error(r(231, s, typeof c));
        return c
    }
    var or = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , gd = !1;
    if (or)
        try {
            var Wl = {};
            Object.defineProperty(Wl, "passive", {
                get: function() {
                    gd = !0
                }
            }),
            window.addEventListener("test", Wl, Wl),
            window.removeEventListener("test", Wl, Wl)
        } catch {
            gd = !1
        }
    var Ir = null
      , yd = null
      , Ia = null;
    function Wg() {
        if (Ia)
            return Ia;
        var i, s = yd, c = s.length, d, g = "value"in Ir ? Ir.value : Ir.textContent, v = g.length;
        for (i = 0; i < c && s[i] === g[i]; i++)
            ;
        var x = c - i;
        for (d = 1; d <= x && s[c - d] === g[v - d]; d++)
            ;
        return Ia = g.slice(i, 1 < d ? 1 - d : void 0)
    }
    function Va(i) {
        var s = i.keyCode;
        return "charCode"in i ? (i = i.charCode,
        i === 0 && s === 13 && (i = 13)) : i = s,
        i === 10 && (i = 13),
        32 <= i || i === 13 ? i : 0
    }
    function Ua() {
        return !0
    }
    function Xg() {
        return !1
    }
    function Pt(i) {
        function s(c, d, g, v, x) {
            this._reactName = c,
            this._targetInst = g,
            this.type = d,
            this.nativeEvent = v,
            this.target = x,
            this.currentTarget = null;
            for (var M in i)
                i.hasOwnProperty(M) && (c = i[M],
                this[M] = c ? c(v) : v[M]);
            return this.isDefaultPrevented = (v.defaultPrevented != null ? v.defaultPrevented : v.returnValue === !1) ? Ua : Xg,
            this.isPropagationStopped = Xg,
            this
        }
        return m(s.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var c = this.nativeEvent;
                c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1),
                this.isDefaultPrevented = Ua)
            },
            stopPropagation: function() {
                var c = this.nativeEvent;
                c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0),
                this.isPropagationStopped = Ua)
            },
            persist: function() {},
            isPersistent: Ua
        }),
        s
    }
    var Pi = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(i) {
            return i.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Pa = Pt(Pi), Xl = m({}, Pi, {
        view: 0,
        detail: 0
    }), K7 = Pt(Xl), vd, bd, Jl, qa = m({}, Xl, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: Sd,
        button: 0,
        buttons: 0,
        relatedTarget: function(i) {
            return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget
        },
        movementX: function(i) {
            return "movementX"in i ? i.movementX : (i !== Jl && (Jl && i.type === "mousemove" ? (vd = i.screenX - Jl.screenX,
            bd = i.screenY - Jl.screenY) : bd = vd = 0,
            Jl = i),
            vd)
        },
        movementY: function(i) {
            return "movementY"in i ? i.movementY : bd
        }
    }), Jg = Pt(qa), G7 = m({}, qa, {
        dataTransfer: 0
    }), Y7 = Pt(G7), Z7 = m({}, Xl, {
        relatedTarget: 0
    }), Cd = Pt(Z7), W7 = m({}, Pi, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), X7 = Pt(W7), J7 = m({}, Pi, {
        clipboardData: function(i) {
            return "clipboardData"in i ? i.clipboardData : window.clipboardData
        }
    }), Q7 = Pt(J7), ew = m({}, Pi, {
        data: 0
    }), Qg = Pt(ew), tw = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, nw = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, rw = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function iw(i) {
        var s = this.nativeEvent;
        return s.getModifierState ? s.getModifierState(i) : (i = rw[i]) ? !!s[i] : !1
    }
    function Sd() {
        return iw
    }
    var ow = m({}, Xl, {
        key: function(i) {
            if (i.key) {
                var s = tw[i.key] || i.key;
                if (s !== "Unidentified")
                    return s
            }
            return i.type === "keypress" ? (i = Va(i),
            i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? nw[i.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: Sd,
        charCode: function(i) {
            return i.type === "keypress" ? Va(i) : 0
        },
        keyCode: function(i) {
            return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0
        },
        which: function(i) {
            return i.type === "keypress" ? Va(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0
        }
    })
      , lw = Pt(ow)
      , sw = m({}, qa, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , e0 = Pt(sw)
      , aw = m({}, Xl, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: Sd
    })
      , cw = Pt(aw)
      , uw = m({}, Pi, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , fw = Pt(uw)
      , dw = m({}, qa, {
        deltaX: function(i) {
            return "deltaX"in i ? i.deltaX : "wheelDeltaX"in i ? -i.wheelDeltaX : 0
        },
        deltaY: function(i) {
            return "deltaY"in i ? i.deltaY : "wheelDeltaY"in i ? -i.wheelDeltaY : "wheelDelta"in i ? -i.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , hw = Pt(dw)
      , pw = m({}, Pi, {
        newState: 0,
        oldState: 0
    })
      , mw = Pt(pw)
      , gw = [9, 13, 27, 32]
      , xd = or && "CompositionEvent"in window
      , Ql = null;
    or && "documentMode"in document && (Ql = document.documentMode);
    var yw = or && "TextEvent"in window && !Ql
      , t0 = or && (!xd || Ql && 8 < Ql && 11 >= Ql)
      , n0 = " "
      , r0 = !1;
    function i0(i, s) {
        switch (i) {
        case "keyup":
            return gw.indexOf(s.keyCode) !== -1;
        case "keydown":
            return s.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function o0(i) {
        return i = i.detail,
        typeof i == "object" && "data"in i ? i.data : null
    }
    var Uo = !1;
    function vw(i, s) {
        switch (i) {
        case "compositionend":
            return o0(s);
        case "keypress":
            return s.which !== 32 ? null : (r0 = !0,
            n0);
        case "textInput":
            return i = s.data,
            i === n0 && r0 ? null : i;
        default:
            return null
        }
    }
    function bw(i, s) {
        if (Uo)
            return i === "compositionend" || !xd && i0(i, s) ? (i = Wg(),
            Ia = yd = Ir = null,
            Uo = !1,
            i) : null;
        switch (i) {
        case "paste":
            return null;
        case "keypress":
            if (!(s.ctrlKey || s.altKey || s.metaKey) || s.ctrlKey && s.altKey) {
                if (s.char && 1 < s.char.length)
                    return s.char;
                if (s.which)
                    return String.fromCharCode(s.which)
            }
            return null;
        case "compositionend":
            return t0 && s.locale !== "ko" ? null : s.data;
        default:
            return null
        }
    }
    var Cw = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function l0(i) {
        var s = i && i.nodeName && i.nodeName.toLowerCase();
        return s === "input" ? !!Cw[i.type] : s === "textarea"
    }
    function s0(i, s, c, d) {
        Io ? Vo ? Vo.push(d) : Vo = [d] : Io = d,
        s = Dc(s, "onChange"),
        0 < s.length && (c = new Pa("onChange","change",null,c,d),
        i.push({
            event: c,
            listeners: s
        }))
    }
    var es = null
      , ts = null;
    function Sw(i) {
        q2(i, 0)
    }
    function $a(i) {
        var s = Yl(i);
        if (Pg(s))
            return i
    }
    function a0(i, s) {
        if (i === "change")
            return s
    }
    var c0 = !1;
    if (or) {
        var wd;
        if (or) {
            var Ed = "oninput"in document;
            if (!Ed) {
                var u0 = document.createElement("div");
                u0.setAttribute("oninput", "return;"),
                Ed = typeof u0.oninput == "function"
            }
            wd = Ed
        } else
            wd = !1;
        c0 = wd && (!document.documentMode || 9 < document.documentMode)
    }
    function f0() {
        es && (es.detachEvent("onpropertychange", d0),
        ts = es = null)
    }
    function d0(i) {
        if (i.propertyName === "value" && $a(ts)) {
            var s = [];
            s0(s, ts, i, pd(i)),
            Zg(Sw, s)
        }
    }
    function xw(i, s, c) {
        i === "focusin" ? (f0(),
        es = s,
        ts = c,
        es.attachEvent("onpropertychange", d0)) : i === "focusout" && f0()
    }
    function ww(i) {
        if (i === "selectionchange" || i === "keyup" || i === "keydown")
            return $a(ts)
    }
    function Ew(i, s) {
        if (i === "click")
            return $a(s)
    }
    function Tw(i, s) {
        if (i === "input" || i === "change")
            return $a(s)
    }
    function kw(i, s) {
        return i === s && (i !== 0 || 1 / i === 1 / s) || i !== i && s !== s
    }
    var tn = typeof Object.is == "function" ? Object.is : kw;
    function ns(i, s) {
        if (tn(i, s))
            return !0;
        if (typeof i != "object" || i === null || typeof s != "object" || s === null)
            return !1;
        var c = Object.keys(i)
          , d = Object.keys(s);
        if (c.length !== d.length)
            return !1;
        for (d = 0; d < c.length; d++) {
            var g = c[d];
            if (!td.call(s, g) || !tn(i[g], s[g]))
                return !1
        }
        return !0
    }
    function h0(i) {
        for (; i && i.firstChild; )
            i = i.firstChild;
        return i
    }
    function p0(i, s) {
        var c = h0(i);
        i = 0;
        for (var d; c; ) {
            if (c.nodeType === 3) {
                if (d = i + c.textContent.length,
                i <= s && d >= s)
                    return {
                        node: c,
                        offset: s - i
                    };
                i = d
            }
            e: {
                for (; c; ) {
                    if (c.nextSibling) {
                        c = c.nextSibling;
                        break e
                    }
                    c = c.parentNode
                }
                c = void 0
            }
            c = h0(c)
        }
    }
    function m0(i, s) {
        return i && s ? i === s ? !0 : i && i.nodeType === 3 ? !1 : s && s.nodeType === 3 ? m0(i, s.parentNode) : "contains"in i ? i.contains(s) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(s) & 16) : !1 : !1
    }
    function g0(i) {
        i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
        for (var s = ja(i.document); s instanceof i.HTMLIFrameElement; ) {
            try {
                var c = typeof s.contentWindow.location.href == "string"
            } catch {
                c = !1
            }
            if (c)
                i = s.contentWindow;
            else
                break;
            s = ja(i.document)
        }
        return s
    }
    function Td(i) {
        var s = i && i.nodeName && i.nodeName.toLowerCase();
        return s && (s === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || s === "textarea" || i.contentEditable === "true")
    }
    var Mw = or && "documentMode"in document && 11 >= document.documentMode
      , Po = null
      , kd = null
      , rs = null
      , Md = !1;
    function y0(i, s, c) {
        var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
        Md || Po == null || Po !== ja(d) || (d = Po,
        "selectionStart"in d && Td(d) ? d = {
            start: d.selectionStart,
            end: d.selectionEnd
        } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(),
        d = {
            anchorNode: d.anchorNode,
            anchorOffset: d.anchorOffset,
            focusNode: d.focusNode,
            focusOffset: d.focusOffset
        }),
        rs && ns(rs, d) || (rs = d,
        d = Dc(kd, "onSelect"),
        0 < d.length && (s = new Pa("onSelect","select",null,s,c),
        i.push({
            event: s,
            listeners: d
        }),
        s.target = Po)))
    }
    function qi(i, s) {
        var c = {};
        return c[i.toLowerCase()] = s.toLowerCase(),
        c["Webkit" + i] = "webkit" + s,
        c["Moz" + i] = "moz" + s,
        c
    }
    var qo = {
        animationend: qi("Animation", "AnimationEnd"),
        animationiteration: qi("Animation", "AnimationIteration"),
        animationstart: qi("Animation", "AnimationStart"),
        transitionrun: qi("Transition", "TransitionRun"),
        transitionstart: qi("Transition", "TransitionStart"),
        transitioncancel: qi("Transition", "TransitionCancel"),
        transitionend: qi("Transition", "TransitionEnd")
    }
      , Ad = {}
      , v0 = {};
    or && (v0 = document.createElement("div").style,
    "AnimationEvent"in window || (delete qo.animationend.animation,
    delete qo.animationiteration.animation,
    delete qo.animationstart.animation),
    "TransitionEvent"in window || delete qo.transitionend.transition);
    function $i(i) {
        if (Ad[i])
            return Ad[i];
        if (!qo[i])
            return i;
        var s = qo[i], c;
        for (c in s)
            if (s.hasOwnProperty(c) && c in v0)
                return Ad[i] = s[c];
        return i
    }
    var b0 = $i("animationend")
      , C0 = $i("animationiteration")
      , S0 = $i("animationstart")
      , Aw = $i("transitionrun")
      , Nw = $i("transitionstart")
      , Rw = $i("transitioncancel")
      , x0 = $i("transitionend")
      , w0 = new Map
      , Nd = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Nd.push("scrollEnd");
    function On(i, s) {
        w0.set(i, s),
        Ui(s, [i])
    }
    var Fa = typeof reportError == "function" ? reportError : function(i) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var s = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
                error: i
            });
            if (!window.dispatchEvent(s))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", i);
            return
        }
        console.error(i)
    }
      , mn = []
      , $o = 0
      , Rd = 0;
    function Ka() {
        for (var i = $o, s = Rd = $o = 0; s < i; ) {
            var c = mn[s];
            mn[s++] = null;
            var d = mn[s];
            mn[s++] = null;
            var g = mn[s];
            mn[s++] = null;
            var v = mn[s];
            if (mn[s++] = null,
            d !== null && g !== null) {
                var x = d.pending;
                x === null ? g.next = g : (g.next = x.next,
                x.next = g),
                d.pending = g
            }
            v !== 0 && E0(c, g, v)
        }
    }
    function Ga(i, s, c, d) {
        mn[$o++] = i,
        mn[$o++] = s,
        mn[$o++] = c,
        mn[$o++] = d,
        Rd |= d,
        i.lanes |= d,
        i = i.alternate,
        i !== null && (i.lanes |= d)
    }
    function Od(i, s, c, d) {
        return Ga(i, s, c, d),
        Ya(i)
    }
    function Fi(i, s) {
        return Ga(i, null, null, s),
        Ya(i)
    }
    function E0(i, s, c) {
        i.lanes |= c;
        var d = i.alternate;
        d !== null && (d.lanes |= c);
        for (var g = !1, v = i.return; v !== null; )
            v.childLanes |= c,
            d = v.alternate,
            d !== null && (d.childLanes |= c),
            v.tag === 22 && (i = v.stateNode,
            i === null || i._visibility & 1 || (g = !0)),
            i = v,
            v = v.return;
        return i.tag === 3 ? (v = i.stateNode,
        g && s !== null && (g = 31 - en(c),
        i = v.hiddenUpdates,
        d = i[g],
        d === null ? i[g] = [s] : d.push(s),
        s.lane = c | 536870912),
        v) : null
    }
    function Ya(i) {
        if (50 < ks)
            throw ks = 0,
            Vh = null,
            Error(r(185));
        for (var s = i.return; s !== null; )
            i = s,
            s = i.return;
        return i.tag === 3 ? i.stateNode : null
    }
    var Fo = {};
    function Ow(i, s, c, d) {
        this.tag = i,
        this.key = c,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = s,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = d,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function nn(i, s, c, d) {
        return new Ow(i,s,c,d)
    }
    function Dd(i) {
        return i = i.prototype,
        !(!i || !i.isReactComponent)
    }
    function lr(i, s) {
        var c = i.alternate;
        return c === null ? (c = nn(i.tag, s, i.key, i.mode),
        c.elementType = i.elementType,
        c.type = i.type,
        c.stateNode = i.stateNode,
        c.alternate = i,
        i.alternate = c) : (c.pendingProps = s,
        c.type = i.type,
        c.flags = 0,
        c.subtreeFlags = 0,
        c.deletions = null),
        c.flags = i.flags & 65011712,
        c.childLanes = i.childLanes,
        c.lanes = i.lanes,
        c.child = i.child,
        c.memoizedProps = i.memoizedProps,
        c.memoizedState = i.memoizedState,
        c.updateQueue = i.updateQueue,
        s = i.dependencies,
        c.dependencies = s === null ? null : {
            lanes: s.lanes,
            firstContext: s.firstContext
        },
        c.sibling = i.sibling,
        c.index = i.index,
        c.ref = i.ref,
        c.refCleanup = i.refCleanup,
        c
    }
    function T0(i, s) {
        i.flags &= 65011714;
        var c = i.alternate;
        return c === null ? (i.childLanes = 0,
        i.lanes = s,
        i.child = null,
        i.subtreeFlags = 0,
        i.memoizedProps = null,
        i.memoizedState = null,
        i.updateQueue = null,
        i.dependencies = null,
        i.stateNode = null) : (i.childLanes = c.childLanes,
        i.lanes = c.lanes,
        i.child = c.child,
        i.subtreeFlags = 0,
        i.deletions = null,
        i.memoizedProps = c.memoizedProps,
        i.memoizedState = c.memoizedState,
        i.updateQueue = c.updateQueue,
        i.type = c.type,
        s = c.dependencies,
        i.dependencies = s === null ? null : {
            lanes: s.lanes,
            firstContext: s.firstContext
        }),
        i
    }
    function Za(i, s, c, d, g, v) {
        var x = 0;
        if (d = i,
        typeof i == "function")
            Dd(i) && (x = 1);
        else if (typeof i == "string")
            x = B9(i, c, re.current) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
        else
            e: switch (i) {
            case ne:
                return i = nn(31, c, s, g),
                i.elementType = ne,
                i.lanes = v,
                i;
            case S:
                return Ki(c.children, g, v, s);
            case w:
                x = 8,
                g |= 24;
                break;
            case k:
                return i = nn(12, c, s, g | 2),
                i.elementType = k,
                i.lanes = v,
                i;
            case z:
                return i = nn(13, c, s, g),
                i.elementType = z,
                i.lanes = v,
                i;
            case $:
                return i = nn(19, c, s, g),
                i.elementType = $,
                i.lanes = v,
                i;
            default:
                if (typeof i == "object" && i !== null)
                    switch (i.$$typeof) {
                    case O:
                        x = 10;
                        break e;
                    case A:
                        x = 9;
                        break e;
                    case B:
                        x = 11;
                        break e;
                    case _:
                        x = 14;
                        break e;
                    case W:
                        x = 16,
                        d = null;
                        break e
                    }
                x = 29,
                c = Error(r(130, i === null ? "null" : typeof i, "")),
                d = null
            }
        return s = nn(x, c, s, g),
        s.elementType = i,
        s.type = d,
        s.lanes = v,
        s
    }
    function Ki(i, s, c, d) {
        return i = nn(7, i, d, s),
        i.lanes = c,
        i
    }
    function Ld(i, s, c) {
        return i = nn(6, i, null, s),
        i.lanes = c,
        i
    }
    function k0(i) {
        var s = nn(18, null, null, 0);
        return s.stateNode = i,
        s
    }
    function zd(i, s, c) {
        return s = nn(4, i.children !== null ? i.children : [], i.key, s),
        s.lanes = c,
        s.stateNode = {
            containerInfo: i.containerInfo,
            pendingChildren: null,
            implementation: i.implementation
        },
        s
    }
    var M0 = new WeakMap;
    function gn(i, s) {
        if (typeof i == "object" && i !== null) {
            var c = M0.get(i);
            return c !== void 0 ? c : (s = {
                value: i,
                source: s,
                stack: kg(s)
            },
            M0.set(i, s),
            s)
        }
        return {
            value: i,
            source: s,
            stack: kg(s)
        }
    }
    var Ko = []
      , Go = 0
      , Wa = null
      , is = 0
      , yn = []
      , vn = 0
      , Vr = null
      , Hn = 1
      , In = "";
    function sr(i, s) {
        Ko[Go++] = is,
        Ko[Go++] = Wa,
        Wa = i,
        is = s
    }
    function A0(i, s, c) {
        yn[vn++] = Hn,
        yn[vn++] = In,
        yn[vn++] = Vr,
        Vr = i;
        var d = Hn;
        i = In;
        var g = 32 - en(d) - 1;
        d &= ~(1 << g),
        c += 1;
        var v = 32 - en(s) + g;
        if (30 < v) {
            var x = g - g % 5;
            v = (d & (1 << x) - 1).toString(32),
            d >>= x,
            g -= x,
            Hn = 1 << 32 - en(s) + g | c << g | d,
            In = v + i
        } else
            Hn = 1 << v | c << g | d,
            In = i
    }
    function _d(i) {
        i.return !== null && (sr(i, 1),
        A0(i, 1, 0))
    }
    function Bd(i) {
        for (; i === Wa; )
            Wa = Ko[--Go],
            Ko[Go] = null,
            is = Ko[--Go],
            Ko[Go] = null;
        for (; i === Vr; )
            Vr = yn[--vn],
            yn[vn] = null,
            In = yn[--vn],
            yn[vn] = null,
            Hn = yn[--vn],
            yn[vn] = null
    }
    function N0(i, s) {
        yn[vn++] = Hn,
        yn[vn++] = In,
        yn[vn++] = Vr,
        Hn = s.id,
        In = s.overflow,
        Vr = i
    }
    var St = null
      , $e = null
      , Ne = !1
      , Ur = null
      , bn = !1
      , jd = Error(r(519));
    function Pr(i) {
        var s = Error(r(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
        throw ls(gn(s, i)),
        jd
    }
    function R0(i) {
        var s = i.stateNode
          , c = i.type
          , d = i.memoizedProps;
        switch (s[Ct] = i,
        s[Ut] = d,
        c) {
        case "dialog":
            ke("cancel", s),
            ke("close", s);
            break;
        case "iframe":
        case "object":
        case "embed":
            ke("load", s);
            break;
        case "video":
        case "audio":
            for (c = 0; c < As.length; c++)
                ke(As[c], s);
            break;
        case "source":
            ke("error", s);
            break;
        case "img":
        case "image":
        case "link":
            ke("error", s),
            ke("load", s);
            break;
        case "details":
            ke("toggle", s);
            break;
        case "input":
            ke("invalid", s),
            qg(s, d.value, d.defaultValue, d.checked, d.defaultChecked, d.type, d.name, !0);
            break;
        case "select":
            ke("invalid", s);
            break;
        case "textarea":
            ke("invalid", s),
            Fg(s, d.value, d.defaultValue, d.children)
        }
        c = d.children,
        typeof c != "string" && typeof c != "number" && typeof c != "bigint" || s.textContent === "" + c || d.suppressHydrationWarning === !0 || G2(s.textContent, c) ? (d.popover != null && (ke("beforetoggle", s),
        ke("toggle", s)),
        d.onScroll != null && ke("scroll", s),
        d.onScrollEnd != null && ke("scrollend", s),
        d.onClick != null && (s.onclick = ir),
        s = !0) : s = !1,
        s || Pr(i, !0)
    }
    function O0(i) {
        for (St = i.return; St; )
            switch (St.tag) {
            case 5:
            case 31:
            case 13:
                bn = !1;
                return;
            case 27:
            case 3:
                bn = !0;
                return;
            default:
                St = St.return
            }
    }
    function Yo(i) {
        if (i !== St)
            return !1;
        if (!Ne)
            return O0(i),
            Ne = !0,
            !1;
        var s = i.tag, c;
        if ((c = s !== 3 && s !== 27) && ((c = s === 5) && (c = i.type,
        c = !(c !== "form" && c !== "button") || tp(i.type, i.memoizedProps)),
        c = !c),
        c && $e && Pr(i),
        O0(i),
        s === 13) {
            if (i = i.memoizedState,
            i = i !== null ? i.dehydrated : null,
            !i)
                throw Error(r(317));
            $e = nv(i)
        } else if (s === 31) {
            if (i = i.memoizedState,
            i = i !== null ? i.dehydrated : null,
            !i)
                throw Error(r(317));
            $e = nv(i)
        } else
            s === 27 ? (s = $e,
            ni(i.type) ? (i = lp,
            lp = null,
            $e = i) : $e = s) : $e = St ? Sn(i.stateNode.nextSibling) : null;
        return !0
    }
    function Gi() {
        $e = St = null,
        Ne = !1
    }
    function Hd() {
        var i = Ur;
        return i !== null && (Kt === null ? Kt = i : Kt.push.apply(Kt, i),
        Ur = null),
        i
    }
    function ls(i) {
        Ur === null ? Ur = [i] : Ur.push(i)
    }
    var Id = R(null)
      , Yi = null
      , ar = null;
    function qr(i, s, c) {
        X(Id, s._currentValue),
        s._currentValue = c
    }
    function cr(i) {
        i._currentValue = Id.current,
        U(Id)
    }
    function Vd(i, s, c) {
        for (; i !== null; ) {
            var d = i.alternate;
            if ((i.childLanes & s) !== s ? (i.childLanes |= s,
            d !== null && (d.childLanes |= s)) : d !== null && (d.childLanes & s) !== s && (d.childLanes |= s),
            i === c)
                break;
            i = i.return
        }
    }
    function Ud(i, s, c, d) {
        var g = i.child;
        for (g !== null && (g.return = i); g !== null; ) {
            var v = g.dependencies;
            if (v !== null) {
                var x = g.child;
                v = v.firstContext;
                e: for (; v !== null; ) {
                    var M = v;
                    v = g;
                    for (var N = 0; N < s.length; N++)
                        if (M.context === s[N]) {
                            v.lanes |= c,
                            M = v.alternate,
                            M !== null && (M.lanes |= c),
                            Vd(v.return, c, i),
                            d || (x = null);
                            break e
                        }
                    v = M.next
                }
            } else if (g.tag === 18) {
                if (x = g.return,
                x === null)
                    throw Error(r(341));
                x.lanes |= c,
                v = x.alternate,
                v !== null && (v.lanes |= c),
                Vd(x, c, i),
                x = null
            } else
                x = g.child;
            if (x !== null)
                x.return = g;
            else
                for (x = g; x !== null; ) {
                    if (x === i) {
                        x = null;
                        break
                    }
                    if (g = x.sibling,
                    g !== null) {
                        g.return = x.return,
                        x = g;
                        break
                    }
                    x = x.return
                }
            g = x
        }
    }
    function Zo(i, s, c, d) {
        i = null;
        for (var g = s, v = !1; g !== null; ) {
            if (!v) {
                if ((g.flags & 524288) !== 0)
                    v = !0;
                else if ((g.flags & 262144) !== 0)
                    break
            }
            if (g.tag === 10) {
                var x = g.alternate;
                if (x === null)
                    throw Error(r(387));
                if (x = x.memoizedProps,
                x !== null) {
                    var M = g.type;
                    tn(g.pendingProps.value, x.value) || (i !== null ? i.push(M) : i = [M])
                }
            } else if (g === Se.current) {
                if (x = g.alternate,
                x === null)
                    throw Error(r(387));
                x.memoizedState.memoizedState !== g.memoizedState.memoizedState && (i !== null ? i.push(Ls) : i = [Ls])
            }
            g = g.return
        }
        i !== null && Ud(s, i, c, d),
        s.flags |= 262144
    }
    function Xa(i) {
        for (i = i.firstContext; i !== null; ) {
            if (!tn(i.context._currentValue, i.memoizedValue))
                return !0;
            i = i.next
        }
        return !1
    }
    function Zi(i) {
        Yi = i,
        ar = null,
        i = i.dependencies,
        i !== null && (i.firstContext = null)
    }
    function xt(i) {
        return D0(Yi, i)
    }
    function Ja(i, s) {
        return Yi === null && Zi(i),
        D0(i, s)
    }
    function D0(i, s) {
        var c = s._currentValue;
        if (s = {
            context: s,
            memoizedValue: c,
            next: null
        },
        ar === null) {
            if (i === null)
                throw Error(r(308));
            ar = s,
            i.dependencies = {
                lanes: 0,
                firstContext: s
            },
            i.flags |= 524288
        } else
            ar = ar.next = s;
        return c
    }
    var Dw = typeof AbortController < "u" ? AbortController : function() {
        var i = []
          , s = this.signal = {
            aborted: !1,
            addEventListener: function(c, d) {
                i.push(d)
            }
        };
        this.abort = function() {
            s.aborted = !0,
            i.forEach(function(c) {
                return c()
            })
        }
    }
      , Lw = t.unstable_scheduleCallback
      , zw = t.unstable_NormalPriority
      , st = {
        $$typeof: O,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function Pd() {
        return {
            controller: new Dw,
            data: new Map,
            refCount: 0
        }
    }
    function ss(i) {
        i.refCount--,
        i.refCount === 0 && Lw(zw, function() {
            i.controller.abort()
        })
    }
    var as = null
      , qd = 0
      , Wo = 0
      , Xo = null;
    function _w(i, s) {
        if (as === null) {
            var c = as = [];
            qd = 0,
            Wo = Kh(),
            Xo = {
                status: "pending",
                value: void 0,
                then: function(d) {
                    c.push(d)
                }
            }
        }
        return qd++,
        s.then(L0, L0),
        s
    }
    function L0() {
        if (--qd === 0 && as !== null) {
            Xo !== null && (Xo.status = "fulfilled");
            var i = as;
            as = null,
            Wo = 0,
            Xo = null;
            for (var s = 0; s < i.length; s++)
                (0,
                i[s])()
        }
    }
    function Bw(i, s) {
        var c = []
          , d = {
            status: "pending",
            value: null,
            reason: null,
            then: function(g) {
                c.push(g)
            }
        };
        return i.then(function() {
            d.status = "fulfilled",
            d.value = s;
            for (var g = 0; g < c.length; g++)
                (0,
                c[g])(s)
        }, function(g) {
            for (d.status = "rejected",
            d.reason = g,
            g = 0; g < c.length; g++)
                (0,
                c[g])(void 0)
        }),
        d
    }
    var z0 = j.S;
    j.S = function(i, s) {
        y2 = Jt(),
        typeof s == "object" && s !== null && typeof s.then == "function" && _w(i, s),
        z0 !== null && z0(i, s)
    }
    ;
    var Wi = R(null);
    function $d() {
        var i = Wi.current;
        return i !== null ? i : Ie.pooledCache
    }
    function Qa(i, s) {
        s === null ? X(Wi, Wi.current) : X(Wi, s.pool)
    }
    function _0() {
        var i = $d();
        return i === null ? null : {
            parent: st._currentValue,
            pool: i
        }
    }
    var Jo = Error(r(460))
      , Fd = Error(r(474))
      , ec = Error(r(542))
      , tc = {
        then: function() {}
    };
    function B0(i) {
        return i = i.status,
        i === "fulfilled" || i === "rejected"
    }
    function j0(i, s, c) {
        switch (c = i[c],
        c === void 0 ? i.push(s) : c !== s && (s.then(ir, ir),
        s = c),
        s.status) {
        case "fulfilled":
            return s.value;
        case "rejected":
            throw i = s.reason,
            I0(i),
            i;
        default:
            if (typeof s.status == "string")
                s.then(ir, ir);
            else {
                if (i = Ie,
                i !== null && 100 < i.shellSuspendCounter)
                    throw Error(r(482));
                i = s,
                i.status = "pending",
                i.then(function(d) {
                    if (s.status === "pending") {
                        var g = s;
                        g.status = "fulfilled",
                        g.value = d
                    }
                }, function(d) {
                    if (s.status === "pending") {
                        var g = s;
                        g.status = "rejected",
                        g.reason = d
                    }
                })
            }
            switch (s.status) {
            case "fulfilled":
                return s.value;
            case "rejected":
                throw i = s.reason,
                I0(i),
                i
            }
            throw Ji = s,
            Jo
        }
    }
    function Xi(i) {
        try {
            var s = i._init;
            return s(i._payload)
        } catch (c) {
            throw c !== null && typeof c == "object" && typeof c.then == "function" ? (Ji = c,
            Jo) : c
        }
    }
    var Ji = null;
    function H0() {
        if (Ji === null)
            throw Error(r(459));
        var i = Ji;
        return Ji = null,
        i
    }
    function I0(i) {
        if (i === Jo || i === ec)
            throw Error(r(483))
    }
    var Qo = null
      , cs = 0;
    function nc(i) {
        var s = cs;
        return cs += 1,
        Qo === null && (Qo = []),
        j0(Qo, i, s)
    }
    function us(i, s) {
        s = s.props.ref,
        i.ref = s !== void 0 ? s : null
    }
    function rc(i, s) {
        throw s.$$typeof === y ? Error(r(525)) : (i = Object.prototype.toString.call(s),
        Error(r(31, i === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : i)))
    }
    function V0(i) {
        function s(L, D) {
            if (i) {
                var H = L.deletions;
                H === null ? (L.deletions = [D],
                L.flags |= 16) : H.push(D)
            }
        }
        function c(L, D) {
            if (!i)
                return null;
            for (; D !== null; )
                s(L, D),
                D = D.sibling;
            return null
        }
        function d(L) {
            for (var D = new Map; L !== null; )
                L.key !== null ? D.set(L.key, L) : D.set(L.index, L),
                L = L.sibling;
            return D
        }
        function g(L, D) {
            return L = lr(L, D),
            L.index = 0,
            L.sibling = null,
            L
        }
        function v(L, D, H) {
            return L.index = H,
            i ? (H = L.alternate,
            H !== null ? (H = H.index,
            H < D ? (L.flags |= 67108866,
            D) : H) : (L.flags |= 67108866,
            D)) : (L.flags |= 1048576,
            D)
        }
        function x(L) {
            return i && L.alternate === null && (L.flags |= 67108866),
            L
        }
        function M(L, D, H, G) {
            return D === null || D.tag !== 6 ? (D = Ld(H, L.mode, G),
            D.return = L,
            D) : (D = g(D, H),
            D.return = L,
            D)
        }
        function N(L, D, H, G) {
            var he = H.type;
            return he === S ? K(L, D, H.props.children, G, H.key) : D !== null && (D.elementType === he || typeof he == "object" && he !== null && he.$$typeof === W && Xi(he) === D.type) ? (D = g(D, H.props),
            us(D, H),
            D.return = L,
            D) : (D = Za(H.type, H.key, H.props, null, L.mode, G),
            us(D, H),
            D.return = L,
            D)
        }
        function I(L, D, H, G) {
            return D === null || D.tag !== 4 || D.stateNode.containerInfo !== H.containerInfo || D.stateNode.implementation !== H.implementation ? (D = zd(H, L.mode, G),
            D.return = L,
            D) : (D = g(D, H.children || []),
            D.return = L,
            D)
        }
        function K(L, D, H, G, he) {
            return D === null || D.tag !== 7 ? (D = Ki(H, L.mode, G, he),
            D.return = L,
            D) : (D = g(D, H),
            D.return = L,
            D)
        }
        function Y(L, D, H) {
            if (typeof D == "string" && D !== "" || typeof D == "number" || typeof D == "bigint")
                return D = Ld("" + D, L.mode, H),
                D.return = L,
                D;
            if (typeof D == "object" && D !== null) {
                switch (D.$$typeof) {
                case b:
                    return H = Za(D.type, D.key, D.props, null, L.mode, H),
                    us(H, D),
                    H.return = L,
                    H;
                case C:
                    return D = zd(D, L.mode, H),
                    D.return = L,
                    D;
                case W:
                    return D = Xi(D),
                    Y(L, D, H)
                }
                if (ae(D) || pe(D))
                    return D = Ki(D, L.mode, H, null),
                    D.return = L,
                    D;
                if (typeof D.then == "function")
                    return Y(L, nc(D), H);
                if (D.$$typeof === O)
                    return Y(L, Ja(L, D), H);
                rc(L, D)
            }
            return null
        }
        function V(L, D, H, G) {
            var he = D !== null ? D.key : null;
            if (typeof H == "string" && H !== "" || typeof H == "number" || typeof H == "bigint")
                return he !== null ? null : M(L, D, "" + H, G);
            if (typeof H == "object" && H !== null) {
                switch (H.$$typeof) {
                case b:
                    return H.key === he ? N(L, D, H, G) : null;
                case C:
                    return H.key === he ? I(L, D, H, G) : null;
                case W:
                    return H = Xi(H),
                    V(L, D, H, G)
                }
                if (ae(H) || pe(H))
                    return he !== null ? null : K(L, D, H, G, null);
                if (typeof H.then == "function")
                    return V(L, D, nc(H), G);
                if (H.$$typeof === O)
                    return V(L, D, Ja(L, H), G);
                rc(L, H)
            }
            return null
        }
        function F(L, D, H, G, he) {
            if (typeof G == "string" && G !== "" || typeof G == "number" || typeof G == "bigint")
                return L = L.get(H) || null,
                M(D, L, "" + G, he);
            if (typeof G == "object" && G !== null) {
                switch (G.$$typeof) {
                case b:
                    return L = L.get(G.key === null ? H : G.key) || null,
                    N(D, L, G, he);
                case C:
                    return L = L.get(G.key === null ? H : G.key) || null,
                    I(D, L, G, he);
                case W:
                    return G = Xi(G),
                    F(L, D, H, G, he)
                }
                if (ae(G) || pe(G))
                    return L = L.get(H) || null,
                    K(D, L, G, he, null);
                if (typeof G.then == "function")
                    return F(L, D, H, nc(G), he);
                if (G.$$typeof === O)
                    return F(L, D, H, Ja(D, G), he);
                rc(D, G)
            }
            return null
        }
        function oe(L, D, H, G) {
            for (var he = null, Re = null, ue = D, we = D = 0, Ae = null; ue !== null && we < H.length; we++) {
                ue.index > we ? (Ae = ue,
                ue = null) : Ae = ue.sibling;
                var Oe = V(L, ue, H[we], G);
                if (Oe === null) {
                    ue === null && (ue = Ae);
                    break
                }
                i && ue && Oe.alternate === null && s(L, ue),
                D = v(Oe, D, we),
                Re === null ? he = Oe : Re.sibling = Oe,
                Re = Oe,
                ue = Ae
            }
            if (we === H.length)
                return c(L, ue),
                Ne && sr(L, we),
                he;
            if (ue === null) {
                for (; we < H.length; we++)
                    ue = Y(L, H[we], G),
                    ue !== null && (D = v(ue, D, we),
                    Re === null ? he = ue : Re.sibling = ue,
                    Re = ue);
                return Ne && sr(L, we),
                he
            }
            for (ue = d(ue); we < H.length; we++)
                Ae = F(ue, L, we, H[we], G),
                Ae !== null && (i && Ae.alternate !== null && ue.delete(Ae.key === null ? we : Ae.key),
                D = v(Ae, D, we),
                Re === null ? he = Ae : Re.sibling = Ae,
                Re = Ae);
            return i && ue.forEach(function(si) {
                return s(L, si)
            }),
            Ne && sr(L, we),
            he
        }
        function me(L, D, H, G) {
            if (H == null)
                throw Error(r(151));
            for (var he = null, Re = null, ue = D, we = D = 0, Ae = null, Oe = H.next(); ue !== null && !Oe.done; we++,
            Oe = H.next()) {
                ue.index > we ? (Ae = ue,
                ue = null) : Ae = ue.sibling;
                var si = V(L, ue, Oe.value, G);
                if (si === null) {
                    ue === null && (ue = Ae);
                    break
                }
                i && ue && si.alternate === null && s(L, ue),
                D = v(si, D, we),
                Re === null ? he = si : Re.sibling = si,
                Re = si,
                ue = Ae
            }
            if (Oe.done)
                return c(L, ue),
                Ne && sr(L, we),
                he;
            if (ue === null) {
                for (; !Oe.done; we++,
                Oe = H.next())
                    Oe = Y(L, Oe.value, G),
                    Oe !== null && (D = v(Oe, D, we),
                    Re === null ? he = Oe : Re.sibling = Oe,
                    Re = Oe);
                return Ne && sr(L, we),
                he
            }
            for (ue = d(ue); !Oe.done; we++,
            Oe = H.next())
                Oe = F(ue, L, we, Oe.value, G),
                Oe !== null && (i && Oe.alternate !== null && ue.delete(Oe.key === null ? we : Oe.key),
                D = v(Oe, D, we),
                Re === null ? he = Oe : Re.sibling = Oe,
                Re = Oe);
            return i && ue.forEach(function(G9) {
                return s(L, G9)
            }),
            Ne && sr(L, we),
            he
        }
        function He(L, D, H, G) {
            if (typeof H == "object" && H !== null && H.type === S && H.key === null && (H = H.props.children),
            typeof H == "object" && H !== null) {
                switch (H.$$typeof) {
                case b:
                    e: {
                        for (var he = H.key; D !== null; ) {
                            if (D.key === he) {
                                if (he = H.type,
                                he === S) {
                                    if (D.tag === 7) {
                                        c(L, D.sibling),
                                        G = g(D, H.props.children),
                                        G.return = L,
                                        L = G;
                                        break e
                                    }
                                } else if (D.elementType === he || typeof he == "object" && he !== null && he.$$typeof === W && Xi(he) === D.type) {
                                    c(L, D.sibling),
                                    G = g(D, H.props),
                                    us(G, H),
                                    G.return = L,
                                    L = G;
                                    break e
                                }
                                c(L, D);
                                break
                            } else
                                s(L, D);
                            D = D.sibling
                        }
                        H.type === S ? (G = Ki(H.props.children, L.mode, G, H.key),
                        G.return = L,
                        L = G) : (G = Za(H.type, H.key, H.props, null, L.mode, G),
                        us(G, H),
                        G.return = L,
                        L = G)
                    }
                    return x(L);
                case C:
                    e: {
                        for (he = H.key; D !== null; ) {
                            if (D.key === he)
                                if (D.tag === 4 && D.stateNode.containerInfo === H.containerInfo && D.stateNode.implementation === H.implementation) {
                                    c(L, D.sibling),
                                    G = g(D, H.children || []),
                                    G.return = L,
                                    L = G;
                                    break e
                                } else {
                                    c(L, D);
                                    break
                                }
                            else
                                s(L, D);
                            D = D.sibling
                        }
                        G = zd(H, L.mode, G),
                        G.return = L,
                        L = G
                    }
                    return x(L);
                case W:
                    return H = Xi(H),
                    He(L, D, H, G)
                }
                if (ae(H))
                    return oe(L, D, H, G);
                if (pe(H)) {
                    if (he = pe(H),
                    typeof he != "function")
                        throw Error(r(150));
                    return H = he.call(H),
                    me(L, D, H, G)
                }
                if (typeof H.then == "function")
                    return He(L, D, nc(H), G);
                if (H.$$typeof === O)
                    return He(L, D, Ja(L, H), G);
                rc(L, H)
            }
            return typeof H == "string" && H !== "" || typeof H == "number" || typeof H == "bigint" ? (H = "" + H,
            D !== null && D.tag === 6 ? (c(L, D.sibling),
            G = g(D, H),
            G.return = L,
            L = G) : (c(L, D),
            G = Ld(H, L.mode, G),
            G.return = L,
            L = G),
            x(L)) : c(L, D)
        }
        return function(L, D, H, G) {
            try {
                cs = 0;
                var he = He(L, D, H, G);
                return Qo = null,
                he
            } catch (ue) {
                if (ue === Jo || ue === ec)
                    throw ue;
                var Re = nn(29, ue, null, L.mode);
                return Re.lanes = G,
                Re.return = L,
                Re
            }
        }
    }
    var Qi = V0(!0)
      , U0 = V0(!1)
      , $r = !1;
    function Kd(i) {
        i.updateQueue = {
            baseState: i.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function Gd(i, s) {
        i = i.updateQueue,
        s.updateQueue === i && (s.updateQueue = {
            baseState: i.baseState,
            firstBaseUpdate: i.firstBaseUpdate,
            lastBaseUpdate: i.lastBaseUpdate,
            shared: i.shared,
            callbacks: null
        })
    }
    function Fr(i) {
        return {
            lane: i,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Kr(i, s, c) {
        var d = i.updateQueue;
        if (d === null)
            return null;
        if (d = d.shared,
        (De & 2) !== 0) {
            var g = d.pending;
            return g === null ? s.next = s : (s.next = g.next,
            g.next = s),
            d.pending = s,
            s = Ya(i),
            E0(i, null, c),
            s
        }
        return Ga(i, d, s, c),
        Ya(i)
    }
    function fs(i, s, c) {
        if (s = s.updateQueue,
        s !== null && (s = s.shared,
        (c & 4194048) !== 0)) {
            var d = s.lanes;
            d &= i.pendingLanes,
            c |= d,
            s.lanes = c,
            Dg(i, c)
        }
    }
    function Yd(i, s) {
        var c = i.updateQueue
          , d = i.alternate;
        if (d !== null && (d = d.updateQueue,
        c === d)) {
            var g = null
              , v = null;
            if (c = c.firstBaseUpdate,
            c !== null) {
                do {
                    var x = {
                        lane: c.lane,
                        tag: c.tag,
                        payload: c.payload,
                        callback: null,
                        next: null
                    };
                    v === null ? g = v = x : v = v.next = x,
                    c = c.next
                } while (c !== null);
                v === null ? g = v = s : v = v.next = s
            } else
                g = v = s;
            c = {
                baseState: d.baseState,
                firstBaseUpdate: g,
                lastBaseUpdate: v,
                shared: d.shared,
                callbacks: d.callbacks
            },
            i.updateQueue = c;
            return
        }
        i = c.lastBaseUpdate,
        i === null ? c.firstBaseUpdate = s : i.next = s,
        c.lastBaseUpdate = s
    }
    var Zd = !1;
    function ds() {
        if (Zd) {
            var i = Xo;
            if (i !== null)
                throw i
        }
    }
    function hs(i, s, c, d) {
        Zd = !1;
        var g = i.updateQueue;
        $r = !1;
        var v = g.firstBaseUpdate
          , x = g.lastBaseUpdate
          , M = g.shared.pending;
        if (M !== null) {
            g.shared.pending = null;
            var N = M
              , I = N.next;
            N.next = null,
            x === null ? v = I : x.next = I,
            x = N;
            var K = i.alternate;
            K !== null && (K = K.updateQueue,
            M = K.lastBaseUpdate,
            M !== x && (M === null ? K.firstBaseUpdate = I : M.next = I,
            K.lastBaseUpdate = N))
        }
        if (v !== null) {
            var Y = g.baseState;
            x = 0,
            K = I = N = null,
            M = v;
            do {
                var V = M.lane & -536870913
                  , F = V !== M.lane;
                if (F ? (Me & V) === V : (d & V) === V) {
                    V !== 0 && V === Wo && (Zd = !0),
                    K !== null && (K = K.next = {
                        lane: 0,
                        tag: M.tag,
                        payload: M.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var oe = i
                          , me = M;
                        V = s;
                        var He = c;
                        switch (me.tag) {
                        case 1:
                            if (oe = me.payload,
                            typeof oe == "function") {
                                Y = oe.call(He, Y, V);
                                break e
                            }
                            Y = oe;
                            break e;
                        case 3:
                            oe.flags = oe.flags & -65537 | 128;
                        case 0:
                            if (oe = me.payload,
                            V = typeof oe == "function" ? oe.call(He, Y, V) : oe,
                            V == null)
                                break e;
                            Y = m({}, Y, V);
                            break e;
                        case 2:
                            $r = !0
                        }
                    }
                    V = M.callback,
                    V !== null && (i.flags |= 64,
                    F && (i.flags |= 8192),
                    F = g.callbacks,
                    F === null ? g.callbacks = [V] : F.push(V))
                } else
                    F = {
                        lane: V,
                        tag: M.tag,
                        payload: M.payload,
                        callback: M.callback,
                        next: null
                    },
                    K === null ? (I = K = F,
                    N = Y) : K = K.next = F,
                    x |= V;
                if (M = M.next,
                M === null) {
                    if (M = g.shared.pending,
                    M === null)
                        break;
                    F = M,
                    M = F.next,
                    F.next = null,
                    g.lastBaseUpdate = F,
                    g.shared.pending = null
                }
            } while (!0);
            K === null && (N = Y),
            g.baseState = N,
            g.firstBaseUpdate = I,
            g.lastBaseUpdate = K,
            v === null && (g.shared.lanes = 0),
            Xr |= x,
            i.lanes = x,
            i.memoizedState = Y
        }
    }
    function P0(i, s) {
        if (typeof i != "function")
            throw Error(r(191, i));
        i.call(s)
    }
    function q0(i, s) {
        var c = i.callbacks;
        if (c !== null)
            for (i.callbacks = null,
            i = 0; i < c.length; i++)
                P0(c[i], s)
    }
    var el = R(null)
      , ic = R(0);
    function $0(i, s) {
        i = vr,
        X(ic, i),
        X(el, s),
        vr = i | s.baseLanes
    }
    function Wd() {
        X(ic, vr),
        X(el, el.current)
    }
    function Xd() {
        vr = ic.current,
        U(el),
        U(ic)
    }
    var rn = R(null)
      , Cn = null;
    function Gr(i) {
        var s = i.alternate;
        X(it, it.current & 1),
        X(rn, i),
        Cn === null && (s === null || el.current !== null || s.memoizedState !== null) && (Cn = i)
    }
    function Jd(i) {
        X(it, it.current),
        X(rn, i),
        Cn === null && (Cn = i)
    }
    function F0(i) {
        i.tag === 22 ? (X(it, it.current),
        X(rn, i),
        Cn === null && (Cn = i)) : Yr()
    }
    function Yr() {
        X(it, it.current),
        X(rn, rn.current)
    }
    function on(i) {
        U(rn),
        Cn === i && (Cn = null),
        U(it)
    }
    var it = R(0);
    function oc(i) {
        for (var s = i; s !== null; ) {
            if (s.tag === 13) {
                var c = s.memoizedState;
                if (c !== null && (c = c.dehydrated,
                c === null || ip(c) || op(c)))
                    return s
            } else if (s.tag === 19 && (s.memoizedProps.revealOrder === "forwards" || s.memoizedProps.revealOrder === "backwards" || s.memoizedProps.revealOrder === "unstable_legacy-backwards" || s.memoizedProps.revealOrder === "together")) {
                if ((s.flags & 128) !== 0)
                    return s
            } else if (s.child !== null) {
                s.child.return = s,
                s = s.child;
                continue
            }
            if (s === i)
                break;
            for (; s.sibling === null; ) {
                if (s.return === null || s.return === i)
                    return null;
                s = s.return
            }
            s.sibling.return = s.return,
            s = s.sibling
        }
        return null
    }
    var ur = 0
      , xe = null
      , Be = null
      , at = null
      , lc = !1
      , tl = !1
      , eo = !1
      , sc = 0
      , ps = 0
      , nl = null
      , jw = 0;
    function Xe() {
        throw Error(r(321))
    }
    function Qd(i, s) {
        if (s === null)
            return !1;
        for (var c = 0; c < s.length && c < i.length; c++)
            if (!tn(i[c], s[c]))
                return !1;
        return !0
    }
    function eh(i, s, c, d, g, v) {
        return ur = v,
        xe = s,
        s.memoizedState = null,
        s.updateQueue = null,
        s.lanes = 0,
        j.H = i === null || i.memoizedState === null ? Ay : mh,
        eo = !1,
        v = c(d, g),
        eo = !1,
        tl && (v = G0(s, c, d, g)),
        K0(i),
        v
    }
    function K0(i) {
        j.H = ys;
        var s = Be !== null && Be.next !== null;
        if (ur = 0,
        at = Be = xe = null,
        lc = !1,
        ps = 0,
        nl = null,
        s)
            throw Error(r(300));
        i === null || ct || (i = i.dependencies,
        i !== null && Xa(i) && (ct = !0))
    }
    function G0(i, s, c, d) {
        xe = i;
        var g = 0;
        do {
            if (tl && (nl = null),
            ps = 0,
            tl = !1,
            25 <= g)
                throw Error(r(301));
            if (g += 1,
            at = Be = null,
            i.updateQueue != null) {
                var v = i.updateQueue;
                v.lastEffect = null,
                v.events = null,
                v.stores = null,
                v.memoCache != null && (v.memoCache.index = 0)
            }
            j.H = Ny,
            v = s(c, d)
        } while (tl);
        return v
    }
    function Hw() {
        var i = j.H
          , s = i.useState()[0];
        return s = typeof s.then == "function" ? ms(s) : s,
        i = i.useState()[0],
        (Be !== null ? Be.memoizedState : null) !== i && (xe.flags |= 1024),
        s
    }
    function th() {
        var i = sc !== 0;
        return sc = 0,
        i
    }
    function nh(i, s, c) {
        s.updateQueue = i.updateQueue,
        s.flags &= -2053,
        i.lanes &= ~c
    }
    function rh(i) {
        if (lc) {
            for (i = i.memoizedState; i !== null; ) {
                var s = i.queue;
                s !== null && (s.pending = null),
                i = i.next
            }
            lc = !1
        }
        ur = 0,
        at = Be = xe = null,
        tl = !1,
        ps = sc = 0,
        nl = null
    }
    function _t() {
        var i = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return at === null ? xe.memoizedState = at = i : at = at.next = i,
        at
    }
    function ot() {
        if (Be === null) {
            var i = xe.alternate;
            i = i !== null ? i.memoizedState : null
        } else
            i = Be.next;
        var s = at === null ? xe.memoizedState : at.next;
        if (s !== null)
            at = s,
            Be = i;
        else {
            if (i === null)
                throw xe.alternate === null ? Error(r(467)) : Error(r(310));
            Be = i,
            i = {
                memoizedState: Be.memoizedState,
                baseState: Be.baseState,
                baseQueue: Be.baseQueue,
                queue: Be.queue,
                next: null
            },
            at === null ? xe.memoizedState = at = i : at = at.next = i
        }
        return at
    }
    function ac() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function ms(i) {
        var s = ps;
        return ps += 1,
        nl === null && (nl = []),
        i = j0(nl, i, s),
        s = xe,
        (at === null ? s.memoizedState : at.next) === null && (s = s.alternate,
        j.H = s === null || s.memoizedState === null ? Ay : mh),
        i
    }
    function cc(i) {
        if (i !== null && typeof i == "object") {
            if (typeof i.then == "function")
                return ms(i);
            if (i.$$typeof === O)
                return xt(i)
        }
        throw Error(r(438, String(i)))
    }
    function ih(i) {
        var s = null
          , c = xe.updateQueue;
        if (c !== null && (s = c.memoCache),
        s == null) {
            var d = xe.alternate;
            d !== null && (d = d.updateQueue,
            d !== null && (d = d.memoCache,
            d != null && (s = {
                data: d.data.map(function(g) {
                    return g.slice()
                }),
                index: 0
            })))
        }
        if (s == null && (s = {
            data: [],
            index: 0
        }),
        c === null && (c = ac(),
        xe.updateQueue = c),
        c.memoCache = s,
        c = s.data[s.index],
        c === void 0)
            for (c = s.data[s.index] = Array(i),
            d = 0; d < i; d++)
                c[d] = de;
        return s.index++,
        c
    }
    function fr(i, s) {
        return typeof s == "function" ? s(i) : s
    }
    function uc(i) {
        var s = ot();
        return oh(s, Be, i)
    }
    function oh(i, s, c) {
        var d = i.queue;
        if (d === null)
            throw Error(r(311));
        d.lastRenderedReducer = c;
        var g = i.baseQueue
          , v = d.pending;
        if (v !== null) {
            if (g !== null) {
                var x = g.next;
                g.next = v.next,
                v.next = x
            }
            s.baseQueue = g = v,
            d.pending = null
        }
        if (v = i.baseState,
        g === null)
            i.memoizedState = v;
        else {
            s = g.next;
            var M = x = null
              , N = null
              , I = s
              , K = !1;
            do {
                var Y = I.lane & -536870913;
                if (Y !== I.lane ? (Me & Y) === Y : (ur & Y) === Y) {
                    var V = I.revertLane;
                    if (V === 0)
                        N !== null && (N = N.next = {
                            lane: 0,
                            revertLane: 0,
                            gesture: null,
                            action: I.action,
                            hasEagerState: I.hasEagerState,
                            eagerState: I.eagerState,
                            next: null
                        }),
                        Y === Wo && (K = !0);
                    else if ((ur & V) === V) {
                        I = I.next,
                        V === Wo && (K = !0);
                        continue
                    } else
                        Y = {
                            lane: 0,
                            revertLane: I.revertLane,
                            gesture: null,
                            action: I.action,
                            hasEagerState: I.hasEagerState,
                            eagerState: I.eagerState,
                            next: null
                        },
                        N === null ? (M = N = Y,
                        x = v) : N = N.next = Y,
                        xe.lanes |= V,
                        Xr |= V;
                    Y = I.action,
                    eo && c(v, Y),
                    v = I.hasEagerState ? I.eagerState : c(v, Y)
                } else
                    V = {
                        lane: Y,
                        revertLane: I.revertLane,
                        gesture: I.gesture,
                        action: I.action,
                        hasEagerState: I.hasEagerState,
                        eagerState: I.eagerState,
                        next: null
                    },
                    N === null ? (M = N = V,
                    x = v) : N = N.next = V,
                    xe.lanes |= Y,
                    Xr |= Y;
                I = I.next
            } while (I !== null && I !== s);
            if (N === null ? x = v : N.next = M,
            !tn(v, i.memoizedState) && (ct = !0,
            K && (c = Xo,
            c !== null)))
                throw c;
            i.memoizedState = v,
            i.baseState = x,
            i.baseQueue = N,
            d.lastRenderedState = v
        }
        return g === null && (d.lanes = 0),
        [i.memoizedState, d.dispatch]
    }
    function lh(i) {
        var s = ot()
          , c = s.queue;
        if (c === null)
            throw Error(r(311));
        c.lastRenderedReducer = i;
        var d = c.dispatch
          , g = c.pending
          , v = s.memoizedState;
        if (g !== null) {
            c.pending = null;
            var x = g = g.next;
            do
                v = i(v, x.action),
                x = x.next;
            while (x !== g);
            tn(v, s.memoizedState) || (ct = !0),
            s.memoizedState = v,
            s.baseQueue === null && (s.baseState = v),
            c.lastRenderedState = v
        }
        return [v, d]
    }
    function Y0(i, s, c) {
        var d = xe
          , g = ot()
          , v = Ne;
        if (v) {
            if (c === void 0)
                throw Error(r(407));
            c = c()
        } else
            c = s();
        var x = !tn((Be || g).memoizedState, c);
        if (x && (g.memoizedState = c,
        ct = !0),
        g = g.queue,
        ch(X0.bind(null, d, g, i), [i]),
        g.getSnapshot !== s || x || at !== null && at.memoizedState.tag & 1) {
            if (d.flags |= 2048,
            rl(9, {
                destroy: void 0
            }, W0.bind(null, d, g, c, s), null),
            Ie === null)
                throw Error(r(349));
            v || (ur & 127) !== 0 || Z0(d, s, c)
        }
        return c
    }
    function Z0(i, s, c) {
        i.flags |= 16384,
        i = {
            getSnapshot: s,
            value: c
        },
        s = xe.updateQueue,
        s === null ? (s = ac(),
        xe.updateQueue = s,
        s.stores = [i]) : (c = s.stores,
        c === null ? s.stores = [i] : c.push(i))
    }
    function W0(i, s, c, d) {
        s.value = c,
        s.getSnapshot = d,
        J0(s) && Q0(i)
    }
    function X0(i, s, c) {
        return c(function() {
            J0(s) && Q0(i)
        })
    }
    function J0(i) {
        var s = i.getSnapshot;
        i = i.value;
        try {
            var c = s();
            return !tn(i, c)
        } catch {
            return !0
        }
    }
    function Q0(i) {
        var s = Fi(i, 2);
        s !== null && Gt(s, i, 2)
    }
    function sh(i) {
        var s = _t();
        if (typeof i == "function") {
            var c = i;
            if (i = c(),
            eo) {
                jr(!0);
                try {
                    c()
                } finally {
                    jr(!1)
                }
            }
        }
        return s.memoizedState = s.baseState = i,
        s.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: fr,
            lastRenderedState: i
        },
        s
    }
    function ey(i, s, c, d) {
        return i.baseState = c,
        oh(i, Be, typeof d == "function" ? d : fr)
    }
    function Iw(i, s, c, d, g) {
        if (hc(i))
            throw Error(r(485));
        if (i = s.action,
        i !== null) {
            var v = {
                payload: g,
                action: i,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(x) {
                    v.listeners.push(x)
                }
            };
            j.T !== null ? c(!0) : v.isTransition = !1,
            d(v),
            c = s.pending,
            c === null ? (v.next = s.pending = v,
            ty(s, v)) : (v.next = c.next,
            s.pending = c.next = v)
        }
    }
    function ty(i, s) {
        var c = s.action
          , d = s.payload
          , g = i.state;
        if (s.isTransition) {
            var v = j.T
              , x = {};
            j.T = x;
            try {
                var M = c(g, d)
                  , N = j.S;
                N !== null && N(x, M),
                ny(i, s, M)
            } catch (I) {
                ah(i, s, I)
            } finally {
                v !== null && x.types !== null && (v.types = x.types),
                j.T = v
            }
        } else
            try {
                v = c(g, d),
                ny(i, s, v)
            } catch (I) {
                ah(i, s, I)
            }
    }
    function ny(i, s, c) {
        c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(function(d) {
            ry(i, s, d)
        }, function(d) {
            return ah(i, s, d)
        }) : ry(i, s, c)
    }
    function ry(i, s, c) {
        s.status = "fulfilled",
        s.value = c,
        iy(s),
        i.state = c,
        s = i.pending,
        s !== null && (c = s.next,
        c === s ? i.pending = null : (c = c.next,
        s.next = c,
        ty(i, c)))
    }
    function ah(i, s, c) {
        var d = i.pending;
        if (i.pending = null,
        d !== null) {
            d = d.next;
            do
                s.status = "rejected",
                s.reason = c,
                iy(s),
                s = s.next;
            while (s !== d)
        }
        i.action = null
    }
    function iy(i) {
        i = i.listeners;
        for (var s = 0; s < i.length; s++)
            (0,
            i[s])()
    }
    function oy(i, s) {
        return s
    }
    function ly(i, s) {
        if (Ne) {
            var c = Ie.formState;
            if (c !== null) {
                e: {
                    var d = xe;
                    if (Ne) {
                        if ($e) {
                            t: {
                                for (var g = $e, v = bn; g.nodeType !== 8; ) {
                                    if (!v) {
                                        g = null;
                                        break t
                                    }
                                    if (g = Sn(g.nextSibling),
                                    g === null) {
                                        g = null;
                                        break t
                                    }
                                }
                                v = g.data,
                                g = v === "F!" || v === "F" ? g : null
                            }
                            if (g) {
                                $e = Sn(g.nextSibling),
                                d = g.data === "F!";
                                break e
                            }
                        }
                        Pr(d)
                    }
                    d = !1
                }
                d && (s = c[0])
            }
        }
        return c = _t(),
        c.memoizedState = c.baseState = s,
        d = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: oy,
            lastRenderedState: s
        },
        c.queue = d,
        c = Ty.bind(null, xe, d),
        d.dispatch = c,
        d = sh(!1),
        v = ph.bind(null, xe, !1, d.queue),
        d = _t(),
        g = {
            state: s,
            dispatch: null,
            action: i,
            pending: null
        },
        d.queue = g,
        c = Iw.bind(null, xe, g, v, c),
        g.dispatch = c,
        d.memoizedState = i,
        [s, c, !1]
    }
    function sy(i) {
        var s = ot();
        return ay(s, Be, i)
    }
    function ay(i, s, c) {
        if (s = oh(i, s, oy)[0],
        i = uc(fr)[0],
        typeof s == "object" && s !== null && typeof s.then == "function")
            try {
                var d = ms(s)
            } catch (x) {
                throw x === Jo ? ec : x
            }
        else
            d = s;
        s = ot();
        var g = s.queue
          , v = g.dispatch;
        return c !== s.memoizedState && (xe.flags |= 2048,
        rl(9, {
            destroy: void 0
        }, Vw.bind(null, g, c), null)),
        [d, v, i]
    }
    function Vw(i, s) {
        i.action = s
    }
    function cy(i) {
        var s = ot()
          , c = Be;
        if (c !== null)
            return ay(s, c, i);
        ot(),
        s = s.memoizedState,
        c = ot();
        var d = c.queue.dispatch;
        return c.memoizedState = i,
        [s, d, !1]
    }
    function rl(i, s, c, d) {
        return i = {
            tag: i,
            create: c,
            deps: d,
            inst: s,
            next: null
        },
        s = xe.updateQueue,
        s === null && (s = ac(),
        xe.updateQueue = s),
        c = s.lastEffect,
        c === null ? s.lastEffect = i.next = i : (d = c.next,
        c.next = i,
        i.next = d,
        s.lastEffect = i),
        i
    }
    function uy() {
        return ot().memoizedState
    }
    function fc(i, s, c, d) {
        var g = _t();
        xe.flags |= i,
        g.memoizedState = rl(1 | s, {
            destroy: void 0
        }, c, d === void 0 ? null : d)
    }
    function dc(i, s, c, d) {
        var g = ot();
        d = d === void 0 ? null : d;
        var v = g.memoizedState.inst;
        Be !== null && d !== null && Qd(d, Be.memoizedState.deps) ? g.memoizedState = rl(s, v, c, d) : (xe.flags |= i,
        g.memoizedState = rl(1 | s, v, c, d))
    }
    function fy(i, s) {
        fc(8390656, 8, i, s)
    }
    function ch(i, s) {
        dc(2048, 8, i, s)
    }
    function Uw(i) {
        xe.flags |= 4;
        var s = xe.updateQueue;
        if (s === null)
            s = ac(),
            xe.updateQueue = s,
            s.events = [i];
        else {
            var c = s.events;
            c === null ? s.events = [i] : c.push(i)
        }
    }
    function dy(i) {
        var s = ot().memoizedState;
        return Uw({
            ref: s,
            nextImpl: i
        }),
        function() {
            if ((De & 2) !== 0)
                throw Error(r(440));
            return s.impl.apply(void 0, arguments)
        }
    }
    function hy(i, s) {
        return dc(4, 2, i, s)
    }
    function py(i, s) {
        return dc(4, 4, i, s)
    }
    function my(i, s) {
        if (typeof s == "function") {
            i = i();
            var c = s(i);
            return function() {
                typeof c == "function" ? c() : s(null)
            }
        }
        if (s != null)
            return i = i(),
            s.current = i,
            function() {
                s.current = null
            }
    }
    function gy(i, s, c) {
        c = c != null ? c.concat([i]) : null,
        dc(4, 4, my.bind(null, s, i), c)
    }
    function uh() {}
    function yy(i, s) {
        var c = ot();
        s = s === void 0 ? null : s;
        var d = c.memoizedState;
        return s !== null && Qd(s, d[1]) ? d[0] : (c.memoizedState = [i, s],
        i)
    }
    function vy(i, s) {
        var c = ot();
        s = s === void 0 ? null : s;
        var d = c.memoizedState;
        if (s !== null && Qd(s, d[1]))
            return d[0];
        if (d = i(),
        eo) {
            jr(!0);
            try {
                i()
            } finally {
                jr(!1)
            }
        }
        return c.memoizedState = [d, s],
        d
    }
    function fh(i, s, c) {
        return c === void 0 || (ur & 1073741824) !== 0 && (Me & 261930) === 0 ? i.memoizedState = s : (i.memoizedState = c,
        i = b2(),
        xe.lanes |= i,
        Xr |= i,
        c)
    }
    function by(i, s, c, d) {
        return tn(c, s) ? c : el.current !== null ? (i = fh(i, c, d),
        tn(i, s) || (ct = !0),
        i) : (ur & 42) === 0 || (ur & 1073741824) !== 0 && (Me & 261930) === 0 ? (ct = !0,
        i.memoizedState = c) : (i = b2(),
        xe.lanes |= i,
        Xr |= i,
        s)
    }
    function Cy(i, s, c, d, g) {
        var v = P.p;
        P.p = v !== 0 && 8 > v ? v : 8;
        var x = j.T
          , M = {};
        j.T = M,
        ph(i, !1, s, c);
        try {
            var N = g()
              , I = j.S;
            if (I !== null && I(M, N),
            N !== null && typeof N == "object" && typeof N.then == "function") {
                var K = Bw(N, d);
                gs(i, s, K, an(i))
            } else
                gs(i, s, d, an(i))
        } catch (Y) {
            gs(i, s, {
                then: function() {},
                status: "rejected",
                reason: Y
            }, an())
        } finally {
            P.p = v,
            x !== null && M.types !== null && (x.types = M.types),
            j.T = x
        }
    }
    function Pw() {}
    function dh(i, s, c, d) {
        if (i.tag !== 5)
            throw Error(r(476));
        var g = Sy(i).queue;
        Cy(i, g, s, q, c === null ? Pw : function() {
            return xy(i),
            c(d)
        }
        )
    }
    function Sy(i) {
        var s = i.memoizedState;
        if (s !== null)
            return s;
        s = {
            memoizedState: q,
            baseState: q,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: fr,
                lastRenderedState: q
            },
            next: null
        };
        var c = {};
        return s.next = {
            memoizedState: c,
            baseState: c,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: fr,
                lastRenderedState: c
            },
            next: null
        },
        i.memoizedState = s,
        i = i.alternate,
        i !== null && (i.memoizedState = s),
        s
    }
    function xy(i) {
        var s = Sy(i);
        s.next === null && (s = i.alternate.memoizedState),
        gs(i, s.next.queue, {}, an())
    }
    function hh() {
        return xt(Ls)
    }
    function wy() {
        return ot().memoizedState
    }
    function Ey() {
        return ot().memoizedState
    }
    function qw(i) {
        for (var s = i.return; s !== null; ) {
            switch (s.tag) {
            case 24:
            case 3:
                var c = an();
                i = Fr(c);
                var d = Kr(s, i, c);
                d !== null && (Gt(d, s, c),
                fs(d, s, c)),
                s = {
                    cache: Pd()
                },
                i.payload = s;
                return
            }
            s = s.return
        }
    }
    function $w(i, s, c) {
        var d = an();
        c = {
            lane: d,
            revertLane: 0,
            gesture: null,
            action: c,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        hc(i) ? ky(s, c) : (c = Od(i, s, c, d),
        c !== null && (Gt(c, i, d),
        My(c, s, d)))
    }
    function Ty(i, s, c) {
        var d = an();
        gs(i, s, c, d)
    }
    function gs(i, s, c, d) {
        var g = {
            lane: d,
            revertLane: 0,
            gesture: null,
            action: c,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (hc(i))
            ky(s, g);
        else {
            var v = i.alternate;
            if (i.lanes === 0 && (v === null || v.lanes === 0) && (v = s.lastRenderedReducer,
            v !== null))
                try {
                    var x = s.lastRenderedState
                      , M = v(x, c);
                    if (g.hasEagerState = !0,
                    g.eagerState = M,
                    tn(M, x))
                        return Ga(i, s, g, 0),
                        Ie === null && Ka(),
                        !1
                } catch {}
            if (c = Od(i, s, g, d),
            c !== null)
                return Gt(c, i, d),
                My(c, s, d),
                !0
        }
        return !1
    }
    function ph(i, s, c, d) {
        if (d = {
            lane: 2,
            revertLane: Kh(),
            gesture: null,
            action: d,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        hc(i)) {
            if (s)
                throw Error(r(479))
        } else
            s = Od(i, c, d, 2),
            s !== null && Gt(s, i, 2)
    }
    function hc(i) {
        var s = i.alternate;
        return i === xe || s !== null && s === xe
    }
    function ky(i, s) {
        tl = lc = !0;
        var c = i.pending;
        c === null ? s.next = s : (s.next = c.next,
        c.next = s),
        i.pending = s
    }
    function My(i, s, c) {
        if ((c & 4194048) !== 0) {
            var d = s.lanes;
            d &= i.pendingLanes,
            c |= d,
            s.lanes = c,
            Dg(i, c)
        }
    }
    var ys = {
        readContext: xt,
        use: cc,
        useCallback: Xe,
        useContext: Xe,
        useEffect: Xe,
        useImperativeHandle: Xe,
        useLayoutEffect: Xe,
        useInsertionEffect: Xe,
        useMemo: Xe,
        useReducer: Xe,
        useRef: Xe,
        useState: Xe,
        useDebugValue: Xe,
        useDeferredValue: Xe,
        useTransition: Xe,
        useSyncExternalStore: Xe,
        useId: Xe,
        useHostTransitionStatus: Xe,
        useFormState: Xe,
        useActionState: Xe,
        useOptimistic: Xe,
        useMemoCache: Xe,
        useCacheRefresh: Xe
    };
    ys.useEffectEvent = Xe;
    var Ay = {
        readContext: xt,
        use: cc,
        useCallback: function(i, s) {
            return _t().memoizedState = [i, s === void 0 ? null : s],
            i
        },
        useContext: xt,
        useEffect: fy,
        useImperativeHandle: function(i, s, c) {
            c = c != null ? c.concat([i]) : null,
            fc(4194308, 4, my.bind(null, s, i), c)
        },
        useLayoutEffect: function(i, s) {
            return fc(4194308, 4, i, s)
        },
        useInsertionEffect: function(i, s) {
            fc(4, 2, i, s)
        },
        useMemo: function(i, s) {
            var c = _t();
            s = s === void 0 ? null : s;
            var d = i();
            if (eo) {
                jr(!0);
                try {
                    i()
                } finally {
                    jr(!1)
                }
            }
            return c.memoizedState = [d, s],
            d
        },
        useReducer: function(i, s, c) {
            var d = _t();
            if (c !== void 0) {
                var g = c(s);
                if (eo) {
                    jr(!0);
                    try {
                        c(s)
                    } finally {
                        jr(!1)
                    }
                }
            } else
                g = s;
            return d.memoizedState = d.baseState = g,
            i = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: i,
                lastRenderedState: g
            },
            d.queue = i,
            i = i.dispatch = $w.bind(null, xe, i),
            [d.memoizedState, i]
        },
        useRef: function(i) {
            var s = _t();
            return i = {
                current: i
            },
            s.memoizedState = i
        },
        useState: function(i) {
            i = sh(i);
            var s = i.queue
              , c = Ty.bind(null, xe, s);
            return s.dispatch = c,
            [i.memoizedState, c]
        },
        useDebugValue: uh,
        useDeferredValue: function(i, s) {
            var c = _t();
            return fh(c, i, s)
        },
        useTransition: function() {
            var i = sh(!1);
            return i = Cy.bind(null, xe, i.queue, !0, !1),
            _t().memoizedState = i,
            [!1, i]
        },
        useSyncExternalStore: function(i, s, c) {
            var d = xe
              , g = _t();
            if (Ne) {
                if (c === void 0)
                    throw Error(r(407));
                c = c()
            } else {
                if (c = s(),
                Ie === null)
                    throw Error(r(349));
                (Me & 127) !== 0 || Z0(d, s, c)
            }
            g.memoizedState = c;
            var v = {
                value: c,
                getSnapshot: s
            };
            return g.queue = v,
            fy(X0.bind(null, d, v, i), [i]),
            d.flags |= 2048,
            rl(9, {
                destroy: void 0
            }, W0.bind(null, d, v, c, s), null),
            c
        },
        useId: function() {
            var i = _t()
              , s = Ie.identifierPrefix;
            if (Ne) {
                var c = In
                  , d = Hn;
                c = (d & ~(1 << 32 - en(d) - 1)).toString(32) + c,
                s = "_" + s + "R_" + c,
                c = sc++,
                0 < c && (s += "H" + c.toString(32)),
                s += "_"
            } else
                c = jw++,
                s = "_" + s + "r_" + c.toString(32) + "_";
            return i.memoizedState = s
        },
        useHostTransitionStatus: hh,
        useFormState: ly,
        useActionState: ly,
        useOptimistic: function(i) {
            var s = _t();
            s.memoizedState = s.baseState = i;
            var c = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return s.queue = c,
            s = ph.bind(null, xe, !0, c),
            c.dispatch = s,
            [i, s]
        },
        useMemoCache: ih,
        useCacheRefresh: function() {
            return _t().memoizedState = qw.bind(null, xe)
        },
        useEffectEvent: function(i) {
            var s = _t()
              , c = {
                impl: i
            };
            return s.memoizedState = c,
            function() {
                if ((De & 2) !== 0)
                    throw Error(r(440));
                return c.impl.apply(void 0, arguments)
            }
        }
    }
      , mh = {
        readContext: xt,
        use: cc,
        useCallback: yy,
        useContext: xt,
        useEffect: ch,
        useImperativeHandle: gy,
        useInsertionEffect: hy,
        useLayoutEffect: py,
        useMemo: vy,
        useReducer: uc,
        useRef: uy,
        useState: function() {
            return uc(fr)
        },
        useDebugValue: uh,
        useDeferredValue: function(i, s) {
            var c = ot();
            return by(c, Be.memoizedState, i, s)
        },
        useTransition: function() {
            var i = uc(fr)[0]
              , s = ot().memoizedState;
            return [typeof i == "boolean" ? i : ms(i), s]
        },
        useSyncExternalStore: Y0,
        useId: wy,
        useHostTransitionStatus: hh,
        useFormState: sy,
        useActionState: sy,
        useOptimistic: function(i, s) {
            var c = ot();
            return ey(c, Be, i, s)
        },
        useMemoCache: ih,
        useCacheRefresh: Ey
    };
    mh.useEffectEvent = dy;
    var Ny = {
        readContext: xt,
        use: cc,
        useCallback: yy,
        useContext: xt,
        useEffect: ch,
        useImperativeHandle: gy,
        useInsertionEffect: hy,
        useLayoutEffect: py,
        useMemo: vy,
        useReducer: lh,
        useRef: uy,
        useState: function() {
            return lh(fr)
        },
        useDebugValue: uh,
        useDeferredValue: function(i, s) {
            var c = ot();
            return Be === null ? fh(c, i, s) : by(c, Be.memoizedState, i, s)
        },
        useTransition: function() {
            var i = lh(fr)[0]
              , s = ot().memoizedState;
            return [typeof i == "boolean" ? i : ms(i), s]
        },
        useSyncExternalStore: Y0,
        useId: wy,
        useHostTransitionStatus: hh,
        useFormState: cy,
        useActionState: cy,
        useOptimistic: function(i, s) {
            var c = ot();
            return Be !== null ? ey(c, Be, i, s) : (c.baseState = i,
            [i, c.queue.dispatch])
        },
        useMemoCache: ih,
        useCacheRefresh: Ey
    };
    Ny.useEffectEvent = dy;
    function gh(i, s, c, d) {
        s = i.memoizedState,
        c = c(d, s),
        c = c == null ? s : m({}, s, c),
        i.memoizedState = c,
        i.lanes === 0 && (i.updateQueue.baseState = c)
    }
    var yh = {
        enqueueSetState: function(i, s, c) {
            i = i._reactInternals;
            var d = an()
              , g = Fr(d);
            g.payload = s,
            c != null && (g.callback = c),
            s = Kr(i, g, d),
            s !== null && (Gt(s, i, d),
            fs(s, i, d))
        },
        enqueueReplaceState: function(i, s, c) {
            i = i._reactInternals;
            var d = an()
              , g = Fr(d);
            g.tag = 1,
            g.payload = s,
            c != null && (g.callback = c),
            s = Kr(i, g, d),
            s !== null && (Gt(s, i, d),
            fs(s, i, d))
        },
        enqueueForceUpdate: function(i, s) {
            i = i._reactInternals;
            var c = an()
              , d = Fr(c);
            d.tag = 2,
            s != null && (d.callback = s),
            s = Kr(i, d, c),
            s !== null && (Gt(s, i, c),
            fs(s, i, c))
        }
    };
    function Ry(i, s, c, d, g, v, x) {
        return i = i.stateNode,
        typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(d, v, x) : s.prototype && s.prototype.isPureReactComponent ? !ns(c, d) || !ns(g, v) : !0
    }
    function Oy(i, s, c, d) {
        i = s.state,
        typeof s.componentWillReceiveProps == "function" && s.componentWillReceiveProps(c, d),
        typeof s.UNSAFE_componentWillReceiveProps == "function" && s.UNSAFE_componentWillReceiveProps(c, d),
        s.state !== i && yh.enqueueReplaceState(s, s.state, null)
    }
    function to(i, s) {
        var c = s;
        if ("ref"in s) {
            c = {};
            for (var d in s)
                d !== "ref" && (c[d] = s[d])
        }
        if (i = i.defaultProps) {
            c === s && (c = m({}, c));
            for (var g in i)
                c[g] === void 0 && (c[g] = i[g])
        }
        return c
    }
    function Dy(i) {
        Fa(i)
    }
    function Ly(i) {
        console.error(i)
    }
    function zy(i) {
        Fa(i)
    }
    function pc(i, s) {
        try {
            var c = i.onUncaughtError;
            c(s.value, {
                componentStack: s.stack
            })
        } catch (d) {
            setTimeout(function() {
                throw d
            })
        }
    }
    function _y(i, s, c) {
        try {
            var d = i.onCaughtError;
            d(c.value, {
                componentStack: c.stack,
                errorBoundary: s.tag === 1 ? s.stateNode : null
            })
        } catch (g) {
            setTimeout(function() {
                throw g
            })
        }
    }
    function vh(i, s, c) {
        return c = Fr(c),
        c.tag = 3,
        c.payload = {
            element: null
        },
        c.callback = function() {
            pc(i, s)
        }
        ,
        c
    }
    function By(i) {
        return i = Fr(i),
        i.tag = 3,
        i
    }
    function jy(i, s, c, d) {
        var g = c.type.getDerivedStateFromError;
        if (typeof g == "function") {
            var v = d.value;
            i.payload = function() {
                return g(v)
            }
            ,
            i.callback = function() {
                _y(s, c, d)
            }
        }
        var x = c.stateNode;
        x !== null && typeof x.componentDidCatch == "function" && (i.callback = function() {
            _y(s, c, d),
            typeof g != "function" && (Jr === null ? Jr = new Set([this]) : Jr.add(this));
            var M = d.stack;
            this.componentDidCatch(d.value, {
                componentStack: M !== null ? M : ""
            })
        }
        )
    }
    function Fw(i, s, c, d, g) {
        if (c.flags |= 32768,
        d !== null && typeof d == "object" && typeof d.then == "function") {
            if (s = c.alternate,
            s !== null && Zo(s, c, g, !0),
            c = rn.current,
            c !== null) {
                switch (c.tag) {
                case 31:
                case 13:
                    return Cn === null ? kc() : c.alternate === null && Je === 0 && (Je = 3),
                    c.flags &= -257,
                    c.flags |= 65536,
                    c.lanes = g,
                    d === tc ? c.flags |= 16384 : (s = c.updateQueue,
                    s === null ? c.updateQueue = new Set([d]) : s.add(d),
                    qh(i, d, g)),
                    !1;
                case 22:
                    return c.flags |= 65536,
                    d === tc ? c.flags |= 16384 : (s = c.updateQueue,
                    s === null ? (s = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([d])
                    },
                    c.updateQueue = s) : (c = s.retryQueue,
                    c === null ? s.retryQueue = new Set([d]) : c.add(d)),
                    qh(i, d, g)),
                    !1
                }
                throw Error(r(435, c.tag))
            }
            return qh(i, d, g),
            kc(),
            !1
        }
        if (Ne)
            return s = rn.current,
            s !== null ? ((s.flags & 65536) === 0 && (s.flags |= 256),
            s.flags |= 65536,
            s.lanes = g,
            d !== jd && (i = Error(r(422), {
                cause: d
            }),
            ls(gn(i, c)))) : (d !== jd && (s = Error(r(423), {
                cause: d
            }),
            ls(gn(s, c))),
            i = i.current.alternate,
            i.flags |= 65536,
            g &= -g,
            i.lanes |= g,
            d = gn(d, c),
            g = vh(i.stateNode, d, g),
            Yd(i, g),
            Je !== 4 && (Je = 2)),
            !1;
        var v = Error(r(520), {
            cause: d
        });
        if (v = gn(v, c),
        Ts === null ? Ts = [v] : Ts.push(v),
        Je !== 4 && (Je = 2),
        s === null)
            return !0;
        d = gn(d, c),
        c = s;
        do {
            switch (c.tag) {
            case 3:
                return c.flags |= 65536,
                i = g & -g,
                c.lanes |= i,
                i = vh(c.stateNode, d, i),
                Yd(c, i),
                !1;
            case 1:
                if (s = c.type,
                v = c.stateNode,
                (c.flags & 128) === 0 && (typeof s.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (Jr === null || !Jr.has(v))))
                    return c.flags |= 65536,
                    g &= -g,
                    c.lanes |= g,
                    g = By(g),
                    jy(g, i, c, d),
                    Yd(c, g),
                    !1
            }
            c = c.return
        } while (c !== null);
        return !1
    }
    var bh = Error(r(461))
      , ct = !1;
    function wt(i, s, c, d) {
        s.child = i === null ? U0(s, null, c, d) : Qi(s, i.child, c, d)
    }
    function Hy(i, s, c, d, g) {
        c = c.render;
        var v = s.ref;
        if ("ref"in d) {
            var x = {};
            for (var M in d)
                M !== "ref" && (x[M] = d[M])
        } else
            x = d;
        return Zi(s),
        d = eh(i, s, c, x, v, g),
        M = th(),
        i !== null && !ct ? (nh(i, s, g),
        dr(i, s, g)) : (Ne && M && _d(s),
        s.flags |= 1,
        wt(i, s, d, g),
        s.child)
    }
    function Iy(i, s, c, d, g) {
        if (i === null) {
            var v = c.type;
            return typeof v == "function" && !Dd(v) && v.defaultProps === void 0 && c.compare === null ? (s.tag = 15,
            s.type = v,
            Vy(i, s, v, d, g)) : (i = Za(c.type, null, d, s, s.mode, g),
            i.ref = s.ref,
            i.return = s,
            s.child = i)
        }
        if (v = i.child,
        !Mh(i, g)) {
            var x = v.memoizedProps;
            if (c = c.compare,
            c = c !== null ? c : ns,
            c(x, d) && i.ref === s.ref)
                return dr(i, s, g)
        }
        return s.flags |= 1,
        i = lr(v, d),
        i.ref = s.ref,
        i.return = s,
        s.child = i
    }
    function Vy(i, s, c, d, g) {
        if (i !== null) {
            var v = i.memoizedProps;
            if (ns(v, d) && i.ref === s.ref)
                if (ct = !1,
                s.pendingProps = d = v,
                Mh(i, g))
                    (i.flags & 131072) !== 0 && (ct = !0);
                else
                    return s.lanes = i.lanes,
                    dr(i, s, g)
        }
        return Ch(i, s, c, d, g)
    }
    function Uy(i, s, c, d) {
        var g = d.children
          , v = i !== null ? i.memoizedState : null;
        if (i === null && s.stateNode === null && (s.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        }),
        d.mode === "hidden") {
            if ((s.flags & 128) !== 0) {
                if (v = v !== null ? v.baseLanes | c : c,
                i !== null) {
                    for (d = s.child = i.child,
                    g = 0; d !== null; )
                        g = g | d.lanes | d.childLanes,
                        d = d.sibling;
                    d = g & ~v
                } else
                    d = 0,
                    s.child = null;
                return Py(i, s, v, c, d)
            }
            if ((c & 536870912) !== 0)
                s.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                i !== null && Qa(s, v !== null ? v.cachePool : null),
                v !== null ? $0(s, v) : Wd(),
                F0(s);
            else
                return d = s.lanes = 536870912,
                Py(i, s, v !== null ? v.baseLanes | c : c, c, d)
        } else
            v !== null ? (Qa(s, v.cachePool),
            $0(s, v),
            Yr(),
            s.memoizedState = null) : (i !== null && Qa(s, null),
            Wd(),
            Yr());
        return wt(i, s, g, c),
        s.child
    }
    function vs(i, s) {
        return i !== null && i.tag === 22 || s.stateNode !== null || (s.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        }),
        s.sibling
    }
    function Py(i, s, c, d, g) {
        var v = $d();
        return v = v === null ? null : {
            parent: st._currentValue,
            pool: v
        },
        s.memoizedState = {
            baseLanes: c,
            cachePool: v
        },
        i !== null && Qa(s, null),
        Wd(),
        F0(s),
        i !== null && Zo(i, s, d, !0),
        s.childLanes = g,
        null
    }
    function mc(i, s) {
        return s = yc({
            mode: s.mode,
            children: s.children
        }, i.mode),
        s.ref = i.ref,
        i.child = s,
        s.return = i,
        s
    }
    function qy(i, s, c) {
        return Qi(s, i.child, null, c),
        i = mc(s, s.pendingProps),
        i.flags |= 2,
        on(s),
        s.memoizedState = null,
        i
    }
    function Kw(i, s, c) {
        var d = s.pendingProps
          , g = (s.flags & 128) !== 0;
        if (s.flags &= -129,
        i === null) {
            if (Ne) {
                if (d.mode === "hidden")
                    return i = mc(s, d),
                    s.lanes = 536870912,
                    vs(null, i);
                if (Jd(s),
                (i = $e) ? (i = tv(i, bn),
                i = i !== null && i.data === "&" ? i : null,
                i !== null && (s.memoizedState = {
                    dehydrated: i,
                    treeContext: Vr !== null ? {
                        id: Hn,
                        overflow: In
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                },
                c = k0(i),
                c.return = s,
                s.child = c,
                St = s,
                $e = null)) : i = null,
                i === null)
                    throw Pr(s);
                return s.lanes = 536870912,
                null
            }
            return mc(s, d)
        }
        var v = i.memoizedState;
        if (v !== null) {
            var x = v.dehydrated;
            if (Jd(s),
            g)
                if (s.flags & 256)
                    s.flags &= -257,
                    s = qy(i, s, c);
                else if (s.memoizedState !== null)
                    s.child = i.child,
                    s.flags |= 128,
                    s = null;
                else
                    throw Error(r(558));
            else if (ct || Zo(i, s, c, !1),
            g = (c & i.childLanes) !== 0,
            ct || g) {
                if (d = Ie,
                d !== null && (x = Lg(d, c),
                x !== 0 && x !== v.retryLane))
                    throw v.retryLane = x,
                    Fi(i, x),
                    Gt(d, i, x),
                    bh;
                kc(),
                s = qy(i, s, c)
            } else
                i = v.treeContext,
                $e = Sn(x.nextSibling),
                St = s,
                Ne = !0,
                Ur = null,
                bn = !1,
                i !== null && N0(s, i),
                s = mc(s, d),
                s.flags |= 4096;
            return s
        }
        return i = lr(i.child, {
            mode: d.mode,
            children: d.children
        }),
        i.ref = s.ref,
        s.child = i,
        i.return = s,
        i
    }
    function gc(i, s) {
        var c = s.ref;
        if (c === null)
            i !== null && i.ref !== null && (s.flags |= 4194816);
        else {
            if (typeof c != "function" && typeof c != "object")
                throw Error(r(284));
            (i === null || i.ref !== c) && (s.flags |= 4194816)
        }
    }
    function Ch(i, s, c, d, g) {
        return Zi(s),
        c = eh(i, s, c, d, void 0, g),
        d = th(),
        i !== null && !ct ? (nh(i, s, g),
        dr(i, s, g)) : (Ne && d && _d(s),
        s.flags |= 1,
        wt(i, s, c, g),
        s.child)
    }
    function $y(i, s, c, d, g, v) {
        return Zi(s),
        s.updateQueue = null,
        c = G0(s, d, c, g),
        K0(i),
        d = th(),
        i !== null && !ct ? (nh(i, s, v),
        dr(i, s, v)) : (Ne && d && _d(s),
        s.flags |= 1,
        wt(i, s, c, v),
        s.child)
    }
    function Fy(i, s, c, d, g) {
        if (Zi(s),
        s.stateNode === null) {
            var v = Fo
              , x = c.contextType;
            typeof x == "object" && x !== null && (v = xt(x)),
            v = new c(d,v),
            s.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null,
            v.updater = yh,
            s.stateNode = v,
            v._reactInternals = s,
            v = s.stateNode,
            v.props = d,
            v.state = s.memoizedState,
            v.refs = {},
            Kd(s),
            x = c.contextType,
            v.context = typeof x == "object" && x !== null ? xt(x) : Fo,
            v.state = s.memoizedState,
            x = c.getDerivedStateFromProps,
            typeof x == "function" && (gh(s, c, x, d),
            v.state = s.memoizedState),
            typeof c.getDerivedStateFromProps == "function" || typeof v.getSnapshotBeforeUpdate == "function" || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (x = v.state,
            typeof v.componentWillMount == "function" && v.componentWillMount(),
            typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(),
            x !== v.state && yh.enqueueReplaceState(v, v.state, null),
            hs(s, d, v, g),
            ds(),
            v.state = s.memoizedState),
            typeof v.componentDidMount == "function" && (s.flags |= 4194308),
            d = !0
        } else if (i === null) {
            v = s.stateNode;
            var M = s.memoizedProps
              , N = to(c, M);
            v.props = N;
            var I = v.context
              , K = c.contextType;
            x = Fo,
            typeof K == "object" && K !== null && (x = xt(K));
            var Y = c.getDerivedStateFromProps;
            K = typeof Y == "function" || typeof v.getSnapshotBeforeUpdate == "function",
            M = s.pendingProps !== M,
            K || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (M || I !== x) && Oy(s, v, d, x),
            $r = !1;
            var V = s.memoizedState;
            v.state = V,
            hs(s, d, v, g),
            ds(),
            I = s.memoizedState,
            M || V !== I || $r ? (typeof Y == "function" && (gh(s, c, Y, d),
            I = s.memoizedState),
            (N = $r || Ry(s, c, N, d, V, I, x)) ? (K || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (typeof v.componentWillMount == "function" && v.componentWillMount(),
            typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount()),
            typeof v.componentDidMount == "function" && (s.flags |= 4194308)) : (typeof v.componentDidMount == "function" && (s.flags |= 4194308),
            s.memoizedProps = d,
            s.memoizedState = I),
            v.props = d,
            v.state = I,
            v.context = x,
            d = N) : (typeof v.componentDidMount == "function" && (s.flags |= 4194308),
            d = !1)
        } else {
            v = s.stateNode,
            Gd(i, s),
            x = s.memoizedProps,
            K = to(c, x),
            v.props = K,
            Y = s.pendingProps,
            V = v.context,
            I = c.contextType,
            N = Fo,
            typeof I == "object" && I !== null && (N = xt(I)),
            M = c.getDerivedStateFromProps,
            (I = typeof M == "function" || typeof v.getSnapshotBeforeUpdate == "function") || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (x !== Y || V !== N) && Oy(s, v, d, N),
            $r = !1,
            V = s.memoizedState,
            v.state = V,
            hs(s, d, v, g),
            ds();
            var F = s.memoizedState;
            x !== Y || V !== F || $r || i !== null && i.dependencies !== null && Xa(i.dependencies) ? (typeof M == "function" && (gh(s, c, M, d),
            F = s.memoizedState),
            (K = $r || Ry(s, c, K, d, V, F, N) || i !== null && i.dependencies !== null && Xa(i.dependencies)) ? (I || typeof v.UNSAFE_componentWillUpdate != "function" && typeof v.componentWillUpdate != "function" || (typeof v.componentWillUpdate == "function" && v.componentWillUpdate(d, F, N),
            typeof v.UNSAFE_componentWillUpdate == "function" && v.UNSAFE_componentWillUpdate(d, F, N)),
            typeof v.componentDidUpdate == "function" && (s.flags |= 4),
            typeof v.getSnapshotBeforeUpdate == "function" && (s.flags |= 1024)) : (typeof v.componentDidUpdate != "function" || x === i.memoizedProps && V === i.memoizedState || (s.flags |= 4),
            typeof v.getSnapshotBeforeUpdate != "function" || x === i.memoizedProps && V === i.memoizedState || (s.flags |= 1024),
            s.memoizedProps = d,
            s.memoizedState = F),
            v.props = d,
            v.state = F,
            v.context = N,
            d = K) : (typeof v.componentDidUpdate != "function" || x === i.memoizedProps && V === i.memoizedState || (s.flags |= 4),
            typeof v.getSnapshotBeforeUpdate != "function" || x === i.memoizedProps && V === i.memoizedState || (s.flags |= 1024),
            d = !1)
        }
        return v = d,
        gc(i, s),
        d = (s.flags & 128) !== 0,
        v || d ? (v = s.stateNode,
        c = d && typeof c.getDerivedStateFromError != "function" ? null : v.render(),
        s.flags |= 1,
        i !== null && d ? (s.child = Qi(s, i.child, null, g),
        s.child = Qi(s, null, c, g)) : wt(i, s, c, g),
        s.memoizedState = v.state,
        i = s.child) : i = dr(i, s, g),
        i
    }
    function Ky(i, s, c, d) {
        return Gi(),
        s.flags |= 256,
        wt(i, s, c, d),
        s.child
    }
    var Sh = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function xh(i) {
        return {
            baseLanes: i,
            cachePool: _0()
        }
    }
    function wh(i, s, c) {
        return i = i !== null ? i.childLanes & ~c : 0,
        s && (i |= sn),
        i
    }
    function Gy(i, s, c) {
        var d = s.pendingProps, g = !1, v = (s.flags & 128) !== 0, x;
        if ((x = v) || (x = i !== null && i.memoizedState === null ? !1 : (it.current & 2) !== 0),
        x && (g = !0,
        s.flags &= -129),
        x = (s.flags & 32) !== 0,
        s.flags &= -33,
        i === null) {
            if (Ne) {
                if (g ? Gr(s) : Yr(),
                (i = $e) ? (i = tv(i, bn),
                i = i !== null && i.data !== "&" ? i : null,
                i !== null && (s.memoizedState = {
                    dehydrated: i,
                    treeContext: Vr !== null ? {
                        id: Hn,
                        overflow: In
                    } : null,
                    retryLane: 536870912,
                    hydrationErrors: null
                },
                c = k0(i),
                c.return = s,
                s.child = c,
                St = s,
                $e = null)) : i = null,
                i === null)
                    throw Pr(s);
                return op(i) ? s.lanes = 32 : s.lanes = 536870912,
                null
            }
            var M = d.children;
            return d = d.fallback,
            g ? (Yr(),
            g = s.mode,
            M = yc({
                mode: "hidden",
                children: M
            }, g),
            d = Ki(d, g, c, null),
            M.return = s,
            d.return = s,
            M.sibling = d,
            s.child = M,
            d = s.child,
            d.memoizedState = xh(c),
            d.childLanes = wh(i, x, c),
            s.memoizedState = Sh,
            vs(null, d)) : (Gr(s),
            Eh(s, M))
        }
        var N = i.memoizedState;
        if (N !== null && (M = N.dehydrated,
        M !== null)) {
            if (v)
                s.flags & 256 ? (Gr(s),
                s.flags &= -257,
                s = Th(i, s, c)) : s.memoizedState !== null ? (Yr(),
                s.child = i.child,
                s.flags |= 128,
                s = null) : (Yr(),
                M = d.fallback,
                g = s.mode,
                d = yc({
                    mode: "visible",
                    children: d.children
                }, g),
                M = Ki(M, g, c, null),
                M.flags |= 2,
                d.return = s,
                M.return = s,
                d.sibling = M,
                s.child = d,
                Qi(s, i.child, null, c),
                d = s.child,
                d.memoizedState = xh(c),
                d.childLanes = wh(i, x, c),
                s.memoizedState = Sh,
                s = vs(null, d));
            else if (Gr(s),
            op(M)) {
                if (x = M.nextSibling && M.nextSibling.dataset,
                x)
                    var I = x.dgst;
                x = I,
                d = Error(r(419)),
                d.stack = "",
                d.digest = x,
                ls({
                    value: d,
                    source: null,
                    stack: null
                }),
                s = Th(i, s, c)
            } else if (ct || Zo(i, s, c, !1),
            x = (c & i.childLanes) !== 0,
            ct || x) {
                if (x = Ie,
                x !== null && (d = Lg(x, c),
                d !== 0 && d !== N.retryLane))
                    throw N.retryLane = d,
                    Fi(i, d),
                    Gt(x, i, d),
                    bh;
                ip(M) || kc(),
                s = Th(i, s, c)
            } else
                ip(M) ? (s.flags |= 192,
                s.child = i.child,
                s = null) : (i = N.treeContext,
                $e = Sn(M.nextSibling),
                St = s,
                Ne = !0,
                Ur = null,
                bn = !1,
                i !== null && N0(s, i),
                s = Eh(s, d.children),
                s.flags |= 4096);
            return s
        }
        return g ? (Yr(),
        M = d.fallback,
        g = s.mode,
        N = i.child,
        I = N.sibling,
        d = lr(N, {
            mode: "hidden",
            children: d.children
        }),
        d.subtreeFlags = N.subtreeFlags & 65011712,
        I !== null ? M = lr(I, M) : (M = Ki(M, g, c, null),
        M.flags |= 2),
        M.return = s,
        d.return = s,
        d.sibling = M,
        s.child = d,
        vs(null, d),
        d = s.child,
        M = i.child.memoizedState,
        M === null ? M = xh(c) : (g = M.cachePool,
        g !== null ? (N = st._currentValue,
        g = g.parent !== N ? {
            parent: N,
            pool: N
        } : g) : g = _0(),
        M = {
            baseLanes: M.baseLanes | c,
            cachePool: g
        }),
        d.memoizedState = M,
        d.childLanes = wh(i, x, c),
        s.memoizedState = Sh,
        vs(i.child, d)) : (Gr(s),
        c = i.child,
        i = c.sibling,
        c = lr(c, {
            mode: "visible",
            children: d.children
        }),
        c.return = s,
        c.sibling = null,
        i !== null && (x = s.deletions,
        x === null ? (s.deletions = [i],
        s.flags |= 16) : x.push(i)),
        s.child = c,
        s.memoizedState = null,
        c)
    }
    function Eh(i, s) {
        return s = yc({
            mode: "visible",
            children: s
        }, i.mode),
        s.return = i,
        i.child = s
    }
    function yc(i, s) {
        return i = nn(22, i, null, s),
        i.lanes = 0,
        i
    }
    function Th(i, s, c) {
        return Qi(s, i.child, null, c),
        i = Eh(s, s.pendingProps.children),
        i.flags |= 2,
        s.memoizedState = null,
        i
    }
    function Yy(i, s, c) {
        i.lanes |= s;
        var d = i.alternate;
        d !== null && (d.lanes |= s),
        Vd(i.return, s, c)
    }
    function kh(i, s, c, d, g, v) {
        var x = i.memoizedState;
        x === null ? i.memoizedState = {
            isBackwards: s,
            rendering: null,
            renderingStartTime: 0,
            last: d,
            tail: c,
            tailMode: g,
            treeForkCount: v
        } : (x.isBackwards = s,
        x.rendering = null,
        x.renderingStartTime = 0,
        x.last = d,
        x.tail = c,
        x.tailMode = g,
        x.treeForkCount = v)
    }
    function Zy(i, s, c) {
        var d = s.pendingProps
          , g = d.revealOrder
          , v = d.tail;
        d = d.children;
        var x = it.current
          , M = (x & 2) !== 0;
        if (M ? (x = x & 1 | 2,
        s.flags |= 128) : x &= 1,
        X(it, x),
        wt(i, s, d, c),
        d = Ne ? is : 0,
        !M && i !== null && (i.flags & 128) !== 0)
            e: for (i = s.child; i !== null; ) {
                if (i.tag === 13)
                    i.memoizedState !== null && Yy(i, c, s);
                else if (i.tag === 19)
                    Yy(i, c, s);
                else if (i.child !== null) {
                    i.child.return = i,
                    i = i.child;
                    continue
                }
                if (i === s)
                    break e;
                for (; i.sibling === null; ) {
                    if (i.return === null || i.return === s)
                        break e;
                    i = i.return
                }
                i.sibling.return = i.return,
                i = i.sibling
            }
        switch (g) {
        case "forwards":
            for (c = s.child,
            g = null; c !== null; )
                i = c.alternate,
                i !== null && oc(i) === null && (g = c),
                c = c.sibling;
            c = g,
            c === null ? (g = s.child,
            s.child = null) : (g = c.sibling,
            c.sibling = null),
            kh(s, !1, g, c, v, d);
            break;
        case "backwards":
        case "unstable_legacy-backwards":
            for (c = null,
            g = s.child,
            s.child = null; g !== null; ) {
                if (i = g.alternate,
                i !== null && oc(i) === null) {
                    s.child = g;
                    break
                }
                i = g.sibling,
                g.sibling = c,
                c = g,
                g = i
            }
            kh(s, !0, c, null, v, d);
            break;
        case "together":
            kh(s, !1, null, null, void 0, d);
            break;
        default:
            s.memoizedState = null
        }
        return s.child
    }
    function dr(i, s, c) {
        if (i !== null && (s.dependencies = i.dependencies),
        Xr |= s.lanes,
        (c & s.childLanes) === 0)
            if (i !== null) {
                if (Zo(i, s, c, !1),
                (c & s.childLanes) === 0)
                    return null
            } else
                return null;
        if (i !== null && s.child !== i.child)
            throw Error(r(153));
        if (s.child !== null) {
            for (i = s.child,
            c = lr(i, i.pendingProps),
            s.child = c,
            c.return = s; i.sibling !== null; )
                i = i.sibling,
                c = c.sibling = lr(i, i.pendingProps),
                c.return = s;
            c.sibling = null
        }
        return s.child
    }
    function Mh(i, s) {
        return (i.lanes & s) !== 0 ? !0 : (i = i.dependencies,
        !!(i !== null && Xa(i)))
    }
    function Gw(i, s, c) {
        switch (s.tag) {
        case 3:
            lt(s, s.stateNode.containerInfo),
            qr(s, st, i.memoizedState.cache),
            Gi();
            break;
        case 27:
        case 5:
            er(s);
            break;
        case 4:
            lt(s, s.stateNode.containerInfo);
            break;
        case 10:
            qr(s, s.type, s.memoizedProps.value);
            break;
        case 31:
            if (s.memoizedState !== null)
                return s.flags |= 128,
                Jd(s),
                null;
            break;
        case 13:
            var d = s.memoizedState;
            if (d !== null)
                return d.dehydrated !== null ? (Gr(s),
                s.flags |= 128,
                null) : (c & s.child.childLanes) !== 0 ? Gy(i, s, c) : (Gr(s),
                i = dr(i, s, c),
                i !== null ? i.sibling : null);
            Gr(s);
            break;
        case 19:
            var g = (i.flags & 128) !== 0;
            if (d = (c & s.childLanes) !== 0,
            d || (Zo(i, s, c, !1),
            d = (c & s.childLanes) !== 0),
            g) {
                if (d)
                    return Zy(i, s, c);
                s.flags |= 128
            }
            if (g = s.memoizedState,
            g !== null && (g.rendering = null,
            g.tail = null,
            g.lastEffect = null),
            X(it, it.current),
            d)
                break;
            return null;
        case 22:
            return s.lanes = 0,
            Uy(i, s, c, s.pendingProps);
        case 24:
            qr(s, st, i.memoizedState.cache)
        }
        return dr(i, s, c)
    }
    function Wy(i, s, c) {
        if (i !== null)
            if (i.memoizedProps !== s.pendingProps)
                ct = !0;
            else {
                if (!Mh(i, c) && (s.flags & 128) === 0)
                    return ct = !1,
                    Gw(i, s, c);
                ct = (i.flags & 131072) !== 0
            }
        else
            ct = !1,
            Ne && (s.flags & 1048576) !== 0 && A0(s, is, s.index);
        switch (s.lanes = 0,
        s.tag) {
        case 16:
            e: {
                var d = s.pendingProps;
                if (i = Xi(s.elementType),
                s.type = i,
                typeof i == "function")
                    Dd(i) ? (d = to(i, d),
                    s.tag = 1,
                    s = Fy(null, s, i, d, c)) : (s.tag = 0,
                    s = Ch(null, s, i, d, c));
                else {
                    if (i != null) {
                        var g = i.$$typeof;
                        if (g === B) {
                            s.tag = 11,
                            s = Hy(null, s, i, d, c);
                            break e
                        } else if (g === _) {
                            s.tag = 14,
                            s = Iy(null, s, i, d, c);
                            break e
                        }
                    }
                    throw s = Q(i) || i,
                    Error(r(306, s, ""))
                }
            }
            return s;
        case 0:
            return Ch(i, s, s.type, s.pendingProps, c);
        case 1:
            return d = s.type,
            g = to(d, s.pendingProps),
            Fy(i, s, d, g, c);
        case 3:
            e: {
                if (lt(s, s.stateNode.containerInfo),
                i === null)
                    throw Error(r(387));
                d = s.pendingProps;
                var v = s.memoizedState;
                g = v.element,
                Gd(i, s),
                hs(s, d, null, c);
                var x = s.memoizedState;
                if (d = x.cache,
                qr(s, st, d),
                d !== v.cache && Ud(s, [st], c, !0),
                ds(),
                d = x.element,
                v.isDehydrated)
                    if (v = {
                        element: d,
                        isDehydrated: !1,
                        cache: x.cache
                    },
                    s.updateQueue.baseState = v,
                    s.memoizedState = v,
                    s.flags & 256) {
                        s = Ky(i, s, d, c);
                        break e
                    } else if (d !== g) {
                        g = gn(Error(r(424)), s),
                        ls(g),
                        s = Ky(i, s, d, c);
                        break e
                    } else
                        for (i = s.stateNode.containerInfo,
                        i.nodeType === 9 ? i = i.body : i = i.nodeName === "HTML" ? i.ownerDocument.body : i,
                        $e = Sn(i.firstChild),
                        St = s,
                        Ne = !0,
                        Ur = null,
                        bn = !0,
                        c = U0(s, null, d, c),
                        s.child = c; c; )
                            c.flags = c.flags & -3 | 4096,
                            c = c.sibling;
                else {
                    if (Gi(),
                    d === g) {
                        s = dr(i, s, c);
                        break e
                    }
                    wt(i, s, d, c)
                }
                s = s.child
            }
            return s;
        case 26:
            return gc(i, s),
            i === null ? (c = sv(s.type, null, s.pendingProps, null)) ? s.memoizedState = c : Ne || (c = s.type,
            i = s.pendingProps,
            d = Lc(ge.current).createElement(c),
            d[Ct] = s,
            d[Ut] = i,
            Et(d, c, i),
            pt(d),
            s.stateNode = d) : s.memoizedState = sv(s.type, i.memoizedProps, s.pendingProps, i.memoizedState),
            null;
        case 27:
            return er(s),
            i === null && Ne && (d = s.stateNode = iv(s.type, s.pendingProps, ge.current),
            St = s,
            bn = !0,
            g = $e,
            ni(s.type) ? (lp = g,
            $e = Sn(d.firstChild)) : $e = g),
            wt(i, s, s.pendingProps.children, c),
            gc(i, s),
            i === null && (s.flags |= 4194304),
            s.child;
        case 5:
            return i === null && Ne && ((g = d = $e) && (d = w9(d, s.type, s.pendingProps, bn),
            d !== null ? (s.stateNode = d,
            St = s,
            $e = Sn(d.firstChild),
            bn = !1,
            g = !0) : g = !1),
            g || Pr(s)),
            er(s),
            g = s.type,
            v = s.pendingProps,
            x = i !== null ? i.memoizedProps : null,
            d = v.children,
            tp(g, v) ? d = null : x !== null && tp(g, x) && (s.flags |= 32),
            s.memoizedState !== null && (g = eh(i, s, Hw, null, null, c),
            Ls._currentValue = g),
            gc(i, s),
            wt(i, s, d, c),
            s.child;
        case 6:
            return i === null && Ne && ((i = c = $e) && (c = E9(c, s.pendingProps, bn),
            c !== null ? (s.stateNode = c,
            St = s,
            $e = null,
            i = !0) : i = !1),
            i || Pr(s)),
            null;
        case 13:
            return Gy(i, s, c);
        case 4:
            return lt(s, s.stateNode.containerInfo),
            d = s.pendingProps,
            i === null ? s.child = Qi(s, null, d, c) : wt(i, s, d, c),
            s.child;
        case 11:
            return Hy(i, s, s.type, s.pendingProps, c);
        case 7:
            return wt(i, s, s.pendingProps, c),
            s.child;
        case 8:
            return wt(i, s, s.pendingProps.children, c),
            s.child;
        case 12:
            return wt(i, s, s.pendingProps.children, c),
            s.child;
        case 10:
            return d = s.pendingProps,
            qr(s, s.type, d.value),
            wt(i, s, d.children, c),
            s.child;
        case 9:
            return g = s.type._context,
            d = s.pendingProps.children,
            Zi(s),
            g = xt(g),
            d = d(g),
            s.flags |= 1,
            wt(i, s, d, c),
            s.child;
        case 14:
            return Iy(i, s, s.type, s.pendingProps, c);
        case 15:
            return Vy(i, s, s.type, s.pendingProps, c);
        case 19:
            return Zy(i, s, c);
        case 31:
            return Kw(i, s, c);
        case 22:
            return Uy(i, s, c, s.pendingProps);
        case 24:
            return Zi(s),
            d = xt(st),
            i === null ? (g = $d(),
            g === null && (g = Ie,
            v = Pd(),
            g.pooledCache = v,
            v.refCount++,
            v !== null && (g.pooledCacheLanes |= c),
            g = v),
            s.memoizedState = {
                parent: d,
                cache: g
            },
            Kd(s),
            qr(s, st, g)) : ((i.lanes & c) !== 0 && (Gd(i, s),
            hs(s, null, null, c),
            ds()),
            g = i.memoizedState,
            v = s.memoizedState,
            g.parent !== d ? (g = {
                parent: d,
                cache: d
            },
            s.memoizedState = g,
            s.lanes === 0 && (s.memoizedState = s.updateQueue.baseState = g),
            qr(s, st, d)) : (d = v.cache,
            qr(s, st, d),
            d !== g.cache && Ud(s, [st], c, !0))),
            wt(i, s, s.pendingProps.children, c),
            s.child;
        case 29:
            throw s.pendingProps
        }
        throw Error(r(156, s.tag))
    }
    function hr(i) {
        i.flags |= 4
    }
    function Ah(i, s, c, d, g) {
        if ((s = (i.mode & 32) !== 0) && (s = !1),
        s) {
            if (i.flags |= 16777216,
            (g & 335544128) === g)
                if (i.stateNode.complete)
                    i.flags |= 8192;
                else if (w2())
                    i.flags |= 8192;
                else
                    throw Ji = tc,
                    Fd
        } else
            i.flags &= -16777217
    }
    function Xy(i, s) {
        if (s.type !== "stylesheet" || (s.state.loading & 4) !== 0)
            i.flags &= -16777217;
        else if (i.flags |= 16777216,
        !dv(s))
            if (w2())
                i.flags |= 8192;
            else
                throw Ji = tc,
                Fd
    }
    function vc(i, s) {
        s !== null && (i.flags |= 4),
        i.flags & 16384 && (s = i.tag !== 22 ? Rg() : 536870912,
        i.lanes |= s,
        sl |= s)
    }
    function bs(i, s) {
        if (!Ne)
            switch (i.tailMode) {
            case "hidden":
                s = i.tail;
                for (var c = null; s !== null; )
                    s.alternate !== null && (c = s),
                    s = s.sibling;
                c === null ? i.tail = null : c.sibling = null;
                break;
            case "collapsed":
                c = i.tail;
                for (var d = null; c !== null; )
                    c.alternate !== null && (d = c),
                    c = c.sibling;
                d === null ? s || i.tail === null ? i.tail = null : i.tail.sibling = null : d.sibling = null
            }
    }
    function Fe(i) {
        var s = i.alternate !== null && i.alternate.child === i.child
          , c = 0
          , d = 0;
        if (s)
            for (var g = i.child; g !== null; )
                c |= g.lanes | g.childLanes,
                d |= g.subtreeFlags & 65011712,
                d |= g.flags & 65011712,
                g.return = i,
                g = g.sibling;
        else
            for (g = i.child; g !== null; )
                c |= g.lanes | g.childLanes,
                d |= g.subtreeFlags,
                d |= g.flags,
                g.return = i,
                g = g.sibling;
        return i.subtreeFlags |= d,
        i.childLanes = c,
        s
    }
    function Yw(i, s, c) {
        var d = s.pendingProps;
        switch (Bd(s),
        s.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Fe(s),
            null;
        case 1:
            return Fe(s),
            null;
        case 3:
            return c = s.stateNode,
            d = null,
            i !== null && (d = i.memoizedState.cache),
            s.memoizedState.cache !== d && (s.flags |= 2048),
            cr(st),
            qe(),
            c.pendingContext && (c.context = c.pendingContext,
            c.pendingContext = null),
            (i === null || i.child === null) && (Yo(s) ? hr(s) : i === null || i.memoizedState.isDehydrated && (s.flags & 256) === 0 || (s.flags |= 1024,
            Hd())),
            Fe(s),
            null;
        case 26:
            var g = s.type
              , v = s.memoizedState;
            return i === null ? (hr(s),
            v !== null ? (Fe(s),
            Xy(s, v)) : (Fe(s),
            Ah(s, g, null, d, c))) : v ? v !== i.memoizedState ? (hr(s),
            Fe(s),
            Xy(s, v)) : (Fe(s),
            s.flags &= -16777217) : (i = i.memoizedProps,
            i !== d && hr(s),
            Fe(s),
            Ah(s, g, i, d, c)),
            null;
        case 27:
            if (Br(s),
            c = ge.current,
            g = s.type,
            i !== null && s.stateNode != null)
                i.memoizedProps !== d && hr(s);
            else {
                if (!d) {
                    if (s.stateNode === null)
                        throw Error(r(166));
                    return Fe(s),
                    null
                }
                i = re.current,
                Yo(s) ? R0(s) : (i = iv(g, d, c),
                s.stateNode = i,
                hr(s))
            }
            return Fe(s),
            null;
        case 5:
            if (Br(s),
            g = s.type,
            i !== null && s.stateNode != null)
                i.memoizedProps !== d && hr(s);
            else {
                if (!d) {
                    if (s.stateNode === null)
                        throw Error(r(166));
                    return Fe(s),
                    null
                }
                if (v = re.current,
                Yo(s))
                    R0(s);
                else {
                    var x = Lc(ge.current);
                    switch (v) {
                    case 1:
                        v = x.createElementNS("http://www.w3.org/2000/svg", g);
                        break;
                    case 2:
                        v = x.createElementNS("http://www.w3.org/1998/Math/MathML", g);
                        break;
                    default:
                        switch (g) {
                        case "svg":
                            v = x.createElementNS("http://www.w3.org/2000/svg", g);
                            break;
                        case "math":
                            v = x.createElementNS("http://www.w3.org/1998/Math/MathML", g);
                            break;
                        case "script":
                            v = x.createElement("div"),
                            v.innerHTML = "<script><\/script>",
                            v = v.removeChild(v.firstChild);
                            break;
                        case "select":
                            v = typeof d.is == "string" ? x.createElement("select", {
                                is: d.is
                            }) : x.createElement("select"),
                            d.multiple ? v.multiple = !0 : d.size && (v.size = d.size);
                            break;
                        default:
                            v = typeof d.is == "string" ? x.createElement(g, {
                                is: d.is
                            }) : x.createElement(g)
                        }
                    }
                    v[Ct] = s,
                    v[Ut] = d;
                    e: for (x = s.child; x !== null; ) {
                        if (x.tag === 5 || x.tag === 6)
                            v.appendChild(x.stateNode);
                        else if (x.tag !== 4 && x.tag !== 27 && x.child !== null) {
                            x.child.return = x,
                            x = x.child;
                            continue
                        }
                        if (x === s)
                            break e;
                        for (; x.sibling === null; ) {
                            if (x.return === null || x.return === s)
                                break e;
                            x = x.return
                        }
                        x.sibling.return = x.return,
                        x = x.sibling
                    }
                    s.stateNode = v;
                    e: switch (Et(v, g, d),
                    g) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        d = !!d.autoFocus;
                        break e;
                    case "img":
                        d = !0;
                        break e;
                    default:
                        d = !1
                    }
                    d && hr(s)
                }
            }
            return Fe(s),
            Ah(s, s.type, i === null ? null : i.memoizedProps, s.pendingProps, c),
            null;
        case 6:
            if (i && s.stateNode != null)
                i.memoizedProps !== d && hr(s);
            else {
                if (typeof d != "string" && s.stateNode === null)
                    throw Error(r(166));
                if (i = ge.current,
                Yo(s)) {
                    if (i = s.stateNode,
                    c = s.memoizedProps,
                    d = null,
                    g = St,
                    g !== null)
                        switch (g.tag) {
                        case 27:
                        case 5:
                            d = g.memoizedProps
                        }
                    i[Ct] = s,
                    i = !!(i.nodeValue === c || d !== null && d.suppressHydrationWarning === !0 || G2(i.nodeValue, c)),
                    i || Pr(s, !0)
                } else
                    i = Lc(i).createTextNode(d),
                    i[Ct] = s,
                    s.stateNode = i
            }
            return Fe(s),
            null;
        case 31:
            if (c = s.memoizedState,
            i === null || i.memoizedState !== null) {
                if (d = Yo(s),
                c !== null) {
                    if (i === null) {
                        if (!d)
                            throw Error(r(318));
                        if (i = s.memoizedState,
                        i = i !== null ? i.dehydrated : null,
                        !i)
                            throw Error(r(557));
                        i[Ct] = s
                    } else
                        Gi(),
                        (s.flags & 128) === 0 && (s.memoizedState = null),
                        s.flags |= 4;
                    Fe(s),
                    i = !1
                } else
                    c = Hd(),
                    i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = c),
                    i = !0;
                if (!i)
                    return s.flags & 256 ? (on(s),
                    s) : (on(s),
                    null);
                if ((s.flags & 128) !== 0)
                    throw Error(r(558))
            }
            return Fe(s),
            null;
        case 13:
            if (d = s.memoizedState,
            i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
                if (g = Yo(s),
                d !== null && d.dehydrated !== null) {
                    if (i === null) {
                        if (!g)
                            throw Error(r(318));
                        if (g = s.memoizedState,
                        g = g !== null ? g.dehydrated : null,
                        !g)
                            throw Error(r(317));
                        g[Ct] = s
                    } else
                        Gi(),
                        (s.flags & 128) === 0 && (s.memoizedState = null),
                        s.flags |= 4;
                    Fe(s),
                    g = !1
                } else
                    g = Hd(),
                    i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = g),
                    g = !0;
                if (!g)
                    return s.flags & 256 ? (on(s),
                    s) : (on(s),
                    null)
            }
            return on(s),
            (s.flags & 128) !== 0 ? (s.lanes = c,
            s) : (c = d !== null,
            i = i !== null && i.memoizedState !== null,
            c && (d = s.child,
            g = null,
            d.alternate !== null && d.alternate.memoizedState !== null && d.alternate.memoizedState.cachePool !== null && (g = d.alternate.memoizedState.cachePool.pool),
            v = null,
            d.memoizedState !== null && d.memoizedState.cachePool !== null && (v = d.memoizedState.cachePool.pool),
            v !== g && (d.flags |= 2048)),
            c !== i && c && (s.child.flags |= 8192),
            vc(s, s.updateQueue),
            Fe(s),
            null);
        case 4:
            return qe(),
            i === null && Wh(s.stateNode.containerInfo),
            Fe(s),
            null;
        case 10:
            return cr(s.type),
            Fe(s),
            null;
        case 19:
            if (U(it),
            d = s.memoizedState,
            d === null)
                return Fe(s),
                null;
            if (g = (s.flags & 128) !== 0,
            v = d.rendering,
            v === null)
                if (g)
                    bs(d, !1);
                else {
                    if (Je !== 0 || i !== null && (i.flags & 128) !== 0)
                        for (i = s.child; i !== null; ) {
                            if (v = oc(i),
                            v !== null) {
                                for (s.flags |= 128,
                                bs(d, !1),
                                i = v.updateQueue,
                                s.updateQueue = i,
                                vc(s, i),
                                s.subtreeFlags = 0,
                                i = c,
                                c = s.child; c !== null; )
                                    T0(c, i),
                                    c = c.sibling;
                                return X(it, it.current & 1 | 2),
                                Ne && sr(s, d.treeForkCount),
                                s.child
                            }
                            i = i.sibling
                        }
                    d.tail !== null && Jt() > wc && (s.flags |= 128,
                    g = !0,
                    bs(d, !1),
                    s.lanes = 4194304)
                }
            else {
                if (!g)
                    if (i = oc(v),
                    i !== null) {
                        if (s.flags |= 128,
                        g = !0,
                        i = i.updateQueue,
                        s.updateQueue = i,
                        vc(s, i),
                        bs(d, !0),
                        d.tail === null && d.tailMode === "hidden" && !v.alternate && !Ne)
                            return Fe(s),
                            null
                    } else
                        2 * Jt() - d.renderingStartTime > wc && c !== 536870912 && (s.flags |= 128,
                        g = !0,
                        bs(d, !1),
                        s.lanes = 4194304);
                d.isBackwards ? (v.sibling = s.child,
                s.child = v) : (i = d.last,
                i !== null ? i.sibling = v : s.child = v,
                d.last = v)
            }
            return d.tail !== null ? (i = d.tail,
            d.rendering = i,
            d.tail = i.sibling,
            d.renderingStartTime = Jt(),
            i.sibling = null,
            c = it.current,
            X(it, g ? c & 1 | 2 : c & 1),
            Ne && sr(s, d.treeForkCount),
            i) : (Fe(s),
            null);
        case 22:
        case 23:
            return on(s),
            Xd(),
            d = s.memoizedState !== null,
            i !== null ? i.memoizedState !== null !== d && (s.flags |= 8192) : d && (s.flags |= 8192),
            d ? (c & 536870912) !== 0 && (s.flags & 128) === 0 && (Fe(s),
            s.subtreeFlags & 6 && (s.flags |= 8192)) : Fe(s),
            c = s.updateQueue,
            c !== null && vc(s, c.retryQueue),
            c = null,
            i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (c = i.memoizedState.cachePool.pool),
            d = null,
            s.memoizedState !== null && s.memoizedState.cachePool !== null && (d = s.memoizedState.cachePool.pool),
            d !== c && (s.flags |= 2048),
            i !== null && U(Wi),
            null;
        case 24:
            return c = null,
            i !== null && (c = i.memoizedState.cache),
            s.memoizedState.cache !== c && (s.flags |= 2048),
            cr(st),
            Fe(s),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(r(156, s.tag))
    }
    function Zw(i, s) {
        switch (Bd(s),
        s.tag) {
        case 1:
            return i = s.flags,
            i & 65536 ? (s.flags = i & -65537 | 128,
            s) : null;
        case 3:
            return cr(st),
            qe(),
            i = s.flags,
            (i & 65536) !== 0 && (i & 128) === 0 ? (s.flags = i & -65537 | 128,
            s) : null;
        case 26:
        case 27:
        case 5:
            return Br(s),
            null;
        case 31:
            if (s.memoizedState !== null) {
                if (on(s),
                s.alternate === null)
                    throw Error(r(340));
                Gi()
            }
            return i = s.flags,
            i & 65536 ? (s.flags = i & -65537 | 128,
            s) : null;
        case 13:
            if (on(s),
            i = s.memoizedState,
            i !== null && i.dehydrated !== null) {
                if (s.alternate === null)
                    throw Error(r(340));
                Gi()
            }
            return i = s.flags,
            i & 65536 ? (s.flags = i & -65537 | 128,
            s) : null;
        case 19:
            return U(it),
            null;
        case 4:
            return qe(),
            null;
        case 10:
            return cr(s.type),
            null;
        case 22:
        case 23:
            return on(s),
            Xd(),
            i !== null && U(Wi),
            i = s.flags,
            i & 65536 ? (s.flags = i & -65537 | 128,
            s) : null;
        case 24:
            return cr(st),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function Jy(i, s) {
        switch (Bd(s),
        s.tag) {
        case 3:
            cr(st),
            qe();
            break;
        case 26:
        case 27:
        case 5:
            Br(s);
            break;
        case 4:
            qe();
            break;
        case 31:
            s.memoizedState !== null && on(s);
            break;
        case 13:
            on(s);
            break;
        case 19:
            U(it);
            break;
        case 10:
            cr(s.type);
            break;
        case 22:
        case 23:
            on(s),
            Xd(),
            i !== null && U(Wi);
            break;
        case 24:
            cr(st)
        }
    }
    function Cs(i, s) {
        try {
            var c = s.updateQueue
              , d = c !== null ? c.lastEffect : null;
            if (d !== null) {
                var g = d.next;
                c = g;
                do {
                    if ((c.tag & i) === i) {
                        d = void 0;
                        var v = c.create
                          , x = c.inst;
                        d = v(),
                        x.destroy = d
                    }
                    c = c.next
                } while (c !== g)
            }
        } catch (M) {
            _e(s, s.return, M)
        }
    }
    function Zr(i, s, c) {
        try {
            var d = s.updateQueue
              , g = d !== null ? d.lastEffect : null;
            if (g !== null) {
                var v = g.next;
                d = v;
                do {
                    if ((d.tag & i) === i) {
                        var x = d.inst
                          , M = x.destroy;
                        if (M !== void 0) {
                            x.destroy = void 0,
                            g = s;
                            var N = c
                              , I = M;
                            try {
                                I()
                            } catch (K) {
                                _e(g, N, K)
                            }
                        }
                    }
                    d = d.next
                } while (d !== v)
            }
        } catch (K) {
            _e(s, s.return, K)
        }
    }
    function Qy(i) {
        var s = i.updateQueue;
        if (s !== null) {
            var c = i.stateNode;
            try {
                q0(s, c)
            } catch (d) {
                _e(i, i.return, d)
            }
        }
    }
    function e2(i, s, c) {
        c.props = to(i.type, i.memoizedProps),
        c.state = i.memoizedState;
        try {
            c.componentWillUnmount()
        } catch (d) {
            _e(i, s, d)
        }
    }
    function Ss(i, s) {
        try {
            var c = i.ref;
            if (c !== null) {
                switch (i.tag) {
                case 26:
                case 27:
                case 5:
                    var d = i.stateNode;
                    break;
                case 30:
                    d = i.stateNode;
                    break;
                default:
                    d = i.stateNode
                }
                typeof c == "function" ? i.refCleanup = c(d) : c.current = d
            }
        } catch (g) {
            _e(i, s, g)
        }
    }
    function Vn(i, s) {
        var c = i.ref
          , d = i.refCleanup;
        if (c !== null)
            if (typeof d == "function")
                try {
                    d()
                } catch (g) {
                    _e(i, s, g)
                } finally {
                    i.refCleanup = null,
                    i = i.alternate,
                    i != null && (i.refCleanup = null)
                }
            else if (typeof c == "function")
                try {
                    c(null)
                } catch (g) {
                    _e(i, s, g)
                }
            else
                c.current = null
    }
    function t2(i) {
        var s = i.type
          , c = i.memoizedProps
          , d = i.stateNode;
        try {
            e: switch (s) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                c.autoFocus && d.focus();
                break e;
            case "img":
                c.src ? d.src = c.src : c.srcSet && (d.srcset = c.srcSet)
            }
        } catch (g) {
            _e(i, i.return, g)
        }
    }
    function Nh(i, s, c) {
        try {
            var d = i.stateNode;
            y9(d, i.type, c, s),
            d[Ut] = s
        } catch (g) {
            _e(i, i.return, g)
        }
    }
    function n2(i) {
        return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && ni(i.type) || i.tag === 4
    }
    function Rh(i) {
        e: for (; ; ) {
            for (; i.sibling === null; ) {
                if (i.return === null || n2(i.return))
                    return null;
                i = i.return
            }
            for (i.sibling.return = i.return,
            i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
                if (i.tag === 27 && ni(i.type) || i.flags & 2 || i.child === null || i.tag === 4)
                    continue e;
                i.child.return = i,
                i = i.child
            }
            if (!(i.flags & 2))
                return i.stateNode
        }
    }
    function Oh(i, s, c) {
        var d = i.tag;
        if (d === 5 || d === 6)
            i = i.stateNode,
            s ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(i, s) : (s = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c,
            s.appendChild(i),
            c = c._reactRootContainer,
            c != null || s.onclick !== null || (s.onclick = ir));
        else if (d !== 4 && (d === 27 && ni(i.type) && (c = i.stateNode,
        s = null),
        i = i.child,
        i !== null))
            for (Oh(i, s, c),
            i = i.sibling; i !== null; )
                Oh(i, s, c),
                i = i.sibling
    }
    function bc(i, s, c) {
        var d = i.tag;
        if (d === 5 || d === 6)
            i = i.stateNode,
            s ? c.insertBefore(i, s) : c.appendChild(i);
        else if (d !== 4 && (d === 27 && ni(i.type) && (c = i.stateNode),
        i = i.child,
        i !== null))
            for (bc(i, s, c),
            i = i.sibling; i !== null; )
                bc(i, s, c),
                i = i.sibling
    }
    function r2(i) {
        var s = i.stateNode
          , c = i.memoizedProps;
        try {
            for (var d = i.type, g = s.attributes; g.length; )
                s.removeAttributeNode(g[0]);
            Et(s, d, c),
            s[Ct] = i,
            s[Ut] = c
        } catch (v) {
            _e(i, i.return, v)
        }
    }
    var pr = !1
      , ut = !1
      , Dh = !1
      , i2 = typeof WeakSet == "function" ? WeakSet : Set
      , mt = null;
    function Ww(i, s) {
        if (i = i.containerInfo,
        Qh = Vc,
        i = g0(i),
        Td(i)) {
            if ("selectionStart"in i)
                var c = {
                    start: i.selectionStart,
                    end: i.selectionEnd
                };
            else
                e: {
                    c = (c = i.ownerDocument) && c.defaultView || window;
                    var d = c.getSelection && c.getSelection();
                    if (d && d.rangeCount !== 0) {
                        c = d.anchorNode;
                        var g = d.anchorOffset
                          , v = d.focusNode;
                        d = d.focusOffset;
                        try {
                            c.nodeType,
                            v.nodeType
                        } catch {
                            c = null;
                            break e
                        }
                        var x = 0
                          , M = -1
                          , N = -1
                          , I = 0
                          , K = 0
                          , Y = i
                          , V = null;
                        t: for (; ; ) {
                            for (var F; Y !== c || g !== 0 && Y.nodeType !== 3 || (M = x + g),
                            Y !== v || d !== 0 && Y.nodeType !== 3 || (N = x + d),
                            Y.nodeType === 3 && (x += Y.nodeValue.length),
                            (F = Y.firstChild) !== null; )
                                V = Y,
                                Y = F;
                            for (; ; ) {
                                if (Y === i)
                                    break t;
                                if (V === c && ++I === g && (M = x),
                                V === v && ++K === d && (N = x),
                                (F = Y.nextSibling) !== null)
                                    break;
                                Y = V,
                                V = Y.parentNode
                            }
                            Y = F
                        }
                        c = M === -1 || N === -1 ? null : {
                            start: M,
                            end: N
                        }
                    } else
                        c = null
                }
            c = c || {
                start: 0,
                end: 0
            }
        } else
            c = null;
        for (ep = {
            focusedElem: i,
            selectionRange: c
        },
        Vc = !1,
        mt = s; mt !== null; )
            if (s = mt,
            i = s.child,
            (s.subtreeFlags & 1028) !== 0 && i !== null)
                i.return = s,
                mt = i;
            else
                for (; mt !== null; ) {
                    switch (s = mt,
                    v = s.alternate,
                    i = s.flags,
                    s.tag) {
                    case 0:
                        if ((i & 4) !== 0 && (i = s.updateQueue,
                        i = i !== null ? i.events : null,
                        i !== null))
                            for (c = 0; c < i.length; c++)
                                g = i[c],
                                g.ref.impl = g.nextImpl;
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((i & 1024) !== 0 && v !== null) {
                            i = void 0,
                            c = s,
                            g = v.memoizedProps,
                            v = v.memoizedState,
                            d = c.stateNode;
                            try {
                                var oe = to(c.type, g);
                                i = d.getSnapshotBeforeUpdate(oe, v),
                                d.__reactInternalSnapshotBeforeUpdate = i
                            } catch (me) {
                                _e(c, c.return, me)
                            }
                        }
                        break;
                    case 3:
                        if ((i & 1024) !== 0) {
                            if (i = s.stateNode.containerInfo,
                            c = i.nodeType,
                            c === 9)
                                rp(i);
                            else if (c === 1)
                                switch (i.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    rp(i);
                                    break;
                                default:
                                    i.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((i & 1024) !== 0)
                            throw Error(r(163))
                    }
                    if (i = s.sibling,
                    i !== null) {
                        i.return = s.return,
                        mt = i;
                        break
                    }
                    mt = s.return
                }
    }
    function o2(i, s, c) {
        var d = c.flags;
        switch (c.tag) {
        case 0:
        case 11:
        case 15:
            gr(i, c),
            d & 4 && Cs(5, c);
            break;
        case 1:
            if (gr(i, c),
            d & 4)
                if (i = c.stateNode,
                s === null)
                    try {
                        i.componentDidMount()
                    } catch (x) {
                        _e(c, c.return, x)
                    }
                else {
                    var g = to(c.type, s.memoizedProps);
                    s = s.memoizedState;
                    try {
                        i.componentDidUpdate(g, s, i.__reactInternalSnapshotBeforeUpdate)
                    } catch (x) {
                        _e(c, c.return, x)
                    }
                }
            d & 64 && Qy(c),
            d & 512 && Ss(c, c.return);
            break;
        case 3:
            if (gr(i, c),
            d & 64 && (i = c.updateQueue,
            i !== null)) {
                if (s = null,
                c.child !== null)
                    switch (c.child.tag) {
                    case 27:
                    case 5:
                        s = c.child.stateNode;
                        break;
                    case 1:
                        s = c.child.stateNode
                    }
                try {
                    q0(i, s)
                } catch (x) {
                    _e(c, c.return, x)
                }
            }
            break;
        case 27:
            s === null && d & 4 && r2(c);
        case 26:
        case 5:
            gr(i, c),
            s === null && d & 4 && t2(c),
            d & 512 && Ss(c, c.return);
            break;
        case 12:
            gr(i, c);
            break;
        case 31:
            gr(i, c),
            d & 4 && a2(i, c);
            break;
        case 13:
            gr(i, c),
            d & 4 && c2(i, c),
            d & 64 && (i = c.memoizedState,
            i !== null && (i = i.dehydrated,
            i !== null && (c = o9.bind(null, c),
            T9(i, c))));
            break;
        case 22:
            if (d = c.memoizedState !== null || pr,
            !d) {
                s = s !== null && s.memoizedState !== null || ut,
                g = pr;
                var v = ut;
                pr = d,
                (ut = s) && !v ? yr(i, c, (c.subtreeFlags & 8772) !== 0) : gr(i, c),
                pr = g,
                ut = v
            }
            break;
        case 30:
            break;
        default:
            gr(i, c)
        }
    }
    function l2(i) {
        var s = i.alternate;
        s !== null && (i.alternate = null,
        l2(s)),
        i.child = null,
        i.deletions = null,
        i.sibling = null,
        i.tag === 5 && (s = i.stateNode,
        s !== null && ad(s)),
        i.stateNode = null,
        i.return = null,
        i.dependencies = null,
        i.memoizedProps = null,
        i.memoizedState = null,
        i.pendingProps = null,
        i.stateNode = null,
        i.updateQueue = null
    }
    var Ze = null
      , qt = !1;
    function mr(i, s, c) {
        for (c = c.child; c !== null; )
            s2(i, s, c),
            c = c.sibling
    }
    function s2(i, s, c) {
        if (Qt && typeof Qt.onCommitFiberUnmount == "function")
            try {
                Qt.onCommitFiberUnmount($l, c)
            } catch {}
        switch (c.tag) {
        case 26:
            ut || Vn(c, s),
            mr(i, s, c),
            c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode,
            c.parentNode.removeChild(c));
            break;
        case 27:
            ut || Vn(c, s);
            var d = Ze
              , g = qt;
            ni(c.type) && (Ze = c.stateNode,
            qt = !1),
            mr(i, s, c),
            Rs(c.stateNode),
            Ze = d,
            qt = g;
            break;
        case 5:
            ut || Vn(c, s);
        case 6:
            if (d = Ze,
            g = qt,
            Ze = null,
            mr(i, s, c),
            Ze = d,
            qt = g,
            Ze !== null)
                if (qt)
                    try {
                        (Ze.nodeType === 9 ? Ze.body : Ze.nodeName === "HTML" ? Ze.ownerDocument.body : Ze).removeChild(c.stateNode)
                    } catch (v) {
                        _e(c, s, v)
                    }
                else
                    try {
                        Ze.removeChild(c.stateNode)
                    } catch (v) {
                        _e(c, s, v)
                    }
            break;
        case 18:
            Ze !== null && (qt ? (i = Ze,
            Q2(i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i, c.stateNode),
            ml(i)) : Q2(Ze, c.stateNode));
            break;
        case 4:
            d = Ze,
            g = qt,
            Ze = c.stateNode.containerInfo,
            qt = !0,
            mr(i, s, c),
            Ze = d,
            qt = g;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            Zr(2, c, s),
            ut || Zr(4, c, s),
            mr(i, s, c);
            break;
        case 1:
            ut || (Vn(c, s),
            d = c.stateNode,
            typeof d.componentWillUnmount == "function" && e2(c, s, d)),
            mr(i, s, c);
            break;
        case 21:
            mr(i, s, c);
            break;
        case 22:
            ut = (d = ut) || c.memoizedState !== null,
            mr(i, s, c),
            ut = d;
            break;
        default:
            mr(i, s, c)
        }
    }
    function a2(i, s) {
        if (s.memoizedState === null && (i = s.alternate,
        i !== null && (i = i.memoizedState,
        i !== null))) {
            i = i.dehydrated;
            try {
                ml(i)
            } catch (c) {
                _e(s, s.return, c)
            }
        }
    }
    function c2(i, s) {
        if (s.memoizedState === null && (i = s.alternate,
        i !== null && (i = i.memoizedState,
        i !== null && (i = i.dehydrated,
        i !== null))))
            try {
                ml(i)
            } catch (c) {
                _e(s, s.return, c)
            }
    }
    function Xw(i) {
        switch (i.tag) {
        case 31:
        case 13:
        case 19:
            var s = i.stateNode;
            return s === null && (s = i.stateNode = new i2),
            s;
        case 22:
            return i = i.stateNode,
            s = i._retryCache,
            s === null && (s = i._retryCache = new i2),
            s;
        default:
            throw Error(r(435, i.tag))
        }
    }
    function Cc(i, s) {
        var c = Xw(i);
        s.forEach(function(d) {
            if (!c.has(d)) {
                c.add(d);
                var g = l9.bind(null, i, d);
                d.then(g, g)
            }
        })
    }
    function $t(i, s) {
        var c = s.deletions;
        if (c !== null)
            for (var d = 0; d < c.length; d++) {
                var g = c[d]
                  , v = i
                  , x = s
                  , M = x;
                e: for (; M !== null; ) {
                    switch (M.tag) {
                    case 27:
                        if (ni(M.type)) {
                            Ze = M.stateNode,
                            qt = !1;
                            break e
                        }
                        break;
                    case 5:
                        Ze = M.stateNode,
                        qt = !1;
                        break e;
                    case 3:
                    case 4:
                        Ze = M.stateNode.containerInfo,
                        qt = !0;
                        break e
                    }
                    M = M.return
                }
                if (Ze === null)
                    throw Error(r(160));
                s2(v, x, g),
                Ze = null,
                qt = !1,
                v = g.alternate,
                v !== null && (v.return = null),
                g.return = null
            }
        if (s.subtreeFlags & 13886)
            for (s = s.child; s !== null; )
                u2(s, i),
                s = s.sibling
    }
    var Dn = null;
    function u2(i, s) {
        var c = i.alternate
          , d = i.flags;
        switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            $t(s, i),
            Ft(i),
            d & 4 && (Zr(3, i, i.return),
            Cs(3, i),
            Zr(5, i, i.return));
            break;
        case 1:
            $t(s, i),
            Ft(i),
            d & 512 && (ut || c === null || Vn(c, c.return)),
            d & 64 && pr && (i = i.updateQueue,
            i !== null && (d = i.callbacks,
            d !== null && (c = i.shared.hiddenCallbacks,
            i.shared.hiddenCallbacks = c === null ? d : c.concat(d))));
            break;
        case 26:
            var g = Dn;
            if ($t(s, i),
            Ft(i),
            d & 512 && (ut || c === null || Vn(c, c.return)),
            d & 4) {
                var v = c !== null ? c.memoizedState : null;
                if (d = i.memoizedState,
                c === null)
                    if (d === null)
                        if (i.stateNode === null) {
                            e: {
                                d = i.type,
                                c = i.memoizedProps,
                                g = g.ownerDocument || g;
                                t: switch (d) {
                                case "title":
                                    v = g.getElementsByTagName("title")[0],
                                    (!v || v[Gl] || v[Ct] || v.namespaceURI === "http://www.w3.org/2000/svg" || v.hasAttribute("itemprop")) && (v = g.createElement(d),
                                    g.head.insertBefore(v, g.querySelector("head > title"))),
                                    Et(v, d, c),
                                    v[Ct] = i,
                                    pt(v),
                                    d = v;
                                    break e;
                                case "link":
                                    var x = uv("link", "href", g).get(d + (c.href || ""));
                                    if (x) {
                                        for (var M = 0; M < x.length; M++)
                                            if (v = x[M],
                                            v.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && v.getAttribute("rel") === (c.rel == null ? null : c.rel) && v.getAttribute("title") === (c.title == null ? null : c.title) && v.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                                                x.splice(M, 1);
                                                break t
                                            }
                                    }
                                    v = g.createElement(d),
                                    Et(v, d, c),
                                    g.head.appendChild(v);
                                    break;
                                case "meta":
                                    if (x = uv("meta", "content", g).get(d + (c.content || ""))) {
                                        for (M = 0; M < x.length; M++)
                                            if (v = x[M],
                                            v.getAttribute("content") === (c.content == null ? null : "" + c.content) && v.getAttribute("name") === (c.name == null ? null : c.name) && v.getAttribute("property") === (c.property == null ? null : c.property) && v.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && v.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                                                x.splice(M, 1);
                                                break t
                                            }
                                    }
                                    v = g.createElement(d),
                                    Et(v, d, c),
                                    g.head.appendChild(v);
                                    break;
                                default:
                                    throw Error(r(468, d))
                                }
                                v[Ct] = i,
                                pt(v),
                                d = v
                            }
                            i.stateNode = d
                        } else
                            fv(g, i.type, i.stateNode);
                    else
                        i.stateNode = cv(g, d, i.memoizedProps);
                else
                    v !== d ? (v === null ? c.stateNode !== null && (c = c.stateNode,
                    c.parentNode.removeChild(c)) : v.count--,
                    d === null ? fv(g, i.type, i.stateNode) : cv(g, d, i.memoizedProps)) : d === null && i.stateNode !== null && Nh(i, i.memoizedProps, c.memoizedProps)
            }
            break;
        case 27:
            $t(s, i),
            Ft(i),
            d & 512 && (ut || c === null || Vn(c, c.return)),
            c !== null && d & 4 && Nh(i, i.memoizedProps, c.memoizedProps);
            break;
        case 5:
            if ($t(s, i),
            Ft(i),
            d & 512 && (ut || c === null || Vn(c, c.return)),
            i.flags & 32) {
                g = i.stateNode;
                try {
                    Ho(g, "")
                } catch (oe) {
                    _e(i, i.return, oe)
                }
            }
            d & 4 && i.stateNode != null && (g = i.memoizedProps,
            Nh(i, g, c !== null ? c.memoizedProps : g)),
            d & 1024 && (Dh = !0);
            break;
        case 6:
            if ($t(s, i),
            Ft(i),
            d & 4) {
                if (i.stateNode === null)
                    throw Error(r(162));
                d = i.memoizedProps,
                c = i.stateNode;
                try {
                    c.nodeValue = d
                } catch (oe) {
                    _e(i, i.return, oe)
                }
            }
            break;
        case 3:
            if (Bc = null,
            g = Dn,
            Dn = zc(s.containerInfo),
            $t(s, i),
            Dn = g,
            Ft(i),
            d & 4 && c !== null && c.memoizedState.isDehydrated)
                try {
                    ml(s.containerInfo)
                } catch (oe) {
                    _e(i, i.return, oe)
                }
            Dh && (Dh = !1,
            f2(i));
            break;
        case 4:
            d = Dn,
            Dn = zc(i.stateNode.containerInfo),
            $t(s, i),
            Ft(i),
            Dn = d;
            break;
        case 12:
            $t(s, i),
            Ft(i);
            break;
        case 31:
            $t(s, i),
            Ft(i),
            d & 4 && (d = i.updateQueue,
            d !== null && (i.updateQueue = null,
            Cc(i, d)));
            break;
        case 13:
            $t(s, i),
            Ft(i),
            i.child.flags & 8192 && i.memoizedState !== null != (c !== null && c.memoizedState !== null) && (xc = Jt()),
            d & 4 && (d = i.updateQueue,
            d !== null && (i.updateQueue = null,
            Cc(i, d)));
            break;
        case 22:
            g = i.memoizedState !== null;
            var N = c !== null && c.memoizedState !== null
              , I = pr
              , K = ut;
            if (pr = I || g,
            ut = K || N,
            $t(s, i),
            ut = K,
            pr = I,
            Ft(i),
            d & 8192)
                e: for (s = i.stateNode,
                s._visibility = g ? s._visibility & -2 : s._visibility | 1,
                g && (c === null || N || pr || ut || no(i)),
                c = null,
                s = i; ; ) {
                    if (s.tag === 5 || s.tag === 26) {
                        if (c === null) {
                            N = c = s;
                            try {
                                if (v = N.stateNode,
                                g)
                                    x = v.style,
                                    typeof x.setProperty == "function" ? x.setProperty("display", "none", "important") : x.display = "none";
                                else {
                                    M = N.stateNode;
                                    var Y = N.memoizedProps.style
                                      , V = Y != null && Y.hasOwnProperty("display") ? Y.display : null;
                                    M.style.display = V == null || typeof V == "boolean" ? "" : ("" + V).trim()
                                }
                            } catch (oe) {
                                _e(N, N.return, oe)
                            }
                        }
                    } else if (s.tag === 6) {
                        if (c === null) {
                            N = s;
                            try {
                                N.stateNode.nodeValue = g ? "" : N.memoizedProps
                            } catch (oe) {
                                _e(N, N.return, oe)
                            }
                        }
                    } else if (s.tag === 18) {
                        if (c === null) {
                            N = s;
                            try {
                                var F = N.stateNode;
                                g ? ev(F, !0) : ev(N.stateNode, !1)
                            } catch (oe) {
                                _e(N, N.return, oe)
                            }
                        }
                    } else if ((s.tag !== 22 && s.tag !== 23 || s.memoizedState === null || s === i) && s.child !== null) {
                        s.child.return = s,
                        s = s.child;
                        continue
                    }
                    if (s === i)
                        break e;
                    for (; s.sibling === null; ) {
                        if (s.return === null || s.return === i)
                            break e;
                        c === s && (c = null),
                        s = s.return
                    }
                    c === s && (c = null),
                    s.sibling.return = s.return,
                    s = s.sibling
                }
            d & 4 && (d = i.updateQueue,
            d !== null && (c = d.retryQueue,
            c !== null && (d.retryQueue = null,
            Cc(i, c))));
            break;
        case 19:
            $t(s, i),
            Ft(i),
            d & 4 && (d = i.updateQueue,
            d !== null && (i.updateQueue = null,
            Cc(i, d)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            $t(s, i),
            Ft(i)
        }
    }
    function Ft(i) {
        var s = i.flags;
        if (s & 2) {
            try {
                for (var c, d = i.return; d !== null; ) {
                    if (n2(d)) {
                        c = d;
                        break
                    }
                    d = d.return
                }
                if (c == null)
                    throw Error(r(160));
                switch (c.tag) {
                case 27:
                    var g = c.stateNode
                      , v = Rh(i);
                    bc(i, v, g);
                    break;
                case 5:
                    var x = c.stateNode;
                    c.flags & 32 && (Ho(x, ""),
                    c.flags &= -33);
                    var M = Rh(i);
                    bc(i, M, x);
                    break;
                case 3:
                case 4:
                    var N = c.stateNode.containerInfo
                      , I = Rh(i);
                    Oh(i, I, N);
                    break;
                default:
                    throw Error(r(161))
                }
            } catch (K) {
                _e(i, i.return, K)
            }
            i.flags &= -3
        }
        s & 4096 && (i.flags &= -4097)
    }
    function f2(i) {
        if (i.subtreeFlags & 1024)
            for (i = i.child; i !== null; ) {
                var s = i;
                f2(s),
                s.tag === 5 && s.flags & 1024 && s.stateNode.reset(),
                i = i.sibling
            }
    }
    function gr(i, s) {
        if (s.subtreeFlags & 8772)
            for (s = s.child; s !== null; )
                o2(i, s.alternate, s),
                s = s.sibling
    }
    function no(i) {
        for (i = i.child; i !== null; ) {
            var s = i;
            switch (s.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Zr(4, s, s.return),
                no(s);
                break;
            case 1:
                Vn(s, s.return);
                var c = s.stateNode;
                typeof c.componentWillUnmount == "function" && e2(s, s.return, c),
                no(s);
                break;
            case 27:
                Rs(s.stateNode);
            case 26:
            case 5:
                Vn(s, s.return),
                no(s);
                break;
            case 22:
                s.memoizedState === null && no(s);
                break;
            case 30:
                no(s);
                break;
            default:
                no(s)
            }
            i = i.sibling
        }
    }
    function yr(i, s, c) {
        for (c = c && (s.subtreeFlags & 8772) !== 0,
        s = s.child; s !== null; ) {
            var d = s.alternate
              , g = i
              , v = s
              , x = v.flags;
            switch (v.tag) {
            case 0:
            case 11:
            case 15:
                yr(g, v, c),
                Cs(4, v);
                break;
            case 1:
                if (yr(g, v, c),
                d = v,
                g = d.stateNode,
                typeof g.componentDidMount == "function")
                    try {
                        g.componentDidMount()
                    } catch (I) {
                        _e(d, d.return, I)
                    }
                if (d = v,
                g = d.updateQueue,
                g !== null) {
                    var M = d.stateNode;
                    try {
                        var N = g.shared.hiddenCallbacks;
                        if (N !== null)
                            for (g.shared.hiddenCallbacks = null,
                            g = 0; g < N.length; g++)
                                P0(N[g], M)
                    } catch (I) {
                        _e(d, d.return, I)
                    }
                }
                c && x & 64 && Qy(v),
                Ss(v, v.return);
                break;
            case 27:
                r2(v);
            case 26:
            case 5:
                yr(g, v, c),
                c && d === null && x & 4 && t2(v),
                Ss(v, v.return);
                break;
            case 12:
                yr(g, v, c);
                break;
            case 31:
                yr(g, v, c),
                c && x & 4 && a2(g, v);
                break;
            case 13:
                yr(g, v, c),
                c && x & 4 && c2(g, v);
                break;
            case 22:
                v.memoizedState === null && yr(g, v, c),
                Ss(v, v.return);
                break;
            case 30:
                break;
            default:
                yr(g, v, c)
            }
            s = s.sibling
        }
    }
    function Lh(i, s) {
        var c = null;
        i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (c = i.memoizedState.cachePool.pool),
        i = null,
        s.memoizedState !== null && s.memoizedState.cachePool !== null && (i = s.memoizedState.cachePool.pool),
        i !== c && (i != null && i.refCount++,
        c != null && ss(c))
    }
    function zh(i, s) {
        i = null,
        s.alternate !== null && (i = s.alternate.memoizedState.cache),
        s = s.memoizedState.cache,
        s !== i && (s.refCount++,
        i != null && ss(i))
    }
    function Ln(i, s, c, d) {
        if (s.subtreeFlags & 10256)
            for (s = s.child; s !== null; )
                d2(i, s, c, d),
                s = s.sibling
    }
    function d2(i, s, c, d) {
        var g = s.flags;
        switch (s.tag) {
        case 0:
        case 11:
        case 15:
            Ln(i, s, c, d),
            g & 2048 && Cs(9, s);
            break;
        case 1:
            Ln(i, s, c, d);
            break;
        case 3:
            Ln(i, s, c, d),
            g & 2048 && (i = null,
            s.alternate !== null && (i = s.alternate.memoizedState.cache),
            s = s.memoizedState.cache,
            s !== i && (s.refCount++,
            i != null && ss(i)));
            break;
        case 12:
            if (g & 2048) {
                Ln(i, s, c, d),
                i = s.stateNode;
                try {
                    var v = s.memoizedProps
                      , x = v.id
                      , M = v.onPostCommit;
                    typeof M == "function" && M(x, s.alternate === null ? "mount" : "update", i.passiveEffectDuration, -0)
                } catch (N) {
                    _e(s, s.return, N)
                }
            } else
                Ln(i, s, c, d);
            break;
        case 31:
            Ln(i, s, c, d);
            break;
        case 13:
            Ln(i, s, c, d);
            break;
        case 23:
            break;
        case 22:
            v = s.stateNode,
            x = s.alternate,
            s.memoizedState !== null ? v._visibility & 2 ? Ln(i, s, c, d) : xs(i, s) : v._visibility & 2 ? Ln(i, s, c, d) : (v._visibility |= 2,
            il(i, s, c, d, (s.subtreeFlags & 10256) !== 0 || !1)),
            g & 2048 && Lh(x, s);
            break;
        case 24:
            Ln(i, s, c, d),
            g & 2048 && zh(s.alternate, s);
            break;
        default:
            Ln(i, s, c, d)
        }
    }
    function il(i, s, c, d, g) {
        for (g = g && ((s.subtreeFlags & 10256) !== 0 || !1),
        s = s.child; s !== null; ) {
            var v = i
              , x = s
              , M = c
              , N = d
              , I = x.flags;
            switch (x.tag) {
            case 0:
            case 11:
            case 15:
                il(v, x, M, N, g),
                Cs(8, x);
                break;
            case 23:
                break;
            case 22:
                var K = x.stateNode;
                x.memoizedState !== null ? K._visibility & 2 ? il(v, x, M, N, g) : xs(v, x) : (K._visibility |= 2,
                il(v, x, M, N, g)),
                g && I & 2048 && Lh(x.alternate, x);
                break;
            case 24:
                il(v, x, M, N, g),
                g && I & 2048 && zh(x.alternate, x);
                break;
            default:
                il(v, x, M, N, g)
            }
            s = s.sibling
        }
    }
    function xs(i, s) {
        if (s.subtreeFlags & 10256)
            for (s = s.child; s !== null; ) {
                var c = i
                  , d = s
                  , g = d.flags;
                switch (d.tag) {
                case 22:
                    xs(c, d),
                    g & 2048 && Lh(d.alternate, d);
                    break;
                case 24:
                    xs(c, d),
                    g & 2048 && zh(d.alternate, d);
                    break;
                default:
                    xs(c, d)
                }
                s = s.sibling
            }
    }
    var ws = 8192;
    function ol(i, s, c) {
        if (i.subtreeFlags & ws)
            for (i = i.child; i !== null; )
                h2(i, s, c),
                i = i.sibling
    }
    function h2(i, s, c) {
        switch (i.tag) {
        case 26:
            ol(i, s, c),
            i.flags & ws && i.memoizedState !== null && j9(c, Dn, i.memoizedState, i.memoizedProps);
            break;
        case 5:
            ol(i, s, c);
            break;
        case 3:
        case 4:
            var d = Dn;
            Dn = zc(i.stateNode.containerInfo),
            ol(i, s, c),
            Dn = d;
            break;
        case 22:
            i.memoizedState === null && (d = i.alternate,
            d !== null && d.memoizedState !== null ? (d = ws,
            ws = 16777216,
            ol(i, s, c),
            ws = d) : ol(i, s, c));
            break;
        default:
            ol(i, s, c)
        }
    }
    function p2(i) {
        var s = i.alternate;
        if (s !== null && (i = s.child,
        i !== null)) {
            s.child = null;
            do
                s = i.sibling,
                i.sibling = null,
                i = s;
            while (i !== null)
        }
    }
    function Es(i) {
        var s = i.deletions;
        if ((i.flags & 16) !== 0) {
            if (s !== null)
                for (var c = 0; c < s.length; c++) {
                    var d = s[c];
                    mt = d,
                    g2(d, i)
                }
            p2(i)
        }
        if (i.subtreeFlags & 10256)
            for (i = i.child; i !== null; )
                m2(i),
                i = i.sibling
    }
    function m2(i) {
        switch (i.tag) {
        case 0:
        case 11:
        case 15:
            Es(i),
            i.flags & 2048 && Zr(9, i, i.return);
            break;
        case 3:
            Es(i);
            break;
        case 12:
            Es(i);
            break;
        case 22:
            var s = i.stateNode;
            i.memoizedState !== null && s._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (s._visibility &= -3,
            Sc(i)) : Es(i);
            break;
        default:
            Es(i)
        }
    }
    function Sc(i) {
        var s = i.deletions;
        if ((i.flags & 16) !== 0) {
            if (s !== null)
                for (var c = 0; c < s.length; c++) {
                    var d = s[c];
                    mt = d,
                    g2(d, i)
                }
            p2(i)
        }
        for (i = i.child; i !== null; ) {
            switch (s = i,
            s.tag) {
            case 0:
            case 11:
            case 15:
                Zr(8, s, s.return),
                Sc(s);
                break;
            case 22:
                c = s.stateNode,
                c._visibility & 2 && (c._visibility &= -3,
                Sc(s));
                break;
            default:
                Sc(s)
            }
            i = i.sibling
        }
    }
    function g2(i, s) {
        for (; mt !== null; ) {
            var c = mt;
            switch (c.tag) {
            case 0:
            case 11:
            case 15:
                Zr(8, c, s);
                break;
            case 23:
            case 22:
                if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
                    var d = c.memoizedState.cachePool.pool;
                    d != null && d.refCount++
                }
                break;
            case 24:
                ss(c.memoizedState.cache)
            }
            if (d = c.child,
            d !== null)
                d.return = c,
                mt = d;
            else
                e: for (c = i; mt !== null; ) {
                    d = mt;
                    var g = d.sibling
                      , v = d.return;
                    if (l2(d),
                    d === c) {
                        mt = null;
                        break e
                    }
                    if (g !== null) {
                        g.return = v,
                        mt = g;
                        break e
                    }
                    mt = v
                }
        }
    }
    var Jw = {
        getCacheForType: function(i) {
            var s = xt(st)
              , c = s.data.get(i);
            return c === void 0 && (c = i(),
            s.data.set(i, c)),
            c
        },
        cacheSignal: function() {
            return xt(st).controller.signal
        }
    }
      , Qw = typeof WeakMap == "function" ? WeakMap : Map
      , De = 0
      , Ie = null
      , Te = null
      , Me = 0
      , ze = 0
      , ln = null
      , Wr = !1
      , ll = !1
      , _h = !1
      , vr = 0
      , Je = 0
      , Xr = 0
      , ro = 0
      , Bh = 0
      , sn = 0
      , sl = 0
      , Ts = null
      , Kt = null
      , jh = !1
      , xc = 0
      , y2 = 0
      , wc = 1 / 0
      , Ec = null
      , Jr = null
      , ht = 0
      , Qr = null
      , al = null
      , br = 0
      , Hh = 0
      , Ih = null
      , v2 = null
      , ks = 0
      , Vh = null;
    function an() {
        return (De & 2) !== 0 && Me !== 0 ? Me & -Me : j.T !== null ? Kh() : zg()
    }
    function b2() {
        if (sn === 0)
            if ((Me & 536870912) === 0 || Ne) {
                var i = Da;
                Da <<= 1,
                (Da & 3932160) === 0 && (Da = 262144),
                sn = i
            } else
                sn = 536870912;
        return i = rn.current,
        i !== null && (i.flags |= 32),
        sn
    }
    function Gt(i, s, c) {
        (i === Ie && (ze === 2 || ze === 9) || i.cancelPendingCommit !== null) && (cl(i, 0),
        ei(i, Me, sn, !1)),
        Kl(i, c),
        ((De & 2) === 0 || i !== Ie) && (i === Ie && ((De & 2) === 0 && (ro |= c),
        Je === 4 && ei(i, Me, sn, !1)),
        Un(i))
    }
    function C2(i, s, c) {
        if ((De & 6) !== 0)
            throw Error(r(327));
        var d = !c && (s & 127) === 0 && (s & i.expiredLanes) === 0 || Fl(i, s)
          , g = d ? n9(i, s) : Ph(i, s, !0)
          , v = d;
        do {
            if (g === 0) {
                ll && !d && ei(i, s, 0, !1);
                break
            } else {
                if (c = i.current.alternate,
                v && !e9(c)) {
                    g = Ph(i, s, !1),
                    v = !1;
                    continue
                }
                if (g === 2) {
                    if (v = s,
                    i.errorRecoveryDisabledLanes & v)
                        var x = 0;
                    else
                        x = i.pendingLanes & -536870913,
                        x = x !== 0 ? x : x & 536870912 ? 536870912 : 0;
                    if (x !== 0) {
                        s = x;
                        e: {
                            var M = i;
                            g = Ts;
                            var N = M.current.memoizedState.isDehydrated;
                            if (N && (cl(M, x).flags |= 256),
                            x = Ph(M, x, !1),
                            x !== 2) {
                                if (_h && !N) {
                                    M.errorRecoveryDisabledLanes |= v,
                                    ro |= v,
                                    g = 4;
                                    break e
                                }
                                v = Kt,
                                Kt = g,
                                v !== null && (Kt === null ? Kt = v : Kt.push.apply(Kt, v))
                            }
                            g = x
                        }
                        if (v = !1,
                        g !== 2)
                            continue
                    }
                }
                if (g === 1) {
                    cl(i, 0),
                    ei(i, s, 0, !0);
                    break
                }
                e: {
                    switch (d = i,
                    v = g,
                    v) {
                    case 0:
                    case 1:
                        throw Error(r(345));
                    case 4:
                        if ((s & 4194048) !== s)
                            break;
                    case 6:
                        ei(d, s, sn, !Wr);
                        break e;
                    case 2:
                        Kt = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(r(329))
                    }
                    if ((s & 62914560) === s && (g = xc + 300 - Jt(),
                    10 < g)) {
                        if (ei(d, s, sn, !Wr),
                        za(d, 0, !0) !== 0)
                            break e;
                        br = s,
                        d.timeoutHandle = X2(S2.bind(null, d, c, Kt, Ec, jh, s, sn, ro, sl, Wr, v, "Throttled", -0, 0), g);
                        break e
                    }
                    S2(d, c, Kt, Ec, jh, s, sn, ro, sl, Wr, v, null, -0, 0)
                }
            }
            break
        } while (!0);
        Un(i)
    }
    function S2(i, s, c, d, g, v, x, M, N, I, K, Y, V, F) {
        if (i.timeoutHandle = -1,
        Y = s.subtreeFlags,
        Y & 8192 || (Y & 16785408) === 16785408) {
            Y = {
                stylesheets: null,
                count: 0,
                imgCount: 0,
                imgBytes: 0,
                suspenseyImages: [],
                waitingForImages: !0,
                waitingForViewTransition: !1,
                unsuspend: ir
            },
            h2(s, v, Y);
            var oe = (v & 62914560) === v ? xc - Jt() : (v & 4194048) === v ? y2 - Jt() : 0;
            if (oe = H9(Y, oe),
            oe !== null) {
                br = v,
                i.cancelPendingCommit = oe(N2.bind(null, i, s, v, c, d, g, x, M, N, K, Y, null, V, F)),
                ei(i, v, x, !I);
                return
            }
        }
        N2(i, s, v, c, d, g, x, M, N)
    }
    function e9(i) {
        for (var s = i; ; ) {
            var c = s.tag;
            if ((c === 0 || c === 11 || c === 15) && s.flags & 16384 && (c = s.updateQueue,
            c !== null && (c = c.stores,
            c !== null)))
                for (var d = 0; d < c.length; d++) {
                    var g = c[d]
                      , v = g.getSnapshot;
                    g = g.value;
                    try {
                        if (!tn(v(), g))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (c = s.child,
            s.subtreeFlags & 16384 && c !== null)
                c.return = s,
                s = c;
            else {
                if (s === i)
                    break;
                for (; s.sibling === null; ) {
                    if (s.return === null || s.return === i)
                        return !0;
                    s = s.return
                }
                s.sibling.return = s.return,
                s = s.sibling
            }
        }
        return !0
    }
    function ei(i, s, c, d) {
        s &= ~Bh,
        s &= ~ro,
        i.suspendedLanes |= s,
        i.pingedLanes &= ~s,
        d && (i.warmLanes |= s),
        d = i.expirationTimes;
        for (var g = s; 0 < g; ) {
            var v = 31 - en(g)
              , x = 1 << v;
            d[v] = -1,
            g &= ~x
        }
        c !== 0 && Og(i, c, s)
    }
    function Tc() {
        return (De & 6) === 0 ? (Ms(0),
        !1) : !0
    }
    function Uh() {
        if (Te !== null) {
            if (ze === 0)
                var i = Te.return;
            else
                i = Te,
                ar = Yi = null,
                rh(i),
                Qo = null,
                cs = 0,
                i = Te;
            for (; i !== null; )
                Jy(i.alternate, i),
                i = i.return;
            Te = null
        }
    }
    function cl(i, s) {
        var c = i.timeoutHandle;
        c !== -1 && (i.timeoutHandle = -1,
        C9(c)),
        c = i.cancelPendingCommit,
        c !== null && (i.cancelPendingCommit = null,
        c()),
        br = 0,
        Uh(),
        Ie = i,
        Te = c = lr(i.current, null),
        Me = s,
        ze = 0,
        ln = null,
        Wr = !1,
        ll = Fl(i, s),
        _h = !1,
        sl = sn = Bh = ro = Xr = Je = 0,
        Kt = Ts = null,
        jh = !1,
        (s & 8) !== 0 && (s |= s & 32);
        var d = i.entangledLanes;
        if (d !== 0)
            for (i = i.entanglements,
            d &= s; 0 < d; ) {
                var g = 31 - en(d)
                  , v = 1 << g;
                s |= i[g],
                d &= ~v
            }
        return vr = s,
        Ka(),
        c
    }
    function x2(i, s) {
        xe = null,
        j.H = ys,
        s === Jo || s === ec ? (s = H0(),
        ze = 3) : s === Fd ? (s = H0(),
        ze = 4) : ze = s === bh ? 8 : s !== null && typeof s == "object" && typeof s.then == "function" ? 6 : 1,
        ln = s,
        Te === null && (Je = 1,
        pc(i, gn(s, i.current)))
    }
    function w2() {
        var i = rn.current;
        return i === null ? !0 : (Me & 4194048) === Me ? Cn === null : (Me & 62914560) === Me || (Me & 536870912) !== 0 ? i === Cn : !1
    }
    function E2() {
        var i = j.H;
        return j.H = ys,
        i === null ? ys : i
    }
    function T2() {
        var i = j.A;
        return j.A = Jw,
        i
    }
    function kc() {
        Je = 4,
        Wr || (Me & 4194048) !== Me && rn.current !== null || (ll = !0),
        (Xr & 134217727) === 0 && (ro & 134217727) === 0 || Ie === null || ei(Ie, Me, sn, !1)
    }
    function Ph(i, s, c) {
        var d = De;
        De |= 2;
        var g = E2()
          , v = T2();
        (Ie !== i || Me !== s) && (Ec = null,
        cl(i, s)),
        s = !1;
        var x = Je;
        e: do
            try {
                if (ze !== 0 && Te !== null) {
                    var M = Te
                      , N = ln;
                    switch (ze) {
                    case 8:
                        Uh(),
                        x = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        rn.current === null && (s = !0);
                        var I = ze;
                        if (ze = 0,
                        ln = null,
                        ul(i, M, N, I),
                        c && ll) {
                            x = 0;
                            break e
                        }
                        break;
                    default:
                        I = ze,
                        ze = 0,
                        ln = null,
                        ul(i, M, N, I)
                    }
                }
                t9(),
                x = Je;
                break
            } catch (K) {
                x2(i, K)
            }
        while (!0);
        return s && i.shellSuspendCounter++,
        ar = Yi = null,
        De = d,
        j.H = g,
        j.A = v,
        Te === null && (Ie = null,
        Me = 0,
        Ka()),
        x
    }
    function t9() {
        for (; Te !== null; )
            k2(Te)
    }
    function n9(i, s) {
        var c = De;
        De |= 2;
        var d = E2()
          , g = T2();
        Ie !== i || Me !== s ? (Ec = null,
        wc = Jt() + 500,
        cl(i, s)) : ll = Fl(i, s);
        e: do
            try {
                if (ze !== 0 && Te !== null) {
                    s = Te;
                    var v = ln;
                    t: switch (ze) {
                    case 1:
                        ze = 0,
                        ln = null,
                        ul(i, s, v, 1);
                        break;
                    case 2:
                    case 9:
                        if (B0(v)) {
                            ze = 0,
                            ln = null,
                            M2(s);
                            break
                        }
                        s = function() {
                            ze !== 2 && ze !== 9 || Ie !== i || (ze = 7),
                            Un(i)
                        }
                        ,
                        v.then(s, s);
                        break e;
                    case 3:
                        ze = 7;
                        break e;
                    case 4:
                        ze = 5;
                        break e;
                    case 7:
                        B0(v) ? (ze = 0,
                        ln = null,
                        M2(s)) : (ze = 0,
                        ln = null,
                        ul(i, s, v, 7));
                        break;
                    case 5:
                        var x = null;
                        switch (Te.tag) {
                        case 26:
                            x = Te.memoizedState;
                        case 5:
                        case 27:
                            var M = Te;
                            if (x ? dv(x) : M.stateNode.complete) {
                                ze = 0,
                                ln = null;
                                var N = M.sibling;
                                if (N !== null)
                                    Te = N;
                                else {
                                    var I = M.return;
                                    I !== null ? (Te = I,
                                    Mc(I)) : Te = null
                                }
                                break t
                            }
                        }
                        ze = 0,
                        ln = null,
                        ul(i, s, v, 5);
                        break;
                    case 6:
                        ze = 0,
                        ln = null,
                        ul(i, s, v, 6);
                        break;
                    case 8:
                        Uh(),
                        Je = 6;
                        break e;
                    default:
                        throw Error(r(462))
                    }
                }
                r9();
                break
            } catch (K) {
                x2(i, K)
            }
        while (!0);
        return ar = Yi = null,
        j.H = d,
        j.A = g,
        De = c,
        Te !== null ? 0 : (Ie = null,
        Me = 0,
        Ka(),
        Je)
    }
    function r9() {
        for (; Te !== null && !k7(); )
            k2(Te)
    }
    function k2(i) {
        var s = Wy(i.alternate, i, vr);
        i.memoizedProps = i.pendingProps,
        s === null ? Mc(i) : Te = s
    }
    function M2(i) {
        var s = i
          , c = s.alternate;
        switch (s.tag) {
        case 15:
        case 0:
            s = $y(c, s, s.pendingProps, s.type, void 0, Me);
            break;
        case 11:
            s = $y(c, s, s.pendingProps, s.type.render, s.ref, Me);
            break;
        case 5:
            rh(s);
        default:
            Jy(c, s),
            s = Te = T0(s, vr),
            s = Wy(c, s, vr)
        }
        i.memoizedProps = i.pendingProps,
        s === null ? Mc(i) : Te = s
    }
    function ul(i, s, c, d) {
        ar = Yi = null,
        rh(s),
        Qo = null,
        cs = 0;
        var g = s.return;
        try {
            if (Fw(i, g, s, c, Me)) {
                Je = 1,
                pc(i, gn(c, i.current)),
                Te = null;
                return
            }
        } catch (v) {
            if (g !== null)
                throw Te = g,
                v;
            Je = 1,
            pc(i, gn(c, i.current)),
            Te = null;
            return
        }
        s.flags & 32768 ? (Ne || d === 1 ? i = !0 : ll || (Me & 536870912) !== 0 ? i = !1 : (Wr = i = !0,
        (d === 2 || d === 9 || d === 3 || d === 6) && (d = rn.current,
        d !== null && d.tag === 13 && (d.flags |= 16384))),
        A2(s, i)) : Mc(s)
    }
    function Mc(i) {
        var s = i;
        do {
            if ((s.flags & 32768) !== 0) {
                A2(s, Wr);
                return
            }
            i = s.return;
            var c = Yw(s.alternate, s, vr);
            if (c !== null) {
                Te = c;
                return
            }
            if (s = s.sibling,
            s !== null) {
                Te = s;
                return
            }
            Te = s = i
        } while (s !== null);
        Je === 0 && (Je = 5)
    }
    function A2(i, s) {
        do {
            var c = Zw(i.alternate, i);
            if (c !== null) {
                c.flags &= 32767,
                Te = c;
                return
            }
            if (c = i.return,
            c !== null && (c.flags |= 32768,
            c.subtreeFlags = 0,
            c.deletions = null),
            !s && (i = i.sibling,
            i !== null)) {
                Te = i;
                return
            }
            Te = i = c
        } while (i !== null);
        Je = 6,
        Te = null
    }
    function N2(i, s, c, d, g, v, x, M, N) {
        i.cancelPendingCommit = null;
        do
            Ac();
        while (ht !== 0);
        if ((De & 6) !== 0)
            throw Error(r(327));
        if (s !== null) {
            if (s === i.current)
                throw Error(r(177));
            if (v = s.lanes | s.childLanes,
            v |= Rd,
            B7(i, c, v, x, M, N),
            i === Ie && (Te = Ie = null,
            Me = 0),
            al = s,
            Qr = i,
            br = c,
            Hh = v,
            Ih = g,
            v2 = d,
            (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? (i.callbackNode = null,
            i.callbackPriority = 0,
            s9(Ra, function() {
                return z2(),
                null
            })) : (i.callbackNode = null,
            i.callbackPriority = 0),
            d = (s.flags & 13878) !== 0,
            (s.subtreeFlags & 13878) !== 0 || d) {
                d = j.T,
                j.T = null,
                g = P.p,
                P.p = 2,
                x = De,
                De |= 4;
                try {
                    Ww(i, s, c)
                } finally {
                    De = x,
                    P.p = g,
                    j.T = d
                }
            }
            ht = 1,
            R2(),
            O2(),
            D2()
        }
    }
    function R2() {
        if (ht === 1) {
            ht = 0;
            var i = Qr
              , s = al
              , c = (s.flags & 13878) !== 0;
            if ((s.subtreeFlags & 13878) !== 0 || c) {
                c = j.T,
                j.T = null;
                var d = P.p;
                P.p = 2;
                var g = De;
                De |= 4;
                try {
                    u2(s, i);
                    var v = ep
                      , x = g0(i.containerInfo)
                      , M = v.focusedElem
                      , N = v.selectionRange;
                    if (x !== M && M && M.ownerDocument && m0(M.ownerDocument.documentElement, M)) {
                        if (N !== null && Td(M)) {
                            var I = N.start
                              , K = N.end;
                            if (K === void 0 && (K = I),
                            "selectionStart"in M)
                                M.selectionStart = I,
                                M.selectionEnd = Math.min(K, M.value.length);
                            else {
                                var Y = M.ownerDocument || document
                                  , V = Y && Y.defaultView || window;
                                if (V.getSelection) {
                                    var F = V.getSelection()
                                      , oe = M.textContent.length
                                      , me = Math.min(N.start, oe)
                                      , He = N.end === void 0 ? me : Math.min(N.end, oe);
                                    !F.extend && me > He && (x = He,
                                    He = me,
                                    me = x);
                                    var L = p0(M, me)
                                      , D = p0(M, He);
                                    if (L && D && (F.rangeCount !== 1 || F.anchorNode !== L.node || F.anchorOffset !== L.offset || F.focusNode !== D.node || F.focusOffset !== D.offset)) {
                                        var H = Y.createRange();
                                        H.setStart(L.node, L.offset),
                                        F.removeAllRanges(),
                                        me > He ? (F.addRange(H),
                                        F.extend(D.node, D.offset)) : (H.setEnd(D.node, D.offset),
                                        F.addRange(H))
                                    }
                                }
                            }
                        }
                        for (Y = [],
                        F = M; F = F.parentNode; )
                            F.nodeType === 1 && Y.push({
                                element: F,
                                left: F.scrollLeft,
                                top: F.scrollTop
                            });
                        for (typeof M.focus == "function" && M.focus(),
                        M = 0; M < Y.length; M++) {
                            var G = Y[M];
                            G.element.scrollLeft = G.left,
                            G.element.scrollTop = G.top
                        }
                    }
                    Vc = !!Qh,
                    ep = Qh = null
                } finally {
                    De = g,
                    P.p = d,
                    j.T = c
                }
            }
            i.current = s,
            ht = 2
        }
    }
    function O2() {
        if (ht === 2) {
            ht = 0;
            var i = Qr
              , s = al
              , c = (s.flags & 8772) !== 0;
            if ((s.subtreeFlags & 8772) !== 0 || c) {
                c = j.T,
                j.T = null;
                var d = P.p;
                P.p = 2;
                var g = De;
                De |= 4;
                try {
                    o2(i, s.alternate, s)
                } finally {
                    De = g,
                    P.p = d,
                    j.T = c
                }
            }
            ht = 3
        }
    }
    function D2() {
        if (ht === 4 || ht === 3) {
            ht = 0,
            M7();
            var i = Qr
              , s = al
              , c = br
              , d = v2;
            (s.subtreeFlags & 10256) !== 0 || (s.flags & 10256) !== 0 ? ht = 5 : (ht = 0,
            al = Qr = null,
            L2(i, i.pendingLanes));
            var g = i.pendingLanes;
            if (g === 0 && (Jr = null),
            ld(c),
            s = s.stateNode,
            Qt && typeof Qt.onCommitFiberRoot == "function")
                try {
                    Qt.onCommitFiberRoot($l, s, void 0, (s.current.flags & 128) === 128)
                } catch {}
            if (d !== null) {
                s = j.T,
                g = P.p,
                P.p = 2,
                j.T = null;
                try {
                    for (var v = i.onRecoverableError, x = 0; x < d.length; x++) {
                        var M = d[x];
                        v(M.value, {
                            componentStack: M.stack
                        })
                    }
                } finally {
                    j.T = s,
                    P.p = g
                }
            }
            (br & 3) !== 0 && Ac(),
            Un(i),
            g = i.pendingLanes,
            (c & 261930) !== 0 && (g & 42) !== 0 ? i === Vh ? ks++ : (ks = 0,
            Vh = i) : ks = 0,
            Ms(0)
        }
    }
    function L2(i, s) {
        (i.pooledCacheLanes &= s) === 0 && (s = i.pooledCache,
        s != null && (i.pooledCache = null,
        ss(s)))
    }
    function Ac() {
        return R2(),
        O2(),
        D2(),
        z2()
    }
    function z2() {
        if (ht !== 5)
            return !1;
        var i = Qr
          , s = Hh;
        Hh = 0;
        var c = ld(br)
          , d = j.T
          , g = P.p;
        try {
            P.p = 32 > c ? 32 : c,
            j.T = null,
            c = Ih,
            Ih = null;
            var v = Qr
              , x = br;
            if (ht = 0,
            al = Qr = null,
            br = 0,
            (De & 6) !== 0)
                throw Error(r(331));
            var M = De;
            if (De |= 4,
            m2(v.current),
            d2(v, v.current, x, c),
            De = M,
            Ms(0, !1),
            Qt && typeof Qt.onPostCommitFiberRoot == "function")
                try {
                    Qt.onPostCommitFiberRoot($l, v)
                } catch {}
            return !0
        } finally {
            P.p = g,
            j.T = d,
            L2(i, s)
        }
    }
    function _2(i, s, c) {
        s = gn(c, s),
        s = vh(i.stateNode, s, 2),
        i = Kr(i, s, 2),
        i !== null && (Kl(i, 2),
        Un(i))
    }
    function _e(i, s, c) {
        if (i.tag === 3)
            _2(i, i, c);
        else
            for (; s !== null; ) {
                if (s.tag === 3) {
                    _2(s, i, c);
                    break
                } else if (s.tag === 1) {
                    var d = s.stateNode;
                    if (typeof s.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Jr === null || !Jr.has(d))) {
                        i = gn(c, i),
                        c = By(2),
                        d = Kr(s, c, 2),
                        d !== null && (jy(c, d, s, i),
                        Kl(d, 2),
                        Un(d));
                        break
                    }
                }
                s = s.return
            }
    }
    function qh(i, s, c) {
        var d = i.pingCache;
        if (d === null) {
            d = i.pingCache = new Qw;
            var g = new Set;
            d.set(s, g)
        } else
            g = d.get(s),
            g === void 0 && (g = new Set,
            d.set(s, g));
        g.has(c) || (_h = !0,
        g.add(c),
        i = i9.bind(null, i, s, c),
        s.then(i, i))
    }
    function i9(i, s, c) {
        var d = i.pingCache;
        d !== null && d.delete(s),
        i.pingedLanes |= i.suspendedLanes & c,
        i.warmLanes &= ~c,
        Ie === i && (Me & c) === c && (Je === 4 || Je === 3 && (Me & 62914560) === Me && 300 > Jt() - xc ? (De & 2) === 0 && cl(i, 0) : Bh |= c,
        sl === Me && (sl = 0)),
        Un(i)
    }
    function B2(i, s) {
        s === 0 && (s = Rg()),
        i = Fi(i, s),
        i !== null && (Kl(i, s),
        Un(i))
    }
    function o9(i) {
        var s = i.memoizedState
          , c = 0;
        s !== null && (c = s.retryLane),
        B2(i, c)
    }
    function l9(i, s) {
        var c = 0;
        switch (i.tag) {
        case 31:
        case 13:
            var d = i.stateNode
              , g = i.memoizedState;
            g !== null && (c = g.retryLane);
            break;
        case 19:
            d = i.stateNode;
            break;
        case 22:
            d = i.stateNode._retryCache;
            break;
        default:
            throw Error(r(314))
        }
        d !== null && d.delete(s),
        B2(i, c)
    }
    function s9(i, s) {
        return nd(i, s)
    }
    var Nc = null
      , fl = null
      , $h = !1
      , Rc = !1
      , Fh = !1
      , ti = 0;
    function Un(i) {
        i !== fl && i.next === null && (fl === null ? Nc = fl = i : fl = fl.next = i),
        Rc = !0,
        $h || ($h = !0,
        c9())
    }
    function Ms(i, s) {
        if (!Fh && Rc) {
            Fh = !0;
            do
                for (var c = !1, d = Nc; d !== null; ) {
                    if (i !== 0) {
                        var g = d.pendingLanes;
                        if (g === 0)
                            var v = 0;
                        else {
                            var x = d.suspendedLanes
                              , M = d.pingedLanes;
                            v = (1 << 31 - en(42 | i) + 1) - 1,
                            v &= g & ~(x & ~M),
                            v = v & 201326741 ? v & 201326741 | 1 : v ? v | 2 : 0
                        }
                        v !== 0 && (c = !0,
                        V2(d, v))
                    } else
                        v = Me,
                        v = za(d, d === Ie ? v : 0, d.cancelPendingCommit !== null || d.timeoutHandle !== -1),
                        (v & 3) === 0 || Fl(d, v) || (c = !0,
                        V2(d, v));
                    d = d.next
                }
            while (c);
            Fh = !1
        }
    }
    function a9() {
        j2()
    }
    function j2() {
        Rc = $h = !1;
        var i = 0;
        ti !== 0 && b9() && (i = ti);
        for (var s = Jt(), c = null, d = Nc; d !== null; ) {
            var g = d.next
              , v = H2(d, s);
            v === 0 ? (d.next = null,
            c === null ? Nc = g : c.next = g,
            g === null && (fl = c)) : (c = d,
            (i !== 0 || (v & 3) !== 0) && (Rc = !0)),
            d = g
        }
        ht !== 0 && ht !== 5 || Ms(i),
        ti !== 0 && (ti = 0)
    }
    function H2(i, s) {
        for (var c = i.suspendedLanes, d = i.pingedLanes, g = i.expirationTimes, v = i.pendingLanes & -62914561; 0 < v; ) {
            var x = 31 - en(v)
              , M = 1 << x
              , N = g[x];
            N === -1 ? ((M & c) === 0 || (M & d) !== 0) && (g[x] = _7(M, s)) : N <= s && (i.expiredLanes |= M),
            v &= ~M
        }
        if (s = Ie,
        c = Me,
        c = za(i, i === s ? c : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1),
        d = i.callbackNode,
        c === 0 || i === s && (ze === 2 || ze === 9) || i.cancelPendingCommit !== null)
            return d !== null && d !== null && rd(d),
            i.callbackNode = null,
            i.callbackPriority = 0;
        if ((c & 3) === 0 || Fl(i, c)) {
            if (s = c & -c,
            s === i.callbackPriority)
                return s;
            switch (d !== null && rd(d),
            ld(c)) {
            case 2:
            case 8:
                c = Ag;
                break;
            case 32:
                c = Ra;
                break;
            case 268435456:
                c = Ng;
                break;
            default:
                c = Ra
            }
            return d = I2.bind(null, i),
            c = nd(c, d),
            i.callbackPriority = s,
            i.callbackNode = c,
            s
        }
        return d !== null && d !== null && rd(d),
        i.callbackPriority = 2,
        i.callbackNode = null,
        2
    }
    function I2(i, s) {
        if (ht !== 0 && ht !== 5)
            return i.callbackNode = null,
            i.callbackPriority = 0,
            null;
        var c = i.callbackNode;
        if (Ac() && i.callbackNode !== c)
            return null;
        var d = Me;
        return d = za(i, i === Ie ? d : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1),
        d === 0 ? null : (C2(i, d, s),
        H2(i, Jt()),
        i.callbackNode != null && i.callbackNode === c ? I2.bind(null, i) : null)
    }
    function V2(i, s) {
        if (Ac())
            return null;
        C2(i, s, !0)
    }
    function c9() {
        S9(function() {
            (De & 6) !== 0 ? nd(Mg, a9) : j2()
        })
    }
    function Kh() {
        if (ti === 0) {
            var i = Wo;
            i === 0 && (i = Oa,
            Oa <<= 1,
            (Oa & 261888) === 0 && (Oa = 256)),
            ti = i
        }
        return ti
    }
    function U2(i) {
        return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : Ha("" + i)
    }
    function P2(i, s) {
        var c = s.ownerDocument.createElement("input");
        return c.name = s.name,
        c.value = s.value,
        i.id && c.setAttribute("form", i.id),
        s.parentNode.insertBefore(c, s),
        i = new FormData(i),
        c.parentNode.removeChild(c),
        i
    }
    function u9(i, s, c, d, g) {
        if (s === "submit" && c && c.stateNode === g) {
            var v = U2((g[Ut] || null).action)
              , x = d.submitter;
            x && (s = (s = x[Ut] || null) ? U2(s.formAction) : x.getAttribute("formAction"),
            s !== null && (v = s,
            x = null));
            var M = new Pa("action","action",null,d,g);
            i.push({
                event: M,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (d.defaultPrevented) {
                            if (ti !== 0) {
                                var N = x ? P2(g, x) : new FormData(g);
                                dh(c, {
                                    pending: !0,
                                    data: N,
                                    method: g.method,
                                    action: v
                                }, null, N)
                            }
                        } else
                            typeof v == "function" && (M.preventDefault(),
                            N = x ? P2(g, x) : new FormData(g),
                            dh(c, {
                                pending: !0,
                                data: N,
                                method: g.method,
                                action: v
                            }, v, N))
                    },
                    currentTarget: g
                }]
            })
        }
    }
    for (var Gh = 0; Gh < Nd.length; Gh++) {
        var Yh = Nd[Gh]
          , f9 = Yh.toLowerCase()
          , d9 = Yh[0].toUpperCase() + Yh.slice(1);
        On(f9, "on" + d9)
    }
    On(b0, "onAnimationEnd"),
    On(C0, "onAnimationIteration"),
    On(S0, "onAnimationStart"),
    On("dblclick", "onDoubleClick"),
    On("focusin", "onFocus"),
    On("focusout", "onBlur"),
    On(Aw, "onTransitionRun"),
    On(Nw, "onTransitionStart"),
    On(Rw, "onTransitionCancel"),
    On(x0, "onTransitionEnd"),
    Bo("onMouseEnter", ["mouseout", "mouseover"]),
    Bo("onMouseLeave", ["mouseout", "mouseover"]),
    Bo("onPointerEnter", ["pointerout", "pointerover"]),
    Bo("onPointerLeave", ["pointerout", "pointerover"]),
    Ui("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    Ui("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    Ui("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    Ui("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    Ui("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    Ui("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var As = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , h9 = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(As));
    function q2(i, s) {
        s = (s & 4) !== 0;
        for (var c = 0; c < i.length; c++) {
            var d = i[c]
              , g = d.event;
            d = d.listeners;
            e: {
                var v = void 0;
                if (s)
                    for (var x = d.length - 1; 0 <= x; x--) {
                        var M = d[x]
                          , N = M.instance
                          , I = M.currentTarget;
                        if (M = M.listener,
                        N !== v && g.isPropagationStopped())
                            break e;
                        v = M,
                        g.currentTarget = I;
                        try {
                            v(g)
                        } catch (K) {
                            Fa(K)
                        }
                        g.currentTarget = null,
                        v = N
                    }
                else
                    for (x = 0; x < d.length; x++) {
                        if (M = d[x],
                        N = M.instance,
                        I = M.currentTarget,
                        M = M.listener,
                        N !== v && g.isPropagationStopped())
                            break e;
                        v = M,
                        g.currentTarget = I;
                        try {
                            v(g)
                        } catch (K) {
                            Fa(K)
                        }
                        g.currentTarget = null,
                        v = N
                    }
            }
        }
    }
    function ke(i, s) {
        var c = s[sd];
        c === void 0 && (c = s[sd] = new Set);
        var d = i + "__bubble";
        c.has(d) || ($2(s, i, 2, !1),
        c.add(d))
    }
    function Zh(i, s, c) {
        var d = 0;
        s && (d |= 4),
        $2(c, i, d, s)
    }
    var Oc = "_reactListening" + Math.random().toString(36).slice(2);
    function Wh(i) {
        if (!i[Oc]) {
            i[Oc] = !0,
            jg.forEach(function(c) {
                c !== "selectionchange" && (h9.has(c) || Zh(c, !1, i),
                Zh(c, !0, i))
            });
            var s = i.nodeType === 9 ? i : i.ownerDocument;
            s === null || s[Oc] || (s[Oc] = !0,
            Zh("selectionchange", !1, s))
        }
    }
    function $2(i, s, c, d) {
        switch (bv(s)) {
        case 2:
            var g = U9;
            break;
        case 8:
            g = P9;
            break;
        default:
            g = fp
        }
        c = g.bind(null, s, c, i),
        g = void 0,
        !gd || s !== "touchstart" && s !== "touchmove" && s !== "wheel" || (g = !0),
        d ? g !== void 0 ? i.addEventListener(s, c, {
            capture: !0,
            passive: g
        }) : i.addEventListener(s, c, !0) : g !== void 0 ? i.addEventListener(s, c, {
            passive: g
        }) : i.addEventListener(s, c, !1)
    }
    function Xh(i, s, c, d, g) {
        var v = d;
        if ((s & 1) === 0 && (s & 2) === 0 && d !== null)
            e: for (; ; ) {
                if (d === null)
                    return;
                var x = d.tag;
                if (x === 3 || x === 4) {
                    var M = d.stateNode.containerInfo;
                    if (M === g)
                        break;
                    if (x === 4)
                        for (x = d.return; x !== null; ) {
                            var N = x.tag;
                            if ((N === 3 || N === 4) && x.stateNode.containerInfo === g)
                                return;
                            x = x.return
                        }
                    for (; M !== null; ) {
                        if (x = Lo(M),
                        x === null)
                            return;
                        if (N = x.tag,
                        N === 5 || N === 6 || N === 26 || N === 27) {
                            d = v = x;
                            continue e
                        }
                        M = M.parentNode
                    }
                }
                d = d.return
            }
        Zg(function() {
            var I = v
              , K = pd(c)
              , Y = [];
            e: {
                var V = w0.get(i);
                if (V !== void 0) {
                    var F = Pa
                      , oe = i;
                    switch (i) {
                    case "keypress":
                        if (Va(c) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        F = lw;
                        break;
                    case "focusin":
                        oe = "focus",
                        F = Cd;
                        break;
                    case "focusout":
                        oe = "blur",
                        F = Cd;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        F = Cd;
                        break;
                    case "click":
                        if (c.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        F = Jg;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        F = Y7;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        F = cw;
                        break;
                    case b0:
                    case C0:
                    case S0:
                        F = X7;
                        break;
                    case x0:
                        F = fw;
                        break;
                    case "scroll":
                    case "scrollend":
                        F = K7;
                        break;
                    case "wheel":
                        F = hw;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        F = Q7;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        F = e0;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        F = mw
                    }
                    var me = (s & 4) !== 0
                      , He = !me && (i === "scroll" || i === "scrollend")
                      , L = me ? V !== null ? V + "Capture" : null : V;
                    me = [];
                    for (var D = I, H; D !== null; ) {
                        var G = D;
                        if (H = G.stateNode,
                        G = G.tag,
                        G !== 5 && G !== 26 && G !== 27 || H === null || L === null || (G = Zl(D, L),
                        G != null && me.push(Ns(D, G, H))),
                        He)
                            break;
                        D = D.return
                    }
                    0 < me.length && (V = new F(V,oe,null,c,K),
                    Y.push({
                        event: V,
                        listeners: me
                    }))
                }
            }
            if ((s & 7) === 0) {
                e: {
                    if (V = i === "mouseover" || i === "pointerover",
                    F = i === "mouseout" || i === "pointerout",
                    V && c !== hd && (oe = c.relatedTarget || c.fromElement) && (Lo(oe) || oe[Do]))
                        break e;
                    if ((F || V) && (V = K.window === K ? K : (V = K.ownerDocument) ? V.defaultView || V.parentWindow : window,
                    F ? (oe = c.relatedTarget || c.toElement,
                    F = I,
                    oe = oe ? Lo(oe) : null,
                    oe !== null && (He = l(oe),
                    me = oe.tag,
                    oe !== He || me !== 5 && me !== 27 && me !== 6) && (oe = null)) : (F = null,
                    oe = I),
                    F !== oe)) {
                        if (me = Jg,
                        G = "onMouseLeave",
                        L = "onMouseEnter",
                        D = "mouse",
                        (i === "pointerout" || i === "pointerover") && (me = e0,
                        G = "onPointerLeave",
                        L = "onPointerEnter",
                        D = "pointer"),
                        He = F == null ? V : Yl(F),
                        H = oe == null ? V : Yl(oe),
                        V = new me(G,D + "leave",F,c,K),
                        V.target = He,
                        V.relatedTarget = H,
                        G = null,
                        Lo(K) === I && (me = new me(L,D + "enter",oe,c,K),
                        me.target = H,
                        me.relatedTarget = He,
                        G = me),
                        He = G,
                        F && oe)
                            t: {
                                for (me = p9,
                                L = F,
                                D = oe,
                                H = 0,
                                G = L; G; G = me(G))
                                    H++;
                                G = 0;
                                for (var he = D; he; he = me(he))
                                    G++;
                                for (; 0 < H - G; )
                                    L = me(L),
                                    H--;
                                for (; 0 < G - H; )
                                    D = me(D),
                                    G--;
                                for (; H--; ) {
                                    if (L === D || D !== null && L === D.alternate) {
                                        me = L;
                                        break t
                                    }
                                    L = me(L),
                                    D = me(D)
                                }
                                me = null
                            }
                        else
                            me = null;
                        F !== null && F2(Y, V, F, me, !1),
                        oe !== null && He !== null && F2(Y, He, oe, me, !0)
                    }
                }
                e: {
                    if (V = I ? Yl(I) : window,
                    F = V.nodeName && V.nodeName.toLowerCase(),
                    F === "select" || F === "input" && V.type === "file")
                        var Re = a0;
                    else if (l0(V))
                        if (c0)
                            Re = Tw;
                        else {
                            Re = ww;
                            var ue = xw
                        }
                    else
                        F = V.nodeName,
                        !F || F.toLowerCase() !== "input" || V.type !== "checkbox" && V.type !== "radio" ? I && dd(I.elementType) && (Re = a0) : Re = Ew;
                    if (Re && (Re = Re(i, I))) {
                        s0(Y, Re, c, K);
                        break e
                    }
                    ue && ue(i, V, I),
                    i === "focusout" && I && V.type === "number" && I.memoizedProps.value != null && fd(V, "number", V.value)
                }
                switch (ue = I ? Yl(I) : window,
                i) {
                case "focusin":
                    (l0(ue) || ue.contentEditable === "true") && (Po = ue,
                    kd = I,
                    rs = null);
                    break;
                case "focusout":
                    rs = kd = Po = null;
                    break;
                case "mousedown":
                    Md = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Md = !1,
                    y0(Y, c, K);
                    break;
                case "selectionchange":
                    if (Mw)
                        break;
                case "keydown":
                case "keyup":
                    y0(Y, c, K)
                }
                var we;
                if (xd)
                    e: {
                        switch (i) {
                        case "compositionstart":
                            var Ae = "onCompositionStart";
                            break e;
                        case "compositionend":
                            Ae = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            Ae = "onCompositionUpdate";
                            break e
                        }
                        Ae = void 0
                    }
                else
                    Uo ? i0(i, c) && (Ae = "onCompositionEnd") : i === "keydown" && c.keyCode === 229 && (Ae = "onCompositionStart");
                Ae && (t0 && c.locale !== "ko" && (Uo || Ae !== "onCompositionStart" ? Ae === "onCompositionEnd" && Uo && (we = Wg()) : (Ir = K,
                yd = "value"in Ir ? Ir.value : Ir.textContent,
                Uo = !0)),
                ue = Dc(I, Ae),
                0 < ue.length && (Ae = new Qg(Ae,i,null,c,K),
                Y.push({
                    event: Ae,
                    listeners: ue
                }),
                we ? Ae.data = we : (we = o0(c),
                we !== null && (Ae.data = we)))),
                (we = yw ? vw(i, c) : bw(i, c)) && (Ae = Dc(I, "onBeforeInput"),
                0 < Ae.length && (ue = new Qg("onBeforeInput","beforeinput",null,c,K),
                Y.push({
                    event: ue,
                    listeners: Ae
                }),
                ue.data = we)),
                u9(Y, i, I, c, K)
            }
            q2(Y, s)
        })
    }
    function Ns(i, s, c) {
        return {
            instance: i,
            listener: s,
            currentTarget: c
        }
    }
    function Dc(i, s) {
        for (var c = s + "Capture", d = []; i !== null; ) {
            var g = i
              , v = g.stateNode;
            if (g = g.tag,
            g !== 5 && g !== 26 && g !== 27 || v === null || (g = Zl(i, c),
            g != null && d.unshift(Ns(i, g, v)),
            g = Zl(i, s),
            g != null && d.push(Ns(i, g, v))),
            i.tag === 3)
                return d;
            i = i.return
        }
        return []
    }
    function p9(i) {
        if (i === null)
            return null;
        do
            i = i.return;
        while (i && i.tag !== 5 && i.tag !== 27);
        return i || null
    }
    function F2(i, s, c, d, g) {
        for (var v = s._reactName, x = []; c !== null && c !== d; ) {
            var M = c
              , N = M.alternate
              , I = M.stateNode;
            if (M = M.tag,
            N !== null && N === d)
                break;
            M !== 5 && M !== 26 && M !== 27 || I === null || (N = I,
            g ? (I = Zl(c, v),
            I != null && x.unshift(Ns(c, I, N))) : g || (I = Zl(c, v),
            I != null && x.push(Ns(c, I, N)))),
            c = c.return
        }
        x.length !== 0 && i.push({
            event: s,
            listeners: x
        })
    }
    var m9 = /\r\n?/g
      , g9 = /\u0000|\uFFFD/g;
    function K2(i) {
        return (typeof i == "string" ? i : "" + i).replace(m9, `
`).replace(g9, "")
    }
    function G2(i, s) {
        return s = K2(s),
        K2(i) === s
    }
    function je(i, s, c, d, g, v) {
        switch (c) {
        case "children":
            typeof d == "string" ? s === "body" || s === "textarea" && d === "" || Ho(i, d) : (typeof d == "number" || typeof d == "bigint") && s !== "body" && Ho(i, "" + d);
            break;
        case "className":
            Ba(i, "class", d);
            break;
        case "tabIndex":
            Ba(i, "tabindex", d);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            Ba(i, c, d);
            break;
        case "style":
            Gg(i, d, v);
            break;
        case "data":
            if (s !== "object") {
                Ba(i, "data", d);
                break
            }
        case "src":
        case "href":
            if (d === "" && (s !== "a" || c !== "href")) {
                i.removeAttribute(c);
                break
            }
            if (d == null || typeof d == "function" || typeof d == "symbol" || typeof d == "boolean") {
                i.removeAttribute(c);
                break
            }
            d = Ha("" + d),
            i.setAttribute(c, d);
            break;
        case "action":
        case "formAction":
            if (typeof d == "function") {
                i.setAttribute(c, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof v == "function" && (c === "formAction" ? (s !== "input" && je(i, s, "name", g.name, g, null),
                je(i, s, "formEncType", g.formEncType, g, null),
                je(i, s, "formMethod", g.formMethod, g, null),
                je(i, s, "formTarget", g.formTarget, g, null)) : (je(i, s, "encType", g.encType, g, null),
                je(i, s, "method", g.method, g, null),
                je(i, s, "target", g.target, g, null)));
            if (d == null || typeof d == "symbol" || typeof d == "boolean") {
                i.removeAttribute(c);
                break
            }
            d = Ha("" + d),
            i.setAttribute(c, d);
            break;
        case "onClick":
            d != null && (i.onclick = ir);
            break;
        case "onScroll":
            d != null && ke("scroll", i);
            break;
        case "onScrollEnd":
            d != null && ke("scrollend", i);
            break;
        case "dangerouslySetInnerHTML":
            if (d != null) {
                if (typeof d != "object" || !("__html"in d))
                    throw Error(r(61));
                if (c = d.__html,
                c != null) {
                    if (g.children != null)
                        throw Error(r(60));
                    i.innerHTML = c
                }
            }
            break;
        case "multiple":
            i.multiple = d && typeof d != "function" && typeof d != "symbol";
            break;
        case "muted":
            i.muted = d && typeof d != "function" && typeof d != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (d == null || typeof d == "function" || typeof d == "boolean" || typeof d == "symbol") {
                i.removeAttribute("xlink:href");
                break
            }
            c = Ha("" + d),
            i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", c);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            d != null && typeof d != "function" && typeof d != "symbol" ? i.setAttribute(c, "" + d) : i.removeAttribute(c);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            d && typeof d != "function" && typeof d != "symbol" ? i.setAttribute(c, "") : i.removeAttribute(c);
            break;
        case "capture":
        case "download":
            d === !0 ? i.setAttribute(c, "") : d !== !1 && d != null && typeof d != "function" && typeof d != "symbol" ? i.setAttribute(c, d) : i.removeAttribute(c);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            d != null && typeof d != "function" && typeof d != "symbol" && !isNaN(d) && 1 <= d ? i.setAttribute(c, d) : i.removeAttribute(c);
            break;
        case "rowSpan":
        case "start":
            d == null || typeof d == "function" || typeof d == "symbol" || isNaN(d) ? i.removeAttribute(c) : i.setAttribute(c, d);
            break;
        case "popover":
            ke("beforetoggle", i),
            ke("toggle", i),
            _a(i, "popover", d);
            break;
        case "xlinkActuate":
            rr(i, "http://www.w3.org/1999/xlink", "xlink:actuate", d);
            break;
        case "xlinkArcrole":
            rr(i, "http://www.w3.org/1999/xlink", "xlink:arcrole", d);
            break;
        case "xlinkRole":
            rr(i, "http://www.w3.org/1999/xlink", "xlink:role", d);
            break;
        case "xlinkShow":
            rr(i, "http://www.w3.org/1999/xlink", "xlink:show", d);
            break;
        case "xlinkTitle":
            rr(i, "http://www.w3.org/1999/xlink", "xlink:title", d);
            break;
        case "xlinkType":
            rr(i, "http://www.w3.org/1999/xlink", "xlink:type", d);
            break;
        case "xmlBase":
            rr(i, "http://www.w3.org/XML/1998/namespace", "xml:base", d);
            break;
        case "xmlLang":
            rr(i, "http://www.w3.org/XML/1998/namespace", "xml:lang", d);
            break;
        case "xmlSpace":
            rr(i, "http://www.w3.org/XML/1998/namespace", "xml:space", d);
            break;
        case "is":
            _a(i, "is", d);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = $7.get(c) || c,
            _a(i, c, d))
        }
    }
    function Jh(i, s, c, d, g, v) {
        switch (c) {
        case "style":
            Gg(i, d, v);
            break;
        case "dangerouslySetInnerHTML":
            if (d != null) {
                if (typeof d != "object" || !("__html"in d))
                    throw Error(r(61));
                if (c = d.__html,
                c != null) {
                    if (g.children != null)
                        throw Error(r(60));
                    i.innerHTML = c
                }
            }
            break;
        case "children":
            typeof d == "string" ? Ho(i, d) : (typeof d == "number" || typeof d == "bigint") && Ho(i, "" + d);
            break;
        case "onScroll":
            d != null && ke("scroll", i);
            break;
        case "onScrollEnd":
            d != null && ke("scrollend", i);
            break;
        case "onClick":
            d != null && (i.onclick = ir);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!Hg.hasOwnProperty(c))
                e: {
                    if (c[0] === "o" && c[1] === "n" && (g = c.endsWith("Capture"),
                    s = c.slice(2, g ? c.length - 7 : void 0),
                    v = i[Ut] || null,
                    v = v != null ? v[c] : null,
                    typeof v == "function" && i.removeEventListener(s, v, g),
                    typeof d == "function")) {
                        typeof v != "function" && v !== null && (c in i ? i[c] = null : i.hasAttribute(c) && i.removeAttribute(c)),
                        i.addEventListener(s, d, g);
                        break e
                    }
                    c in i ? i[c] = d : d === !0 ? i.setAttribute(c, "") : _a(i, c, d)
                }
        }
    }
    function Et(i, s, c) {
        switch (s) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            ke("error", i),
            ke("load", i);
            var d = !1, g = !1, v;
            for (v in c)
                if (c.hasOwnProperty(v)) {
                    var x = c[v];
                    if (x != null)
                        switch (v) {
                        case "src":
                            d = !0;
                            break;
                        case "srcSet":
                            g = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(r(137, s));
                        default:
                            je(i, s, v, x, c, null)
                        }
                }
            g && je(i, s, "srcSet", c.srcSet, c, null),
            d && je(i, s, "src", c.src, c, null);
            return;
        case "input":
            ke("invalid", i);
            var M = v = x = g = null
              , N = null
              , I = null;
            for (d in c)
                if (c.hasOwnProperty(d)) {
                    var K = c[d];
                    if (K != null)
                        switch (d) {
                        case "name":
                            g = K;
                            break;
                        case "type":
                            x = K;
                            break;
                        case "checked":
                            N = K;
                            break;
                        case "defaultChecked":
                            I = K;
                            break;
                        case "value":
                            v = K;
                            break;
                        case "defaultValue":
                            M = K;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (K != null)
                                throw Error(r(137, s));
                            break;
                        default:
                            je(i, s, d, K, c, null)
                        }
                }
            qg(i, v, M, N, I, x, g, !1);
            return;
        case "select":
            ke("invalid", i),
            d = x = v = null;
            for (g in c)
                if (c.hasOwnProperty(g) && (M = c[g],
                M != null))
                    switch (g) {
                    case "value":
                        v = M;
                        break;
                    case "defaultValue":
                        x = M;
                        break;
                    case "multiple":
                        d = M;
                    default:
                        je(i, s, g, M, c, null)
                    }
            s = v,
            c = x,
            i.multiple = !!d,
            s != null ? jo(i, !!d, s, !1) : c != null && jo(i, !!d, c, !0);
            return;
        case "textarea":
            ke("invalid", i),
            v = g = d = null;
            for (x in c)
                if (c.hasOwnProperty(x) && (M = c[x],
                M != null))
                    switch (x) {
                    case "value":
                        d = M;
                        break;
                    case "defaultValue":
                        g = M;
                        break;
                    case "children":
                        v = M;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (M != null)
                            throw Error(r(91));
                        break;
                    default:
                        je(i, s, x, M, c, null)
                    }
            Fg(i, d, g, v);
            return;
        case "option":
            for (N in c)
                c.hasOwnProperty(N) && (d = c[N],
                d != null) && (N === "selected" ? i.selected = d && typeof d != "function" && typeof d != "symbol" : je(i, s, N, d, c, null));
            return;
        case "dialog":
            ke("beforetoggle", i),
            ke("toggle", i),
            ke("cancel", i),
            ke("close", i);
            break;
        case "iframe":
        case "object":
            ke("load", i);
            break;
        case "video":
        case "audio":
            for (d = 0; d < As.length; d++)
                ke(As[d], i);
            break;
        case "image":
            ke("error", i),
            ke("load", i);
            break;
        case "details":
            ke("toggle", i);
            break;
        case "embed":
        case "source":
        case "link":
            ke("error", i),
            ke("load", i);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (I in c)
                if (c.hasOwnProperty(I) && (d = c[I],
                d != null))
                    switch (I) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(r(137, s));
                    default:
                        je(i, s, I, d, c, null)
                    }
            return;
        default:
            if (dd(s)) {
                for (K in c)
                    c.hasOwnProperty(K) && (d = c[K],
                    d !== void 0 && Jh(i, s, K, d, c, void 0));
                return
            }
        }
        for (M in c)
            c.hasOwnProperty(M) && (d = c[M],
            d != null && je(i, s, M, d, c, null))
    }
    function y9(i, s, c, d) {
        switch (s) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var g = null
              , v = null
              , x = null
              , M = null
              , N = null
              , I = null
              , K = null;
            for (F in c) {
                var Y = c[F];
                if (c.hasOwnProperty(F) && Y != null)
                    switch (F) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        N = Y;
                    default:
                        d.hasOwnProperty(F) || je(i, s, F, null, d, Y)
                    }
            }
            for (var V in d) {
                var F = d[V];
                if (Y = c[V],
                d.hasOwnProperty(V) && (F != null || Y != null))
                    switch (V) {
                    case "type":
                        v = F;
                        break;
                    case "name":
                        g = F;
                        break;
                    case "checked":
                        I = F;
                        break;
                    case "defaultChecked":
                        K = F;
                        break;
                    case "value":
                        x = F;
                        break;
                    case "defaultValue":
                        M = F;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (F != null)
                            throw Error(r(137, s));
                        break;
                    default:
                        F !== Y && je(i, s, V, F, d, Y)
                    }
            }
            ud(i, x, M, N, I, K, v, g);
            return;
        case "select":
            F = x = M = V = null;
            for (v in c)
                if (N = c[v],
                c.hasOwnProperty(v) && N != null)
                    switch (v) {
                    case "value":
                        break;
                    case "multiple":
                        F = N;
                    default:
                        d.hasOwnProperty(v) || je(i, s, v, null, d, N)
                    }
            for (g in d)
                if (v = d[g],
                N = c[g],
                d.hasOwnProperty(g) && (v != null || N != null))
                    switch (g) {
                    case "value":
                        V = v;
                        break;
                    case "defaultValue":
                        M = v;
                        break;
                    case "multiple":
                        x = v;
                    default:
                        v !== N && je(i, s, g, v, d, N)
                    }
            s = M,
            c = x,
            d = F,
            V != null ? jo(i, !!c, V, !1) : !!d != !!c && (s != null ? jo(i, !!c, s, !0) : jo(i, !!c, c ? [] : "", !1));
            return;
        case "textarea":
            F = V = null;
            for (M in c)
                if (g = c[M],
                c.hasOwnProperty(M) && g != null && !d.hasOwnProperty(M))
                    switch (M) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        je(i, s, M, null, d, g)
                    }
            for (x in d)
                if (g = d[x],
                v = c[x],
                d.hasOwnProperty(x) && (g != null || v != null))
                    switch (x) {
                    case "value":
                        V = g;
                        break;
                    case "defaultValue":
                        F = g;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (g != null)
                            throw Error(r(91));
                        break;
                    default:
                        g !== v && je(i, s, x, g, d, v)
                    }
            $g(i, V, F);
            return;
        case "option":
            for (var oe in c)
                V = c[oe],
                c.hasOwnProperty(oe) && V != null && !d.hasOwnProperty(oe) && (oe === "selected" ? i.selected = !1 : je(i, s, oe, null, d, V));
            for (N in d)
                V = d[N],
                F = c[N],
                d.hasOwnProperty(N) && V !== F && (V != null || F != null) && (N === "selected" ? i.selected = V && typeof V != "function" && typeof V != "symbol" : je(i, s, N, V, d, F));
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var me in c)
                V = c[me],
                c.hasOwnProperty(me) && V != null && !d.hasOwnProperty(me) && je(i, s, me, null, d, V);
            for (I in d)
                if (V = d[I],
                F = c[I],
                d.hasOwnProperty(I) && V !== F && (V != null || F != null))
                    switch (I) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (V != null)
                            throw Error(r(137, s));
                        break;
                    default:
                        je(i, s, I, V, d, F)
                    }
            return;
        default:
            if (dd(s)) {
                for (var He in c)
                    V = c[He],
                    c.hasOwnProperty(He) && V !== void 0 && !d.hasOwnProperty(He) && Jh(i, s, He, void 0, d, V);
                for (K in d)
                    V = d[K],
                    F = c[K],
                    !d.hasOwnProperty(K) || V === F || V === void 0 && F === void 0 || Jh(i, s, K, V, d, F);
                return
            }
        }
        for (var L in c)
            V = c[L],
            c.hasOwnProperty(L) && V != null && !d.hasOwnProperty(L) && je(i, s, L, null, d, V);
        for (Y in d)
            V = d[Y],
            F = c[Y],
            !d.hasOwnProperty(Y) || V === F || V == null && F == null || je(i, s, Y, V, d, F)
    }
    function Y2(i) {
        switch (i) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
            return !0;
        default:
            return !1
        }
    }
    function v9() {
        if (typeof performance.getEntriesByType == "function") {
            for (var i = 0, s = 0, c = performance.getEntriesByType("resource"), d = 0; d < c.length; d++) {
                var g = c[d]
                  , v = g.transferSize
                  , x = g.initiatorType
                  , M = g.duration;
                if (v && M && Y2(x)) {
                    for (x = 0,
                    M = g.responseEnd,
                    d += 1; d < c.length; d++) {
                        var N = c[d]
                          , I = N.startTime;
                        if (I > M)
                            break;
                        var K = N.transferSize
                          , Y = N.initiatorType;
                        K && Y2(Y) && (N = N.responseEnd,
                        x += K * (N < M ? 1 : (M - I) / (N - I)))
                    }
                    if (--d,
                    s += 8 * (v + x) / (g.duration / 1e3),
                    i++,
                    10 < i)
                        break
                }
            }
            if (0 < i)
                return s / i / 1e6
        }
        return navigator.connection && (i = navigator.connection.downlink,
        typeof i == "number") ? i : 5
    }
    var Qh = null
      , ep = null;
    function Lc(i) {
        return i.nodeType === 9 ? i : i.ownerDocument
    }
    function Z2(i) {
        switch (i) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function W2(i, s) {
        if (i === 0)
            switch (s) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return i === 1 && s === "foreignObject" ? 0 : i
    }
    function tp(i, s) {
        return i === "textarea" || i === "noscript" || typeof s.children == "string" || typeof s.children == "number" || typeof s.children == "bigint" || typeof s.dangerouslySetInnerHTML == "object" && s.dangerouslySetInnerHTML !== null && s.dangerouslySetInnerHTML.__html != null
    }
    var np = null;
    function b9() {
        var i = window.event;
        return i && i.type === "popstate" ? i === np ? !1 : (np = i,
        !0) : (np = null,
        !1)
    }
    var X2 = typeof setTimeout == "function" ? setTimeout : void 0
      , C9 = typeof clearTimeout == "function" ? clearTimeout : void 0
      , J2 = typeof Promise == "function" ? Promise : void 0
      , S9 = typeof queueMicrotask == "function" ? queueMicrotask : typeof J2 < "u" ? function(i) {
        return J2.resolve(null).then(i).catch(x9)
    }
    : X2;
    function x9(i) {
        setTimeout(function() {
            throw i
        })
    }
    function ni(i) {
        return i === "head"
    }
    function Q2(i, s) {
        var c = s
          , d = 0;
        do {
            var g = c.nextSibling;
            if (i.removeChild(c),
            g && g.nodeType === 8)
                if (c = g.data,
                c === "/$" || c === "/&") {
                    if (d === 0) {
                        i.removeChild(g),
                        ml(s);
                        return
                    }
                    d--
                } else if (c === "$" || c === "$?" || c === "$~" || c === "$!" || c === "&")
                    d++;
                else if (c === "html")
                    Rs(i.ownerDocument.documentElement);
                else if (c === "head") {
                    c = i.ownerDocument.head,
                    Rs(c);
                    for (var v = c.firstChild; v; ) {
                        var x = v.nextSibling
                          , M = v.nodeName;
                        v[Gl] || M === "SCRIPT" || M === "STYLE" || M === "LINK" && v.rel.toLowerCase() === "stylesheet" || c.removeChild(v),
                        v = x
                    }
                } else
                    c === "body" && Rs(i.ownerDocument.body);
            c = g
        } while (c);
        ml(s)
    }
    function ev(i, s) {
        var c = i;
        i = 0;
        do {
            var d = c.nextSibling;
            if (c.nodeType === 1 ? s ? (c._stashedDisplay = c.style.display,
            c.style.display = "none") : (c.style.display = c._stashedDisplay || "",
            c.getAttribute("style") === "" && c.removeAttribute("style")) : c.nodeType === 3 && (s ? (c._stashedText = c.nodeValue,
            c.nodeValue = "") : c.nodeValue = c._stashedText || ""),
            d && d.nodeType === 8)
                if (c = d.data,
                c === "/$") {
                    if (i === 0)
                        break;
                    i--
                } else
                    c !== "$" && c !== "$?" && c !== "$~" && c !== "$!" || i++;
            c = d
        } while (c)
    }
    function rp(i) {
        var s = i.firstChild;
        for (s && s.nodeType === 10 && (s = s.nextSibling); s; ) {
            var c = s;
            switch (s = s.nextSibling,
            c.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                rp(c),
                ad(c);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (c.rel.toLowerCase() === "stylesheet")
                    continue
            }
            i.removeChild(c)
        }
    }
    function w9(i, s, c, d) {
        for (; i.nodeType === 1; ) {
            var g = c;
            if (i.nodeName.toLowerCase() !== s.toLowerCase()) {
                if (!d && (i.nodeName !== "INPUT" || i.type !== "hidden"))
                    break
            } else if (d) {
                if (!i[Gl])
                    switch (s) {
                    case "meta":
                        if (!i.hasAttribute("itemprop"))
                            break;
                        return i;
                    case "link":
                        if (v = i.getAttribute("rel"),
                        v === "stylesheet" && i.hasAttribute("data-precedence"))
                            break;
                        if (v !== g.rel || i.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || i.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || i.getAttribute("title") !== (g.title == null ? null : g.title))
                            break;
                        return i;
                    case "style":
                        if (i.hasAttribute("data-precedence"))
                            break;
                        return i;
                    case "script":
                        if (v = i.getAttribute("src"),
                        (v !== (g.src == null ? null : g.src) || i.getAttribute("type") !== (g.type == null ? null : g.type) || i.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && v && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                            break;
                        return i;
                    default:
                        return i
                    }
            } else if (s === "input" && i.type === "hidden") {
                var v = g.name == null ? null : "" + g.name;
                if (g.type === "hidden" && i.getAttribute("name") === v)
                    return i
            } else
                return i;
            if (i = Sn(i.nextSibling),
            i === null)
                break
        }
        return null
    }
    function E9(i, s, c) {
        if (s === "")
            return null;
        for (; i.nodeType !== 3; )
            if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !c || (i = Sn(i.nextSibling),
            i === null))
                return null;
        return i
    }
    function tv(i, s) {
        for (; i.nodeType !== 8; )
            if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !s || (i = Sn(i.nextSibling),
            i === null))
                return null;
        return i
    }
    function ip(i) {
        return i.data === "$?" || i.data === "$~"
    }
    function op(i) {
        return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState !== "loading"
    }
    function T9(i, s) {
        var c = i.ownerDocument;
        if (i.data === "$~")
            i._reactRetry = s;
        else if (i.data !== "$?" || c.readyState !== "loading")
            s();
        else {
            var d = function() {
                s(),
                c.removeEventListener("DOMContentLoaded", d)
            };
            c.addEventListener("DOMContentLoaded", d),
            i._reactRetry = d
        }
    }
    function Sn(i) {
        for (; i != null; i = i.nextSibling) {
            var s = i.nodeType;
            if (s === 1 || s === 3)
                break;
            if (s === 8) {
                if (s = i.data,
                s === "$" || s === "$!" || s === "$?" || s === "$~" || s === "&" || s === "F!" || s === "F")
                    break;
                if (s === "/$" || s === "/&")
                    return null
            }
        }
        return i
    }
    var lp = null;
    function nv(i) {
        i = i.nextSibling;
        for (var s = 0; i; ) {
            if (i.nodeType === 8) {
                var c = i.data;
                if (c === "/$" || c === "/&") {
                    if (s === 0)
                        return Sn(i.nextSibling);
                    s--
                } else
                    c !== "$" && c !== "$!" && c !== "$?" && c !== "$~" && c !== "&" || s++
            }
            i = i.nextSibling
        }
        return null
    }
    function rv(i) {
        i = i.previousSibling;
        for (var s = 0; i; ) {
            if (i.nodeType === 8) {
                var c = i.data;
                if (c === "$" || c === "$!" || c === "$?" || c === "$~" || c === "&") {
                    if (s === 0)
                        return i;
                    s--
                } else
                    c !== "/$" && c !== "/&" || s++
            }
            i = i.previousSibling
        }
        return null
    }
    function iv(i, s, c) {
        switch (s = Lc(c),
        i) {
        case "html":
            if (i = s.documentElement,
            !i)
                throw Error(r(452));
            return i;
        case "head":
            if (i = s.head,
            !i)
                throw Error(r(453));
            return i;
        case "body":
            if (i = s.body,
            !i)
                throw Error(r(454));
            return i;
        default:
            throw Error(r(451))
        }
    }
    function Rs(i) {
        for (var s = i.attributes; s.length; )
            i.removeAttributeNode(s[0]);
        ad(i)
    }
    var xn = new Map
      , ov = new Set;
    function zc(i) {
        return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument
    }
    var Cr = P.d;
    P.d = {
        f: k9,
        r: M9,
        D: A9,
        C: N9,
        L: R9,
        m: O9,
        X: L9,
        S: D9,
        M: z9
    };
    function k9() {
        var i = Cr.f()
          , s = Tc();
        return i || s
    }
    function M9(i) {
        var s = zo(i);
        s !== null && s.tag === 5 && s.type === "form" ? xy(s) : Cr.r(i)
    }
    var dl = typeof document > "u" ? null : document;
    function lv(i, s, c) {
        var d = dl;
        if (d && typeof s == "string" && s) {
            var g = pn(s);
            g = 'link[rel="' + i + '"][href="' + g + '"]',
            typeof c == "string" && (g += '[crossorigin="' + c + '"]'),
            ov.has(g) || (ov.add(g),
            i = {
                rel: i,
                crossOrigin: c,
                href: s
            },
            d.querySelector(g) === null && (s = d.createElement("link"),
            Et(s, "link", i),
            pt(s),
            d.head.appendChild(s)))
        }
    }
    function A9(i) {
        Cr.D(i),
        lv("dns-prefetch", i, null)
    }
    function N9(i, s) {
        Cr.C(i, s),
        lv("preconnect", i, s)
    }
    function R9(i, s, c) {
        Cr.L(i, s, c);
        var d = dl;
        if (d && i && s) {
            var g = 'link[rel="preload"][as="' + pn(s) + '"]';
            s === "image" && c && c.imageSrcSet ? (g += '[imagesrcset="' + pn(c.imageSrcSet) + '"]',
            typeof c.imageSizes == "string" && (g += '[imagesizes="' + pn(c.imageSizes) + '"]')) : g += '[href="' + pn(i) + '"]';
            var v = g;
            switch (s) {
            case "style":
                v = hl(i);
                break;
            case "script":
                v = pl(i)
            }
            xn.has(v) || (i = m({
                rel: "preload",
                href: s === "image" && c && c.imageSrcSet ? void 0 : i,
                as: s
            }, c),
            xn.set(v, i),
            d.querySelector(g) !== null || s === "style" && d.querySelector(Os(v)) || s === "script" && d.querySelector(Ds(v)) || (s = d.createElement("link"),
            Et(s, "link", i),
            pt(s),
            d.head.appendChild(s)))
        }
    }
    function O9(i, s) {
        Cr.m(i, s);
        var c = dl;
        if (c && i) {
            var d = s && typeof s.as == "string" ? s.as : "script"
              , g = 'link[rel="modulepreload"][as="' + pn(d) + '"][href="' + pn(i) + '"]'
              , v = g;
            switch (d) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                v = pl(i)
            }
            if (!xn.has(v) && (i = m({
                rel: "modulepreload",
                href: i
            }, s),
            xn.set(v, i),
            c.querySelector(g) === null)) {
                switch (d) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (c.querySelector(Ds(v)))
                        return
                }
                d = c.createElement("link"),
                Et(d, "link", i),
                pt(d),
                c.head.appendChild(d)
            }
        }
    }
    function D9(i, s, c) {
        Cr.S(i, s, c);
        var d = dl;
        if (d && i) {
            var g = _o(d).hoistableStyles
              , v = hl(i);
            s = s || "default";
            var x = g.get(v);
            if (!x) {
                var M = {
                    loading: 0,
                    preload: null
                };
                if (x = d.querySelector(Os(v)))
                    M.loading = 5;
                else {
                    i = m({
                        rel: "stylesheet",
                        href: i,
                        "data-precedence": s
                    }, c),
                    (c = xn.get(v)) && sp(i, c);
                    var N = x = d.createElement("link");
                    pt(N),
                    Et(N, "link", i),
                    N._p = new Promise(function(I, K) {
                        N.onload = I,
                        N.onerror = K
                    }
                    ),
                    N.addEventListener("load", function() {
                        M.loading |= 1
                    }),
                    N.addEventListener("error", function() {
                        M.loading |= 2
                    }),
                    M.loading |= 4,
                    _c(x, s, d)
                }
                x = {
                    type: "stylesheet",
                    instance: x,
                    count: 1,
                    state: M
                },
                g.set(v, x)
            }
        }
    }
    function L9(i, s) {
        Cr.X(i, s);
        var c = dl;
        if (c && i) {
            var d = _o(c).hoistableScripts
              , g = pl(i)
              , v = d.get(g);
            v || (v = c.querySelector(Ds(g)),
            v || (i = m({
                src: i,
                async: !0
            }, s),
            (s = xn.get(g)) && ap(i, s),
            v = c.createElement("script"),
            pt(v),
            Et(v, "link", i),
            c.head.appendChild(v)),
            v = {
                type: "script",
                instance: v,
                count: 1,
                state: null
            },
            d.set(g, v))
        }
    }
    function z9(i, s) {
        Cr.M(i, s);
        var c = dl;
        if (c && i) {
            var d = _o(c).hoistableScripts
              , g = pl(i)
              , v = d.get(g);
            v || (v = c.querySelector(Ds(g)),
            v || (i = m({
                src: i,
                async: !0,
                type: "module"
            }, s),
            (s = xn.get(g)) && ap(i, s),
            v = c.createElement("script"),
            pt(v),
            Et(v, "link", i),
            c.head.appendChild(v)),
            v = {
                type: "script",
                instance: v,
                count: 1,
                state: null
            },
            d.set(g, v))
        }
    }
    function sv(i, s, c, d) {
        var g = (g = ge.current) ? zc(g) : null;
        if (!g)
            throw Error(r(446));
        switch (i) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof c.precedence == "string" && typeof c.href == "string" ? (s = hl(c.href),
            c = _o(g).hoistableStyles,
            d = c.get(s),
            d || (d = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            c.set(s, d)),
            d) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
                i = hl(c.href);
                var v = _o(g).hoistableStyles
                  , x = v.get(i);
                if (x || (g = g.ownerDocument || g,
                x = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                v.set(i, x),
                (v = g.querySelector(Os(i))) && !v._p && (x.instance = v,
                x.state.loading = 5),
                xn.has(i) || (c = {
                    rel: "preload",
                    as: "style",
                    href: c.href,
                    crossOrigin: c.crossOrigin,
                    integrity: c.integrity,
                    media: c.media,
                    hrefLang: c.hrefLang,
                    referrerPolicy: c.referrerPolicy
                },
                xn.set(i, c),
                v || _9(g, i, c, x.state))),
                s && d === null)
                    throw Error(r(528, ""));
                return x
            }
            if (s && d !== null)
                throw Error(r(529, ""));
            return null;
        case "script":
            return s = c.async,
            c = c.src,
            typeof c == "string" && s && typeof s != "function" && typeof s != "symbol" ? (s = pl(c),
            c = _o(g).hoistableScripts,
            d = c.get(s),
            d || (d = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            c.set(s, d)),
            d) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(r(444, i))
        }
    }
    function hl(i) {
        return 'href="' + pn(i) + '"'
    }
    function Os(i) {
        return 'link[rel="stylesheet"][' + i + "]"
    }
    function av(i) {
        return m({}, i, {
            "data-precedence": i.precedence,
            precedence: null
        })
    }
    function _9(i, s, c, d) {
        i.querySelector('link[rel="preload"][as="style"][' + s + "]") ? d.loading = 1 : (s = i.createElement("link"),
        d.preload = s,
        s.addEventListener("load", function() {
            return d.loading |= 1
        }),
        s.addEventListener("error", function() {
            return d.loading |= 2
        }),
        Et(s, "link", c),
        pt(s),
        i.head.appendChild(s))
    }
    function pl(i) {
        return '[src="' + pn(i) + '"]'
    }
    function Ds(i) {
        return "script[async]" + i
    }
    function cv(i, s, c) {
        if (s.count++,
        s.instance === null)
            switch (s.type) {
            case "style":
                var d = i.querySelector('style[data-href~="' + pn(c.href) + '"]');
                if (d)
                    return s.instance = d,
                    pt(d),
                    d;
                var g = m({}, c, {
                    "data-href": c.href,
                    "data-precedence": c.precedence,
                    href: null,
                    precedence: null
                });
                return d = (i.ownerDocument || i).createElement("style"),
                pt(d),
                Et(d, "style", g),
                _c(d, c.precedence, i),
                s.instance = d;
            case "stylesheet":
                g = hl(c.href);
                var v = i.querySelector(Os(g));
                if (v)
                    return s.state.loading |= 4,
                    s.instance = v,
                    pt(v),
                    v;
                d = av(c),
                (g = xn.get(g)) && sp(d, g),
                v = (i.ownerDocument || i).createElement("link"),
                pt(v);
                var x = v;
                return x._p = new Promise(function(M, N) {
                    x.onload = M,
                    x.onerror = N
                }
                ),
                Et(v, "link", d),
                s.state.loading |= 4,
                _c(v, c.precedence, i),
                s.instance = v;
            case "script":
                return v = pl(c.src),
                (g = i.querySelector(Ds(v))) ? (s.instance = g,
                pt(g),
                g) : (d = c,
                (g = xn.get(v)) && (d = m({}, c),
                ap(d, g)),
                i = i.ownerDocument || i,
                g = i.createElement("script"),
                pt(g),
                Et(g, "link", d),
                i.head.appendChild(g),
                s.instance = g);
            case "void":
                return null;
            default:
                throw Error(r(443, s.type))
            }
        else
            s.type === "stylesheet" && (s.state.loading & 4) === 0 && (d = s.instance,
            s.state.loading |= 4,
            _c(d, c.precedence, i));
        return s.instance
    }
    function _c(i, s, c) {
        for (var d = c.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), g = d.length ? d[d.length - 1] : null, v = g, x = 0; x < d.length; x++) {
            var M = d[x];
            if (M.dataset.precedence === s)
                v = M;
            else if (v !== g)
                break
        }
        v ? v.parentNode.insertBefore(i, v.nextSibling) : (s = c.nodeType === 9 ? c.head : c,
        s.insertBefore(i, s.firstChild))
    }
    function sp(i, s) {
        i.crossOrigin == null && (i.crossOrigin = s.crossOrigin),
        i.referrerPolicy == null && (i.referrerPolicy = s.referrerPolicy),
        i.title == null && (i.title = s.title)
    }
    function ap(i, s) {
        i.crossOrigin == null && (i.crossOrigin = s.crossOrigin),
        i.referrerPolicy == null && (i.referrerPolicy = s.referrerPolicy),
        i.integrity == null && (i.integrity = s.integrity)
    }
    var Bc = null;
    function uv(i, s, c) {
        if (Bc === null) {
            var d = new Map
              , g = Bc = new Map;
            g.set(c, d)
        } else
            g = Bc,
            d = g.get(c),
            d || (d = new Map,
            g.set(c, d));
        if (d.has(i))
            return d;
        for (d.set(i, null),
        c = c.getElementsByTagName(i),
        g = 0; g < c.length; g++) {
            var v = c[g];
            if (!(v[Gl] || v[Ct] || i === "link" && v.getAttribute("rel") === "stylesheet") && v.namespaceURI !== "http://www.w3.org/2000/svg") {
                var x = v.getAttribute(s) || "";
                x = i + x;
                var M = d.get(x);
                M ? M.push(v) : d.set(x, [v])
            }
        }
        return d
    }
    function fv(i, s, c) {
        i = i.ownerDocument || i,
        i.head.insertBefore(c, s === "title" ? i.querySelector("head > title") : null)
    }
    function B9(i, s, c) {
        if (c === 1 || s.itemProp != null)
            return !1;
        switch (i) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof s.precedence != "string" || typeof s.href != "string" || s.href === "")
                break;
            return !0;
        case "link":
            if (typeof s.rel != "string" || typeof s.href != "string" || s.href === "" || s.onLoad || s.onError)
                break;
            return s.rel === "stylesheet" ? (i = s.disabled,
            typeof s.precedence == "string" && i == null) : !0;
        case "script":
            if (s.async && typeof s.async != "function" && typeof s.async != "symbol" && !s.onLoad && !s.onError && s.src && typeof s.src == "string")
                return !0
        }
        return !1
    }
    function dv(i) {
        return !(i.type === "stylesheet" && (i.state.loading & 3) === 0)
    }
    function j9(i, s, c, d) {
        if (c.type === "stylesheet" && (typeof d.media != "string" || matchMedia(d.media).matches !== !1) && (c.state.loading & 4) === 0) {
            if (c.instance === null) {
                var g = hl(d.href)
                  , v = s.querySelector(Os(g));
                if (v) {
                    s = v._p,
                    s !== null && typeof s == "object" && typeof s.then == "function" && (i.count++,
                    i = jc.bind(i),
                    s.then(i, i)),
                    c.state.loading |= 4,
                    c.instance = v,
                    pt(v);
                    return
                }
                v = s.ownerDocument || s,
                d = av(d),
                (g = xn.get(g)) && sp(d, g),
                v = v.createElement("link"),
                pt(v);
                var x = v;
                x._p = new Promise(function(M, N) {
                    x.onload = M,
                    x.onerror = N
                }
                ),
                Et(v, "link", d),
                c.instance = v
            }
            i.stylesheets === null && (i.stylesheets = new Map),
            i.stylesheets.set(c, s),
            (s = c.state.preload) && (c.state.loading & 3) === 0 && (i.count++,
            c = jc.bind(i),
            s.addEventListener("load", c),
            s.addEventListener("error", c))
        }
    }
    var cp = 0;
    function H9(i, s) {
        return i.stylesheets && i.count === 0 && Ic(i, i.stylesheets),
        0 < i.count || 0 < i.imgCount ? function(c) {
            var d = setTimeout(function() {
                if (i.stylesheets && Ic(i, i.stylesheets),
                i.unsuspend) {
                    var v = i.unsuspend;
                    i.unsuspend = null,
                    v()
                }
            }, 6e4 + s);
            0 < i.imgBytes && cp === 0 && (cp = 62500 * v9());
            var g = setTimeout(function() {
                if (i.waitingForImages = !1,
                i.count === 0 && (i.stylesheets && Ic(i, i.stylesheets),
                i.unsuspend)) {
                    var v = i.unsuspend;
                    i.unsuspend = null,
                    v()
                }
            }, (i.imgBytes > cp ? 50 : 800) + s);
            return i.unsuspend = c,
            function() {
                i.unsuspend = null,
                clearTimeout(d),
                clearTimeout(g)
            }
        }
        : null
    }
    function jc() {
        if (this.count--,
        this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
            if (this.stylesheets)
                Ic(this, this.stylesheets);
            else if (this.unsuspend) {
                var i = this.unsuspend;
                this.unsuspend = null,
                i()
            }
        }
    }
    var Hc = null;
    function Ic(i, s) {
        i.stylesheets = null,
        i.unsuspend !== null && (i.count++,
        Hc = new Map,
        s.forEach(I9, i),
        Hc = null,
        jc.call(i))
    }
    function I9(i, s) {
        if (!(s.state.loading & 4)) {
            var c = Hc.get(i);
            if (c)
                var d = c.get(null);
            else {
                c = new Map,
                Hc.set(i, c);
                for (var g = i.querySelectorAll("link[data-precedence],style[data-precedence]"), v = 0; v < g.length; v++) {
                    var x = g[v];
                    (x.nodeName === "LINK" || x.getAttribute("media") !== "not all") && (c.set(x.dataset.precedence, x),
                    d = x)
                }
                d && c.set(null, d)
            }
            g = s.instance,
            x = g.getAttribute("data-precedence"),
            v = c.get(x) || d,
            v === d && c.set(null, g),
            c.set(x, g),
            this.count++,
            d = jc.bind(this),
            g.addEventListener("load", d),
            g.addEventListener("error", d),
            v ? v.parentNode.insertBefore(g, v.nextSibling) : (i = i.nodeType === 9 ? i.head : i,
            i.insertBefore(g, i.firstChild)),
            s.state.loading |= 4
        }
    }
    var Ls = {
        $$typeof: O,
        Provider: null,
        Consumer: null,
        _currentValue: q,
        _currentValue2: q,
        _threadCount: 0
    };
    function V9(i, s, c, d, g, v, x, M, N) {
        this.tag = 1,
        this.containerInfo = i,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = id(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = id(0),
        this.hiddenUpdates = id(null),
        this.identifierPrefix = d,
        this.onUncaughtError = g,
        this.onCaughtError = v,
        this.onRecoverableError = x,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = N,
        this.incompleteTransitions = new Map
    }
    function hv(i, s, c, d, g, v, x, M, N, I, K, Y) {
        return i = new V9(i,s,c,x,N,I,K,Y,M),
        s = 1,
        v === !0 && (s |= 24),
        v = nn(3, null, null, s),
        i.current = v,
        v.stateNode = i,
        s = Pd(),
        s.refCount++,
        i.pooledCache = s,
        s.refCount++,
        v.memoizedState = {
            element: d,
            isDehydrated: c,
            cache: s
        },
        Kd(v),
        i
    }
    function pv(i) {
        return i ? (i = Fo,
        i) : Fo
    }
    function mv(i, s, c, d, g, v) {
        g = pv(g),
        d.context === null ? d.context = g : d.pendingContext = g,
        d = Fr(s),
        d.payload = {
            element: c
        },
        v = v === void 0 ? null : v,
        v !== null && (d.callback = v),
        c = Kr(i, d, s),
        c !== null && (Gt(c, i, s),
        fs(c, i, s))
    }
    function gv(i, s) {
        if (i = i.memoizedState,
        i !== null && i.dehydrated !== null) {
            var c = i.retryLane;
            i.retryLane = c !== 0 && c < s ? c : s
        }
    }
    function up(i, s) {
        gv(i, s),
        (i = i.alternate) && gv(i, s)
    }
    function yv(i) {
        if (i.tag === 13 || i.tag === 31) {
            var s = Fi(i, 67108864);
            s !== null && Gt(s, i, 67108864),
            up(i, 67108864)
        }
    }
    function vv(i) {
        if (i.tag === 13 || i.tag === 31) {
            var s = an();
            s = od(s);
            var c = Fi(i, s);
            c !== null && Gt(c, i, s),
            up(i, s)
        }
    }
    var Vc = !0;
    function U9(i, s, c, d) {
        var g = j.T;
        j.T = null;
        var v = P.p;
        try {
            P.p = 2,
            fp(i, s, c, d)
        } finally {
            P.p = v,
            j.T = g
        }
    }
    function P9(i, s, c, d) {
        var g = j.T;
        j.T = null;
        var v = P.p;
        try {
            P.p = 8,
            fp(i, s, c, d)
        } finally {
            P.p = v,
            j.T = g
        }
    }
    function fp(i, s, c, d) {
        if (Vc) {
            var g = dp(d);
            if (g === null)
                Xh(i, s, d, Uc, c),
                Cv(i, d);
            else if ($9(g, i, s, c, d))
                d.stopPropagation();
            else if (Cv(i, d),
            s & 4 && -1 < q9.indexOf(i)) {
                for (; g !== null; ) {
                    var v = zo(g);
                    if (v !== null)
                        switch (v.tag) {
                        case 3:
                            if (v = v.stateNode,
                            v.current.memoizedState.isDehydrated) {
                                var x = Vi(v.pendingLanes);
                                if (x !== 0) {
                                    var M = v;
                                    for (M.pendingLanes |= 2,
                                    M.entangledLanes |= 2; x; ) {
                                        var N = 1 << 31 - en(x);
                                        M.entanglements[1] |= N,
                                        x &= ~N
                                    }
                                    Un(v),
                                    (De & 6) === 0 && (wc = Jt() + 500,
                                    Ms(0))
                                }
                            }
                            break;
                        case 31:
                        case 13:
                            M = Fi(v, 2),
                            M !== null && Gt(M, v, 2),
                            Tc(),
                            up(v, 2)
                        }
                    if (v = dp(d),
                    v === null && Xh(i, s, d, Uc, c),
                    v === g)
                        break;
                    g = v
                }
                g !== null && d.stopPropagation()
            } else
                Xh(i, s, d, null, c)
        }
    }
    function dp(i) {
        return i = pd(i),
        hp(i)
    }
    var Uc = null;
    function hp(i) {
        if (Uc = null,
        i = Lo(i),
        i !== null) {
            var s = l(i);
            if (s === null)
                i = null;
            else {
                var c = s.tag;
                if (c === 13) {
                    if (i = a(s),
                    i !== null)
                        return i;
                    i = null
                } else if (c === 31) {
                    if (i = u(s),
                    i !== null)
                        return i;
                    i = null
                } else if (c === 3) {
                    if (s.stateNode.current.memoizedState.isDehydrated)
                        return s.tag === 3 ? s.stateNode.containerInfo : null;
                    i = null
                } else
                    s !== i && (i = null)
            }
        }
        return Uc = i,
        null
    }
    function bv(i) {
        switch (i) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (A7()) {
            case Mg:
                return 2;
            case Ag:
                return 8;
            case Ra:
            case N7:
                return 32;
            case Ng:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var pp = !1
      , ri = null
      , ii = null
      , oi = null
      , zs = new Map
      , _s = new Map
      , li = []
      , q9 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function Cv(i, s) {
        switch (i) {
        case "focusin":
        case "focusout":
            ri = null;
            break;
        case "dragenter":
        case "dragleave":
            ii = null;
            break;
        case "mouseover":
        case "mouseout":
            oi = null;
            break;
        case "pointerover":
        case "pointerout":
            zs.delete(s.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            _s.delete(s.pointerId)
        }
    }
    function Bs(i, s, c, d, g, v) {
        return i === null || i.nativeEvent !== v ? (i = {
            blockedOn: s,
            domEventName: c,
            eventSystemFlags: d,
            nativeEvent: v,
            targetContainers: [g]
        },
        s !== null && (s = zo(s),
        s !== null && yv(s)),
        i) : (i.eventSystemFlags |= d,
        s = i.targetContainers,
        g !== null && s.indexOf(g) === -1 && s.push(g),
        i)
    }
    function $9(i, s, c, d, g) {
        switch (s) {
        case "focusin":
            return ri = Bs(ri, i, s, c, d, g),
            !0;
        case "dragenter":
            return ii = Bs(ii, i, s, c, d, g),
            !0;
        case "mouseover":
            return oi = Bs(oi, i, s, c, d, g),
            !0;
        case "pointerover":
            var v = g.pointerId;
            return zs.set(v, Bs(zs.get(v) || null, i, s, c, d, g)),
            !0;
        case "gotpointercapture":
            return v = g.pointerId,
            _s.set(v, Bs(_s.get(v) || null, i, s, c, d, g)),
            !0
        }
        return !1
    }
    function Sv(i) {
        var s = Lo(i.target);
        if (s !== null) {
            var c = l(s);
            if (c !== null) {
                if (s = c.tag,
                s === 13) {
                    if (s = a(c),
                    s !== null) {
                        i.blockedOn = s,
                        _g(i.priority, function() {
                            vv(c)
                        });
                        return
                    }
                } else if (s === 31) {
                    if (s = u(c),
                    s !== null) {
                        i.blockedOn = s,
                        _g(i.priority, function() {
                            vv(c)
                        });
                        return
                    }
                } else if (s === 3 && c.stateNode.current.memoizedState.isDehydrated) {
                    i.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
                    return
                }
            }
        }
        i.blockedOn = null
    }
    function Pc(i) {
        if (i.blockedOn !== null)
            return !1;
        for (var s = i.targetContainers; 0 < s.length; ) {
            var c = dp(i.nativeEvent);
            if (c === null) {
                c = i.nativeEvent;
                var d = new c.constructor(c.type,c);
                hd = d,
                c.target.dispatchEvent(d),
                hd = null
            } else
                return s = zo(c),
                s !== null && yv(s),
                i.blockedOn = c,
                !1;
            s.shift()
        }
        return !0
    }
    function xv(i, s, c) {
        Pc(i) && c.delete(s)
    }
    function F9() {
        pp = !1,
        ri !== null && Pc(ri) && (ri = null),
        ii !== null && Pc(ii) && (ii = null),
        oi !== null && Pc(oi) && (oi = null),
        zs.forEach(xv),
        _s.forEach(xv)
    }
    function qc(i, s) {
        i.blockedOn === s && (i.blockedOn = null,
        pp || (pp = !0,
        t.unstable_scheduleCallback(t.unstable_NormalPriority, F9)))
    }
    var $c = null;
    function wv(i) {
        $c !== i && ($c = i,
        t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
            $c === i && ($c = null);
            for (var s = 0; s < i.length; s += 3) {
                var c = i[s]
                  , d = i[s + 1]
                  , g = i[s + 2];
                if (typeof d != "function") {
                    if (hp(d || c) === null)
                        continue;
                    break
                }
                var v = zo(c);
                v !== null && (i.splice(s, 3),
                s -= 3,
                dh(v, {
                    pending: !0,
                    data: g,
                    method: c.method,
                    action: d
                }, d, g))
            }
        }))
    }
    function ml(i) {
        function s(N) {
            return qc(N, i)
        }
        ri !== null && qc(ri, i),
        ii !== null && qc(ii, i),
        oi !== null && qc(oi, i),
        zs.forEach(s),
        _s.forEach(s);
        for (var c = 0; c < li.length; c++) {
            var d = li[c];
            d.blockedOn === i && (d.blockedOn = null)
        }
        for (; 0 < li.length && (c = li[0],
        c.blockedOn === null); )
            Sv(c),
            c.blockedOn === null && li.shift();
        if (c = (i.ownerDocument || i).$$reactFormReplay,
        c != null)
            for (d = 0; d < c.length; d += 3) {
                var g = c[d]
                  , v = c[d + 1]
                  , x = g[Ut] || null;
                if (typeof v == "function")
                    x || wv(c);
                else if (x) {
                    var M = null;
                    if (v && v.hasAttribute("formAction")) {
                        if (g = v,
                        x = v[Ut] || null)
                            M = x.formAction;
                        else if (hp(g) !== null)
                            continue
                    } else
                        M = x.action;
                    typeof M == "function" ? c[d + 1] = M : (c.splice(d, 3),
                    d -= 3),
                    wv(c)
                }
            }
    }
    function Ev() {
        function i(v) {
            v.canIntercept && v.info === "react-transition" && v.intercept({
                handler: function() {
                    return new Promise(function(x) {
                        return g = x
                    }
                    )
                },
                focusReset: "manual",
                scroll: "manual"
            })
        }
        function s() {
            g !== null && (g(),
            g = null),
            d || setTimeout(c, 20)
        }
        function c() {
            if (!d && !navigation.transition) {
                var v = navigation.currentEntry;
                v && v.url != null && navigation.navigate(v.url, {
                    state: v.getState(),
                    info: "react-transition",
                    history: "replace"
                })
            }
        }
        if (typeof navigation == "object") {
            var d = !1
              , g = null;
            return navigation.addEventListener("navigate", i),
            navigation.addEventListener("navigatesuccess", s),
            navigation.addEventListener("navigateerror", s),
            setTimeout(c, 100),
            function() {
                d = !0,
                navigation.removeEventListener("navigate", i),
                navigation.removeEventListener("navigatesuccess", s),
                navigation.removeEventListener("navigateerror", s),
                g !== null && (g(),
                g = null)
            }
        }
    }
    function mp(i) {
        this._internalRoot = i
    }
    Fc.prototype.render = mp.prototype.render = function(i) {
        var s = this._internalRoot;
        if (s === null)
            throw Error(r(409));
        var c = s.current
          , d = an();
        mv(c, d, i, s, null, null)
    }
    ,
    Fc.prototype.unmount = mp.prototype.unmount = function() {
        var i = this._internalRoot;
        if (i !== null) {
            this._internalRoot = null;
            var s = i.containerInfo;
            mv(i.current, 2, null, i, null, null),
            Tc(),
            s[Do] = null
        }
    }
    ;
    function Fc(i) {
        this._internalRoot = i
    }
    Fc.prototype.unstable_scheduleHydration = function(i) {
        if (i) {
            var s = zg();
            i = {
                blockedOn: null,
                target: i,
                priority: s
            };
            for (var c = 0; c < li.length && s !== 0 && s < li[c].priority; c++)
                ;
            li.splice(c, 0, i),
            c === 0 && Sv(i)
        }
    }
    ;
    var Tv = e.version;
    if (Tv !== "19.2.4")
        throw Error(r(527, Tv, "19.2.4"));
    P.findDOMNode = function(i) {
        var s = i._reactInternals;
        if (s === void 0)
            throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","),
            Error(r(268, i)));
        return i = h(s),
        i = i !== null ? p(i) : null,
        i = i === null ? null : i.stateNode,
        i
    }
    ;
    var K9 = {
        bundleType: 0,
        version: "19.2.4",
        rendererPackageName: "react-dom",
        currentDispatcherRef: j,
        reconcilerVersion: "19.2.4"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var Kc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!Kc.isDisabled && Kc.supportsFiber)
            try {
                $l = Kc.inject(K9),
                Qt = Kc
            } catch {}
    }
    return Hs.createRoot = function(i, s) {
        if (!o(i))
            throw Error(r(299));
        var c = !1
          , d = ""
          , g = Dy
          , v = Ly
          , x = zy;
        return s != null && (s.unstable_strictMode === !0 && (c = !0),
        s.identifierPrefix !== void 0 && (d = s.identifierPrefix),
        s.onUncaughtError !== void 0 && (g = s.onUncaughtError),
        s.onCaughtError !== void 0 && (v = s.onCaughtError),
        s.onRecoverableError !== void 0 && (x = s.onRecoverableError)),
        s = hv(i, 1, !1, null, null, c, d, null, g, v, x, Ev),
        i[Do] = s.current,
        Wh(i),
        new mp(s)
    }
    ,
    Hs.hydrateRoot = function(i, s, c) {
        if (!o(i))
            throw Error(r(299));
        var d = !1
          , g = ""
          , v = Dy
          , x = Ly
          , M = zy
          , N = null;
        return c != null && (c.unstable_strictMode === !0 && (d = !0),
        c.identifierPrefix !== void 0 && (g = c.identifierPrefix),
        c.onUncaughtError !== void 0 && (v = c.onUncaughtError),
        c.onCaughtError !== void 0 && (x = c.onCaughtError),
        c.onRecoverableError !== void 0 && (M = c.onRecoverableError),
        c.formState !== void 0 && (N = c.formState)),
        s = hv(i, 1, !0, s, c ?? null, d, g, N, v, x, M, Ev),
        s.context = pv(null),
        c = s.current,
        d = an(),
        d = od(d),
        g = Fr(d),
        g.callback = null,
        Kr(c, g, d),
        c = d,
        s.current.lanes = c,
        Kl(s, c),
        Un(s),
        i[Do] = s.current,
        Wh(i),
        new Fc(s)
    }
    ,
    Hs.version = "19.2.4",
    Hs
}
var _v;
function nE() {
    if (_v)
        return vp.exports;
    _v = 1;
    function t() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)
            } catch (e) {
                console.error(e)
            }
    }
    return t(),
    vp.exports = tE(),
    vp.exports
}
var rE = nE()
  , Mf = vS();
const bS = yS(Mf);
var xp = {
    exports: {}
}
  , wp = {};
var Bv;
function iE() {
    if (Bv)
        return wp;
    Bv = 1;
    var t = Sa();
    function e(m, y) {
        return m === y && (m !== 0 || 1 / m === 1 / y) || m !== m && y !== y
    }
    var n = typeof Object.is == "function" ? Object.is : e
      , r = t.useState
      , o = t.useEffect
      , l = t.useLayoutEffect
      , a = t.useDebugValue;
    function u(m, y) {
        var b = y()
          , C = r({
            inst: {
                value: b,
                getSnapshot: y
            }
        })
          , S = C[0].inst
          , w = C[1];
        return l(function() {
            S.value = b,
            S.getSnapshot = y,
            f(S) && w({
                inst: S
            })
        }, [m, b, y]),
        o(function() {
            return f(S) && w({
                inst: S
            }),
            m(function() {
                f(S) && w({
                    inst: S
                })
            })
        }, [m]),
        a(b),
        b
    }
    function f(m) {
        var y = m.getSnapshot;
        m = m.value;
        try {
            var b = y();
            return !n(m, b)
        } catch {
            return !0
        }
    }
    function h(m, y) {
        return y()
    }
    var p = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? h : u;
    return wp.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : p,
    wp
}
var jv;
function CS() {
    return jv || (jv = 1,
    xp.exports = iE()),
    xp.exports
}
var SS = CS();
function Tt(t) {
    this.content = t
}
Tt.prototype = {
    constructor: Tt,
    find: function(t) {
        for (var e = 0; e < this.content.length; e += 2)
            if (this.content[e] === t)
                return e;
        return -1
    },
    get: function(t) {
        var e = this.find(t);
        return e == -1 ? void 0 : this.content[e + 1]
    },
    update: function(t, e, n) {
        var r = n && n != t ? this.remove(n) : this
          , o = r.find(t)
          , l = r.content.slice();
        return o == -1 ? l.push(n || t, e) : (l[o + 1] = e,
        n && (l[o] = n)),
        new Tt(l)
    },
    remove: function(t) {
        var e = this.find(t);
        if (e == -1)
            return this;
        var n = this.content.slice();
        return n.splice(e, 2),
        new Tt(n)
    },
    addToStart: function(t, e) {
        return new Tt([t, e].concat(this.remove(t).content))
    },
    addToEnd: function(t, e) {
        var n = this.remove(t).content.slice();
        return n.push(t, e),
        new Tt(n)
    },
    addBefore: function(t, e, n) {
        var r = this.remove(e)
          , o = r.content.slice()
          , l = r.find(t);
        return o.splice(l == -1 ? o.length : l, 0, e, n),
        new Tt(o)
    },
    forEach: function(t) {
        for (var e = 0; e < this.content.length; e += 2)
            t(this.content[e], this.content[e + 1])
    },
    prepend: function(t) {
        return t = Tt.from(t),
        t.size ? new Tt(t.content.concat(this.subtract(t).content)) : this
    },
    append: function(t) {
        return t = Tt.from(t),
        t.size ? new Tt(this.subtract(t).content.concat(t.content)) : this
    },
    subtract: function(t) {
        var e = this;
        t = Tt.from(t);
        for (var n = 0; n < t.content.length; n += 2)
            e = e.remove(t.content[n]);
        return e
    },
    toObject: function() {
        var t = {};
        return this.forEach(function(e, n) {
            t[e] = n
        }),
        t
    },
    get size() {
        return this.content.length >> 1
    }
};
Tt.from = function(t) {
    if (t instanceof Tt)
        return t;
    var e = [];
    if (t)
        for (var n in t)
            e.push(n, t[n]);
    return new Tt(e)
}
;
function xS(t, e, n) {
    for (let r = 0; ; r++) {
        if (r == t.childCount || r == e.childCount)
            return t.childCount == e.childCount ? null : n;
        let o = t.child(r)
          , l = e.child(r);
        if (o == l) {
            n += o.nodeSize;
            continue
        }
        if (!o.sameMarkup(l))
            return n;
        if (o.isText && o.text != l.text) {
            for (let a = 0; o.text[a] == l.text[a]; a++)
                n++;
            return n
        }
        if (o.content.size || l.content.size) {
            let a = xS(o.content, l.content, n + 1);
            if (a != null)
                return a
        }
        n += o.nodeSize
    }
}
function wS(t, e, n, r) {
    for (let o = t.childCount, l = e.childCount; ; ) {
        if (o == 0 || l == 0)
            return o == l ? null : {
                a: n,
                b: r
            };
        let a = t.child(--o)
          , u = e.child(--l)
          , f = a.nodeSize;
        if (a == u) {
            n -= f,
            r -= f;
            continue
        }
        if (!a.sameMarkup(u))
            return {
                a: n,
                b: r
            };
        if (a.isText && a.text != u.text) {
            let h = 0
              , p = Math.min(a.text.length, u.text.length);
            for (; h < p && a.text[a.text.length - h - 1] == u.text[u.text.length - h - 1]; )
                h++,
                n--,
                r--;
            return {
                a: n,
                b: r
            }
        }
        if (a.content.size || u.content.size) {
            let h = wS(a.content, u.content, n - 1, r - 1);
            if (h)
                return h
        }
        n -= f,
        r -= f
    }
}
class Z {
    constructor(e, n) {
        if (this.content = e,
        this.size = n || 0,
        n == null)
            for (let r = 0; r < e.length; r++)
                this.size += e[r].nodeSize
    }
    nodesBetween(e, n, r, o=0, l) {
        for (let a = 0, u = 0; u < n; a++) {
            let f = this.content[a]
              , h = u + f.nodeSize;
            if (h > e && r(f, o + u, l || null, a) !== !1 && f.content.size) {
                let p = u + 1;
                f.nodesBetween(Math.max(0, e - p), Math.min(f.content.size, n - p), r, o + p)
            }
            u = h
        }
    }
    descendants(e) {
        this.nodesBetween(0, this.size, e)
    }
    textBetween(e, n, r, o) {
        let l = ""
          , a = !0;
        return this.nodesBetween(e, n, (u, f) => {
            let h = u.isText ? u.text.slice(Math.max(e, f) - f, n - f) : u.isLeaf ? o ? typeof o == "function" ? o(u) : o : u.type.spec.leafText ? u.type.spec.leafText(u) : "" : "";
            u.isBlock && (u.isLeaf && h || u.isTextblock) && r && (a ? a = !1 : l += r),
            l += h
        }
        , 0),
        l
    }
    append(e) {
        if (!e.size)
            return this;
        if (!this.size)
            return e;
        let n = this.lastChild
          , r = e.firstChild
          , o = this.content.slice()
          , l = 0;
        for (n.isText && n.sameMarkup(r) && (o[o.length - 1] = n.withText(n.text + r.text),
        l = 1); l < e.content.length; l++)
            o.push(e.content[l]);
        return new Z(o,this.size + e.size)
    }
    cut(e, n=this.size) {
        if (e == 0 && n == this.size)
            return this;
        let r = []
          , o = 0;
        if (n > e)
            for (let l = 0, a = 0; a < n; l++) {
                let u = this.content[l]
                  , f = a + u.nodeSize;
                f > e && ((a < e || f > n) && (u.isText ? u = u.cut(Math.max(0, e - a), Math.min(u.text.length, n - a)) : u = u.cut(Math.max(0, e - a - 1), Math.min(u.content.size, n - a - 1))),
                r.push(u),
                o += u.nodeSize),
                a = f
            }
        return new Z(r,o)
    }
    cutByIndex(e, n) {
        return e == n ? Z.empty : e == 0 && n == this.content.length ? this : new Z(this.content.slice(e, n))
    }
    replaceChild(e, n) {
        let r = this.content[e];
        if (r == n)
            return this;
        let o = this.content.slice()
          , l = this.size + n.nodeSize - r.nodeSize;
        return o[e] = n,
        new Z(o,l)
    }
    addToStart(e) {
        return new Z([e].concat(this.content),this.size + e.nodeSize)
    }
    addToEnd(e) {
        return new Z(this.content.concat(e),this.size + e.nodeSize)
    }
    eq(e) {
        if (this.content.length != e.content.length)
            return !1;
        for (let n = 0; n < this.content.length; n++)
            if (!this.content[n].eq(e.content[n]))
                return !1;
        return !0
    }
    get firstChild() {
        return this.content.length ? this.content[0] : null
    }
    get lastChild() {
        return this.content.length ? this.content[this.content.length - 1] : null
    }
    get childCount() {
        return this.content.length
    }
    child(e) {
        let n = this.content[e];
        if (!n)
            throw new RangeError("Index " + e + " out of range for " + this);
        return n
    }
    maybeChild(e) {
        return this.content[e] || null
    }
    forEach(e) {
        for (let n = 0, r = 0; n < this.content.length; n++) {
            let o = this.content[n];
            e(o, r, n),
            r += o.nodeSize
        }
    }
    findDiffStart(e, n=0) {
        return xS(this, e, n)
    }
    findDiffEnd(e, n=this.size, r=e.size) {
        return wS(this, e, n, r)
    }
    findIndex(e) {
        if (e == 0)
            return Gc(0, e);
        if (e == this.size)
            return Gc(this.content.length, e);
        if (e > this.size || e < 0)
            throw new RangeError(`Position ${e} outside of fragment (${this})`);
        for (let n = 0, r = 0; ; n++) {
            let o = this.child(n)
              , l = r + o.nodeSize;
            if (l >= e)
                return l == e ? Gc(n + 1, l) : Gc(n, r);
            r = l
        }
    }
    toString() {
        return "<" + this.toStringInner() + ">"
    }
    toStringInner() {
        return this.content.join(", ")
    }
    toJSON() {
        return this.content.length ? this.content.map(e => e.toJSON()) : null
    }
    static fromJSON(e, n) {
        if (!n)
            return Z.empty;
        if (!Array.isArray(n))
            throw new RangeError("Invalid input for Fragment.fromJSON");
        return new Z(n.map(e.nodeFromJSON))
    }
    static fromArray(e) {
        if (!e.length)
            return Z.empty;
        let n, r = 0;
        for (let o = 0; o < e.length; o++) {
            let l = e[o];
            r += l.nodeSize,
            o && l.isText && e[o - 1].sameMarkup(l) ? (n || (n = e.slice(0, o)),
            n[n.length - 1] = l.withText(n[n.length - 1].text + l.text)) : n && n.push(l)
        }
        return new Z(n || e,r)
    }
    static from(e) {
        if (!e)
            return Z.empty;
        if (e instanceof Z)
            return e;
        if (Array.isArray(e))
            return this.fromArray(e);
        if (e.attrs)
            return new Z([e],e.nodeSize);
        throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
    }
}
Z.empty = new Z([],0);
const Ep = {
    index: 0,
    offset: 0
};
function Gc(t, e) {
    return Ep.index = t,
    Ep.offset = e,
    Ep
}
function Au(t, e) {
    if (t === e)
        return !0;
    if (!(t && typeof t == "object") || !(e && typeof e == "object"))
        return !1;
    let n = Array.isArray(t);
    if (Array.isArray(e) != n)
        return !1;
    if (n) {
        if (t.length != e.length)
            return !1;
        for (let r = 0; r < t.length; r++)
            if (!Au(t[r], e[r]))
                return !1
    } else {
        for (let r in t)
            if (!(r in e) || !Au(t[r], e[r]))
                return !1;
        for (let r in e)
            if (!(r in t))
                return !1
    }
    return !0
}
let Ve = class gm {
    constructor(e, n) {
        this.type = e,
        this.attrs = n
    }
    addToSet(e) {
        let n, r = !1;
        for (let o = 0; o < e.length; o++) {
            let l = e[o];
            if (this.eq(l))
                return e;
            if (this.type.excludes(l.type))
                n || (n = e.slice(0, o));
            else {
                if (l.type.excludes(this.type))
                    return e;
                !r && l.type.rank > this.type.rank && (n || (n = e.slice(0, o)),
                n.push(this),
                r = !0),
                n && n.push(l)
            }
        }
        return n || (n = e.slice()),
        r || n.push(this),
        n
    }
    removeFromSet(e) {
        for (let n = 0; n < e.length; n++)
            if (this.eq(e[n]))
                return e.slice(0, n).concat(e.slice(n + 1));
        return e
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++)
            if (this.eq(e[n]))
                return !0;
        return !1
    }
    eq(e) {
        return this == e || this.type == e.type && Au(this.attrs, e.attrs)
    }
    toJSON() {
        let e = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break
        }
        return e
    }
    static fromJSON(e, n) {
        if (!n)
            throw new RangeError("Invalid input for Mark.fromJSON");
        let r = e.marks[n.type];
        if (!r)
            throw new RangeError(`There is no mark type ${n.type} in this schema`);
        let o = r.create(n.attrs);
        return r.checkAttrs(o.attrs),
        o
    }
    static sameSet(e, n) {
        if (e == n)
            return !0;
        if (e.length != n.length)
            return !1;
        for (let r = 0; r < e.length; r++)
            if (!e[r].eq(n[r]))
                return !1;
        return !0
    }
    static setFrom(e) {
        if (!e || Array.isArray(e) && e.length == 0)
            return gm.none;
        if (e instanceof gm)
            return [e];
        let n = e.slice();
        return n.sort( (r, o) => r.type.rank - o.type.rank),
        n
    }
}
;
Ve.none = [];
class Nu extends Error {
}
class te {
    constructor(e, n, r) {
        this.content = e,
        this.openStart = n,
        this.openEnd = r
    }
    get size() {
        return this.content.size - this.openStart - this.openEnd
    }
    insertAt(e, n) {
        let r = TS(this.content, e + this.openStart, n);
        return r && new te(r,this.openStart,this.openEnd)
    }
    removeBetween(e, n) {
        return new te(ES(this.content, e + this.openStart, n + this.openStart),this.openStart,this.openEnd)
    }
    eq(e) {
        return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd
    }
    toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")"
    }
    toJSON() {
        if (!this.content.size)
            return null;
        let e = {
            content: this.content.toJSON()
        };
        return this.openStart > 0 && (e.openStart = this.openStart),
        this.openEnd > 0 && (e.openEnd = this.openEnd),
        e
    }
    static fromJSON(e, n) {
        if (!n)
            return te.empty;
        let r = n.openStart || 0
          , o = n.openEnd || 0;
        if (typeof r != "number" || typeof o != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
        return new te(Z.fromJSON(e, n.content),r,o)
    }
    static maxOpen(e, n=!0) {
        let r = 0
          , o = 0;
        for (let l = e.firstChild; l && !l.isLeaf && (n || !l.type.spec.isolating); l = l.firstChild)
            r++;
        for (let l = e.lastChild; l && !l.isLeaf && (n || !l.type.spec.isolating); l = l.lastChild)
            o++;
        return new te(e,r,o)
    }
}
te.empty = new te(Z.empty,0,0);
function ES(t, e, n) {
    let {index: r, offset: o} = t.findIndex(e)
      , l = t.maybeChild(r)
      , {index: a, offset: u} = t.findIndex(n);
    if (o == e || l.isText) {
        if (u != n && !t.child(a).isText)
            throw new RangeError("Removing non-flat range");
        return t.cut(0, e).append(t.cut(n))
    }
    if (r != a)
        throw new RangeError("Removing non-flat range");
    return t.replaceChild(r, l.copy(ES(l.content, e - o - 1, n - o - 1)))
}
function TS(t, e, n, r) {
    let {index: o, offset: l} = t.findIndex(e)
      , a = t.maybeChild(o);
    if (l == e || a.isText)
        return r && !r.canReplace(o, o, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
    let u = TS(a.content, e - l - 1, n, a);
    return u && t.replaceChild(o, a.copy(u))
}
function oE(t, e, n) {
    if (n.openStart > t.depth)
        throw new Nu("Inserted content deeper than insertion position");
    if (t.depth - n.openStart != e.depth - n.openEnd)
        throw new Nu("Inconsistent open depths");
    return kS(t, e, n, 0)
}
function kS(t, e, n, r) {
    let o = t.index(r)
      , l = t.node(r);
    if (o == e.index(r) && r < t.depth - n.openStart) {
        let a = kS(t, e, n, r + 1);
        return l.copy(l.content.replaceChild(o, a))
    } else if (n.content.size)
        if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
            let a = t.parent
              , u = a.content;
            return po(a, u.cut(0, t.parentOffset).append(n.content).append(u.cut(e.parentOffset)))
        } else {
            let {start: a, end: u} = lE(n, t);
            return po(l, AS(t, a, u, e, r))
        }
    else
        return po(l, Ru(t, e, r))
}
function MS(t, e) {
    if (!e.type.compatibleContent(t.type))
        throw new Nu("Cannot join " + e.type.name + " onto " + t.type.name)
}
function ym(t, e, n) {
    let r = t.node(n);
    return MS(r, e.node(n)),
    r
}
function ho(t, e) {
    let n = e.length - 1;
    n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t)
}
function Js(t, e, n, r) {
    let o = (e || t).node(n)
      , l = 0
      , a = e ? e.index(n) : o.childCount;
    t && (l = t.index(n),
    t.depth > n ? l++ : t.textOffset && (ho(t.nodeAfter, r),
    l++));
    for (let u = l; u < a; u++)
        ho(o.child(u), r);
    e && e.depth == n && e.textOffset && ho(e.nodeBefore, r)
}
function po(t, e) {
    return t.type.checkContent(e),
    t.copy(e)
}
function AS(t, e, n, r, o) {
    let l = t.depth > o && ym(t, e, o + 1)
      , a = r.depth > o && ym(n, r, o + 1)
      , u = [];
    return Js(null, t, o, u),
    l && a && e.index(o) == n.index(o) ? (MS(l, a),
    ho(po(l, AS(t, e, n, r, o + 1)), u)) : (l && ho(po(l, Ru(t, e, o + 1)), u),
    Js(e, n, o, u),
    a && ho(po(a, Ru(n, r, o + 1)), u)),
    Js(r, null, o, u),
    new Z(u)
}
function Ru(t, e, n) {
    let r = [];
    if (Js(null, t, n, r),
    t.depth > n) {
        let o = ym(t, e, n + 1);
        ho(po(o, Ru(t, e, n + 1)), r)
    }
    return Js(e, null, n, r),
    new Z(r)
}
function lE(t, e) {
    let n = e.depth - t.openStart
      , o = e.node(n).copy(t.content);
    for (let l = n - 1; l >= 0; l--)
        o = e.node(l).copy(Z.from(o));
    return {
        start: o.resolveNoCache(t.openStart + n),
        end: o.resolveNoCache(o.content.size - t.openEnd - n)
    }
}
class aa {
    constructor(e, n, r) {
        this.pos = e,
        this.path = n,
        this.parentOffset = r,
        this.depth = n.length / 3 - 1
    }
    resolveDepth(e) {
        return e == null ? this.depth : e < 0 ? this.depth + e : e
    }
    get parent() {
        return this.node(this.depth)
    }
    get doc() {
        return this.node(0)
    }
    node(e) {
        return this.path[this.resolveDepth(e) * 3]
    }
    index(e) {
        return this.path[this.resolveDepth(e) * 3 + 1]
    }
    indexAfter(e) {
        return e = this.resolveDepth(e),
        this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
    }
    start(e) {
        return e = this.resolveDepth(e),
        e == 0 ? 0 : this.path[e * 3 - 1] + 1
    }
    end(e) {
        return e = this.resolveDepth(e),
        this.start(e) + this.node(e).content.size
    }
    before(e) {
        if (e = this.resolveDepth(e),
        !e)
            throw new RangeError("There is no position before the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1]
    }
    after(e) {
        if (e = this.resolveDepth(e),
        !e)
            throw new RangeError("There is no position after the top-level node");
        return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize
    }
    get textOffset() {
        return this.pos - this.path[this.path.length - 1]
    }
    get nodeAfter() {
        let e = this.parent
          , n = this.index(this.depth);
        if (n == e.childCount)
            return null;
        let r = this.pos - this.path[this.path.length - 1]
          , o = e.child(n);
        return r ? e.child(n).cut(r) : o
    }
    get nodeBefore() {
        let e = this.index(this.depth)
          , n = this.pos - this.path[this.path.length - 1];
        return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1)
    }
    posAtIndex(e, n) {
        n = this.resolveDepth(n);
        let r = this.path[n * 3]
          , o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
        for (let l = 0; l < e; l++)
            o += r.child(l).nodeSize;
        return o
    }
    marks() {
        let e = this.parent
          , n = this.index();
        if (e.content.size == 0)
            return Ve.none;
        if (this.textOffset)
            return e.child(n).marks;
        let r = e.maybeChild(n - 1)
          , o = e.maybeChild(n);
        if (!r) {
            let u = r;
            r = o,
            o = u
        }
        let l = r.marks;
        for (var a = 0; a < l.length; a++)
            l[a].type.spec.inclusive === !1 && (!o || !l[a].isInSet(o.marks)) && (l = l[a--].removeFromSet(l));
        return l
    }
    marksAcross(e) {
        let n = this.parent.maybeChild(this.index());
        if (!n || !n.isInline)
            return null;
        let r = n.marks
          , o = e.parent.maybeChild(e.index());
        for (var l = 0; l < r.length; l++)
            r[l].type.spec.inclusive === !1 && (!o || !r[l].isInSet(o.marks)) && (r = r[l--].removeFromSet(r));
        return r
    }
    sharedDepth(e) {
        for (let n = this.depth; n > 0; n--)
            if (this.start(n) <= e && this.end(n) >= e)
                return n;
        return 0
    }
    blockRange(e=this, n) {
        if (e.pos < this.pos)
            return e.blockRange(this);
        for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
            if (e.pos <= this.end(r) && (!n || n(this.node(r))))
                return new Ou(this,e,r);
        return null
    }
    sameParent(e) {
        return this.pos - this.parentOffset == e.pos - e.parentOffset
    }
    max(e) {
        return e.pos > this.pos ? e : this
    }
    min(e) {
        return e.pos < this.pos ? e : this
    }
    toString() {
        let e = "";
        for (let n = 1; n <= this.depth; n++)
            e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
        return e + ":" + this.parentOffset
    }
    static resolve(e, n) {
        if (!(n >= 0 && n <= e.content.size))
            throw new RangeError("Position " + n + " out of range");
        let r = []
          , o = 0
          , l = n;
        for (let a = e; ; ) {
            let {index: u, offset: f} = a.content.findIndex(l)
              , h = l - f;
            if (r.push(a, u, o + f),
            !h || (a = a.child(u),
            a.isText))
                break;
            l = h - 1,
            o += f + 1
        }
        return new aa(n,r,l)
    }
    static resolveCached(e, n) {
        let r = Hv.get(e);
        if (r)
            for (let l = 0; l < r.elts.length; l++) {
                let a = r.elts[l];
                if (a.pos == n)
                    return a
            }
        else
            Hv.set(e, r = new sE);
        let o = r.elts[r.i] = aa.resolve(e, n);
        return r.i = (r.i + 1) % aE,
        o
    }
}
class sE {
    constructor() {
        this.elts = [],
        this.i = 0
    }
}
const aE = 12
  , Hv = new WeakMap;
class Ou {
    constructor(e, n, r) {
        this.$from = e,
        this.$to = n,
        this.depth = r
    }
    get start() {
        return this.$from.before(this.depth + 1)
    }
    get end() {
        return this.$to.after(this.depth + 1)
    }
    get parent() {
        return this.$from.node(this.depth)
    }
    get startIndex() {
        return this.$from.index(this.depth)
    }
    get endIndex() {
        return this.$to.indexAfter(this.depth)
    }
}
const cE = Object.create(null);
let Ci = class vm {
    constructor(e, n, r, o=Ve.none) {
        this.type = e,
        this.attrs = n,
        this.marks = o,
        this.content = r || Z.empty
    }
    get children() {
        return this.content.content
    }
    get nodeSize() {
        return this.isLeaf ? 1 : 2 + this.content.size
    }
    get childCount() {
        return this.content.childCount
    }
    child(e) {
        return this.content.child(e)
    }
    maybeChild(e) {
        return this.content.maybeChild(e)
    }
    forEach(e) {
        this.content.forEach(e)
    }
    nodesBetween(e, n, r, o=0) {
        this.content.nodesBetween(e, n, r, o, this)
    }
    descendants(e) {
        this.nodesBetween(0, this.content.size, e)
    }
    get textContent() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "")
    }
    textBetween(e, n, r, o) {
        return this.content.textBetween(e, n, r, o)
    }
    get firstChild() {
        return this.content.firstChild
    }
    get lastChild() {
        return this.content.lastChild
    }
    eq(e) {
        return this == e || this.sameMarkup(e) && this.content.eq(e.content)
    }
    sameMarkup(e) {
        return this.hasMarkup(e.type, e.attrs, e.marks)
    }
    hasMarkup(e, n, r) {
        return this.type == e && Au(this.attrs, n || e.defaultAttrs || cE) && Ve.sameSet(this.marks, r || Ve.none)
    }
    copy(e=null) {
        return e == this.content ? this : new vm(this.type,this.attrs,e,this.marks)
    }
    mark(e) {
        return e == this.marks ? this : new vm(this.type,this.attrs,this.content,e)
    }
    cut(e, n=this.content.size) {
        return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n))
    }
    slice(e, n=this.content.size, r=!1) {
        if (e == n)
            return te.empty;
        let o = this.resolve(e)
          , l = this.resolve(n)
          , a = r ? 0 : o.sharedDepth(n)
          , u = o.start(a)
          , h = o.node(a).content.cut(o.pos - u, l.pos - u);
        return new te(h,o.depth - a,l.depth - a)
    }
    replace(e, n, r) {
        return oE(this.resolve(e), this.resolve(n), r)
    }
    nodeAt(e) {
        for (let n = this; ; ) {
            let {index: r, offset: o} = n.content.findIndex(e);
            if (n = n.maybeChild(r),
            !n)
                return null;
            if (o == e || n.isText)
                return n;
            e -= o + 1
        }
    }
    childAfter(e) {
        let {index: n, offset: r} = this.content.findIndex(e);
        return {
            node: this.content.maybeChild(n),
            index: n,
            offset: r
        }
    }
    childBefore(e) {
        if (e == 0)
            return {
                node: null,
                index: 0,
                offset: 0
            };
        let {index: n, offset: r} = this.content.findIndex(e);
        if (r < e)
            return {
                node: this.content.child(n),
                index: n,
                offset: r
            };
        let o = this.content.child(n - 1);
        return {
            node: o,
            index: n - 1,
            offset: r - o.nodeSize
        }
    }
    resolve(e) {
        return aa.resolveCached(this, e)
    }
    resolveNoCache(e) {
        return aa.resolve(this, e)
    }
    rangeHasMark(e, n, r) {
        let o = !1;
        return n > e && this.nodesBetween(e, n, l => (r.isInSet(l.marks) && (o = !0),
        !o)),
        o
    }
    get isBlock() {
        return this.type.isBlock
    }
    get isTextblock() {
        return this.type.isTextblock
    }
    get inlineContent() {
        return this.type.inlineContent
    }
    get isInline() {
        return this.type.isInline
    }
    get isText() {
        return this.type.isText
    }
    get isLeaf() {
        return this.type.isLeaf
    }
    get isAtom() {
        return this.type.isAtom
    }
    toString() {
        if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
        let e = this.type.name;
        return this.content.size && (e += "(" + this.content.toStringInner() + ")"),
        NS(this.marks, e)
    }
    contentMatchAt(e) {
        let n = this.type.contentMatch.matchFragment(this.content, 0, e);
        if (!n)
            throw new Error("Called contentMatchAt on a node with invalid content");
        return n
    }
    canReplace(e, n, r=Z.empty, o=0, l=r.childCount) {
        let a = this.contentMatchAt(e).matchFragment(r, o, l)
          , u = a && a.matchFragment(this.content, n);
        if (!u || !u.validEnd)
            return !1;
        for (let f = o; f < l; f++)
            if (!this.type.allowsMarks(r.child(f).marks))
                return !1;
        return !0
    }
    canReplaceWith(e, n, r, o) {
        if (o && !this.type.allowsMarks(o))
            return !1;
        let l = this.contentMatchAt(e).matchType(r)
          , a = l && l.matchFragment(this.content, n);
        return a ? a.validEnd : !1
    }
    canAppend(e) {
        return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type)
    }
    check() {
        this.type.checkContent(this.content),
        this.type.checkAttrs(this.attrs);
        let e = Ve.none;
        for (let n = 0; n < this.marks.length; n++) {
            let r = this.marks[n];
            r.type.checkAttrs(r.attrs),
            e = r.addToSet(e)
        }
        if (!Ve.sameSet(e, this.marks))
            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(n => n.type.name)}`);
        this.content.forEach(n => n.check())
    }
    toJSON() {
        let e = {
            type: this.type.name
        };
        for (let n in this.attrs) {
            e.attrs = this.attrs;
            break
        }
        return this.content.size && (e.content = this.content.toJSON()),
        this.marks.length && (e.marks = this.marks.map(n => n.toJSON())),
        e
    }
    static fromJSON(e, n) {
        if (!n)
            throw new RangeError("Invalid input for Node.fromJSON");
        let r;
        if (n.marks) {
            if (!Array.isArray(n.marks))
                throw new RangeError("Invalid mark data for Node.fromJSON");
            r = n.marks.map(e.markFromJSON)
        }
        if (n.type == "text") {
            if (typeof n.text != "string")
                throw new RangeError("Invalid text node in JSON");
            return e.text(n.text, r)
        }
        let o = Z.fromJSON(e, n.content)
          , l = e.nodeType(n.type).create(n.attrs, o, r);
        return l.type.checkAttrs(l.attrs),
        l
    }
}
;
Ci.prototype.text = void 0;
class Du extends Ci {
    constructor(e, n, r, o) {
        if (super(e, n, null, o),
        !r)
            throw new RangeError("Empty text nodes are not allowed");
        this.text = r
    }
    toString() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : NS(this.marks, JSON.stringify(this.text))
    }
    get textContent() {
        return this.text
    }
    textBetween(e, n) {
        return this.text.slice(e, n)
    }
    get nodeSize() {
        return this.text.length
    }
    mark(e) {
        return e == this.marks ? this : new Du(this.type,this.attrs,this.text,e)
    }
    withText(e) {
        return e == this.text ? this : new Du(this.type,this.attrs,e,this.marks)
    }
    cut(e=0, n=this.text.length) {
        return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n))
    }
    eq(e) {
        return this.sameMarkup(e) && this.text == e.text
    }
    toJSON() {
        let e = super.toJSON();
        return e.text = this.text,
        e
    }
}
function NS(t, e) {
    for (let n = t.length - 1; n >= 0; n--)
        e = t[n].type.name + "(" + e + ")";
    return e
}
class vo {
    constructor(e) {
        this.validEnd = e,
        this.next = [],
        this.wrapCache = []
    }
    static parse(e, n) {
        let r = new uE(e,n);
        if (r.next == null)
            return vo.empty;
        let o = RS(r);
        r.next && r.err("Unexpected trailing text");
        let l = yE(gE(o));
        return vE(l, r),
        l
    }
    matchType(e) {
        for (let n = 0; n < this.next.length; n++)
            if (this.next[n].type == e)
                return this.next[n].next;
        return null
    }
    matchFragment(e, n=0, r=e.childCount) {
        let o = this;
        for (let l = n; o && l < r; l++)
            o = o.matchType(e.child(l).type);
        return o
    }
    get inlineContent() {
        return this.next.length != 0 && this.next[0].type.isInline
    }
    get defaultType() {
        for (let e = 0; e < this.next.length; e++) {
            let {type: n} = this.next[e];
            if (!(n.isText || n.hasRequiredAttrs()))
                return n
        }
        return null
    }
    compatible(e) {
        for (let n = 0; n < this.next.length; n++)
            for (let r = 0; r < e.next.length; r++)
                if (this.next[n].type == e.next[r].type)
                    return !0;
        return !1
    }
    fillBefore(e, n=!1, r=0) {
        let o = [this];
        function l(a, u) {
            let f = a.matchFragment(e, r);
            if (f && (!n || f.validEnd))
                return Z.from(u.map(h => h.createAndFill()));
            for (let h = 0; h < a.next.length; h++) {
                let {type: p, next: m} = a.next[h];
                if (!(p.isText || p.hasRequiredAttrs()) && o.indexOf(m) == -1) {
                    o.push(m);
                    let y = l(m, u.concat(p));
                    if (y)
                        return y
                }
            }
            return null
        }
        return l(this, [])
    }
    findWrapping(e) {
        for (let r = 0; r < this.wrapCache.length; r += 2)
            if (this.wrapCache[r] == e)
                return this.wrapCache[r + 1];
        let n = this.computeWrapping(e);
        return this.wrapCache.push(e, n),
        n
    }
    computeWrapping(e) {
        let n = Object.create(null)
          , r = [{
            match: this,
            type: null,
            via: null
        }];
        for (; r.length; ) {
            let o = r.shift()
              , l = o.match;
            if (l.matchType(e)) {
                let a = [];
                for (let u = o; u.type; u = u.via)
                    a.push(u.type);
                return a.reverse()
            }
            for (let a = 0; a < l.next.length; a++) {
                let {type: u, next: f} = l.next[a];
                !u.isLeaf && !u.hasRequiredAttrs() && !(u.name in n) && (!o.type || f.validEnd) && (r.push({
                    match: u.contentMatch,
                    type: u,
                    via: o
                }),
                n[u.name] = !0)
            }
        }
        return null
    }
    get edgeCount() {
        return this.next.length
    }
    edge(e) {
        if (e >= this.next.length)
            throw new RangeError(`There's no ${e}th edge in this content match`);
        return this.next[e]
    }
    toString() {
        let e = [];
        function n(r) {
            e.push(r);
            for (let o = 0; o < r.next.length; o++)
                e.indexOf(r.next[o].next) == -1 && n(r.next[o].next)
        }
        return n(this),
        e.map( (r, o) => {
            let l = o + (r.validEnd ? "*" : " ") + " ";
            for (let a = 0; a < r.next.length; a++)
                l += (a ? ", " : "") + r.next[a].type.name + "->" + e.indexOf(r.next[a].next);
            return l
        }
        ).join(`
`)
    }
}
vo.empty = new vo(!0);
class uE {
    constructor(e, n) {
        this.string = e,
        this.nodeTypes = n,
        this.inline = null,
        this.pos = 0,
        this.tokens = e.split(/\s*(?=\b|\W|$)/),
        this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
        this.tokens[0] == "" && this.tokens.shift()
    }
    get next() {
        return this.tokens[this.pos]
    }
    eat(e) {
        return this.next == e && (this.pos++ || !0)
    }
    err(e) {
        throw new SyntaxError(e + " (in content expression '" + this.string + "')")
    }
}
function RS(t) {
    let e = [];
    do
        e.push(fE(t));
    while (t.eat("|"));
    return e.length == 1 ? e[0] : {
        type: "choice",
        exprs: e
    }
}
function fE(t) {
    let e = [];
    do
        e.push(dE(t));
    while (t.next && t.next != ")" && t.next != "|");
    return e.length == 1 ? e[0] : {
        type: "seq",
        exprs: e
    }
}
function dE(t) {
    let e = mE(t);
    for (; ; )
        if (t.eat("+"))
            e = {
                type: "plus",
                expr: e
            };
        else if (t.eat("*"))
            e = {
                type: "star",
                expr: e
            };
        else if (t.eat("?"))
            e = {
                type: "opt",
                expr: e
            };
        else if (t.eat("{"))
            e = hE(t, e);
        else
            break;
    return e
}
function Iv(t) {
    /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
    let e = Number(t.next);
    return t.pos++,
    e
}
function hE(t, e) {
    let n = Iv(t)
      , r = n;
    return t.eat(",") && (t.next != "}" ? r = Iv(t) : r = -1),
    t.eat("}") || t.err("Unclosed braced range"),
    {
        type: "range",
        min: n,
        max: r,
        expr: e
    }
}
function pE(t, e) {
    let n = t.nodeTypes
      , r = n[e];
    if (r)
        return [r];
    let o = [];
    for (let l in n) {
        let a = n[l];
        a.isInGroup(e) && o.push(a)
    }
    return o.length == 0 && t.err("No node type or group '" + e + "' found"),
    o
}
function mE(t) {
    if (t.eat("(")) {
        let e = RS(t);
        return t.eat(")") || t.err("Missing closing paren"),
        e
    } else if (/\W/.test(t.next))
        t.err("Unexpected token '" + t.next + "'");
    else {
        let e = pE(t, t.next).map(n => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"),
        {
            type: "name",
            value: n
        }));
        return t.pos++,
        e.length == 1 ? e[0] : {
            type: "choice",
            exprs: e
        }
    }
}
function gE(t) {
    let e = [[]];
    return o(l(t, 0), n()),
    e;
    function n() {
        return e.push([]) - 1
    }
    function r(a, u, f) {
        let h = {
            term: f,
            to: u
        };
        return e[a].push(h),
        h
    }
    function o(a, u) {
        a.forEach(f => f.to = u)
    }
    function l(a, u) {
        if (a.type == "choice")
            return a.exprs.reduce( (f, h) => f.concat(l(h, u)), []);
        if (a.type == "seq")
            for (let f = 0; ; f++) {
                let h = l(a.exprs[f], u);
                if (f == a.exprs.length - 1)
                    return h;
                o(h, u = n())
            }
        else if (a.type == "star") {
            let f = n();
            return r(u, f),
            o(l(a.expr, f), f),
            [r(f)]
        } else if (a.type == "plus") {
            let f = n();
            return o(l(a.expr, u), f),
            o(l(a.expr, f), f),
            [r(f)]
        } else {
            if (a.type == "opt")
                return [r(u)].concat(l(a.expr, u));
            if (a.type == "range") {
                let f = u;
                for (let h = 0; h < a.min; h++) {
                    let p = n();
                    o(l(a.expr, f), p),
                    f = p
                }
                if (a.max == -1)
                    o(l(a.expr, f), f);
                else
                    for (let h = a.min; h < a.max; h++) {
                        let p = n();
                        r(f, p),
                        o(l(a.expr, f), p),
                        f = p
                    }
                return [r(f)]
            } else {
                if (a.type == "name")
                    return [r(u, void 0, a.value)];
                throw new Error("Unknown expr type")
            }
        }
    }
}
function OS(t, e) {
    return e - t
}
function Vv(t, e) {
    let n = [];
    return r(e),
    n.sort(OS);
    function r(o) {
        let l = t[o];
        if (l.length == 1 && !l[0].term)
            return r(l[0].to);
        n.push(o);
        for (let a = 0; a < l.length; a++) {
            let {term: u, to: f} = l[a];
            !u && n.indexOf(f) == -1 && r(f)
        }
    }
}
function yE(t) {
    let e = Object.create(null);
    return n(Vv(t, 0));
    function n(r) {
        let o = [];
        r.forEach(a => {
            t[a].forEach( ({term: u, to: f}) => {
                if (!u)
                    return;
                let h;
                for (let p = 0; p < o.length; p++)
                    o[p][0] == u && (h = o[p][1]);
                Vv(t, f).forEach(p => {
                    h || o.push([u, h = []]),
                    h.indexOf(p) == -1 && h.push(p)
                }
                )
            }
            )
        }
        );
        let l = e[r.join(",")] = new vo(r.indexOf(t.length - 1) > -1);
        for (let a = 0; a < o.length; a++) {
            let u = o[a][1].sort(OS);
            l.next.push({
                type: o[a][0],
                next: e[u.join(",")] || n(u)
            })
        }
        return l
    }
}
function vE(t, e) {
    for (let n = 0, r = [t]; n < r.length; n++) {
        let o = r[n]
          , l = !o.validEnd
          , a = [];
        for (let u = 0; u < o.next.length; u++) {
            let {type: f, next: h} = o.next[u];
            a.push(f.name),
            l && !(f.isText || f.hasRequiredAttrs()) && (l = !1),
            r.indexOf(h) == -1 && r.push(h)
        }
        l && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)")
    }
}
function DS(t) {
    let e = Object.create(null);
    for (let n in t) {
        let r = t[n];
        if (!r.hasDefault)
            return null;
        e[n] = r.default
    }
    return e
}
function LS(t, e) {
    let n = Object.create(null);
    for (let r in t) {
        let o = e && e[r];
        if (o === void 0) {
            let l = t[r];
            if (l.hasDefault)
                o = l.default;
            else
                throw new RangeError("No value supplied for attribute " + r)
        }
        n[r] = o
    }
    return n
}
function zS(t, e, n, r) {
    for (let o in e)
        if (!(o in t))
            throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
    for (let o in t) {
        let l = t[o];
        l.validate && l.validate(e[o])
    }
}
function _S(t, e) {
    let n = Object.create(null);
    if (e)
        for (let r in e)
            n[r] = new CE(t,r,e[r]);
    return n
}
let Uv = class BS {
    constructor(e, n, r) {
        this.name = e,
        this.schema = n,
        this.spec = r,
        this.markSet = null,
        this.groups = r.group ? r.group.split(" ") : [],
        this.attrs = _S(e, r.attrs),
        this.defaultAttrs = DS(this.attrs),
        this.contentMatch = null,
        this.inlineContent = null,
        this.isBlock = !(r.inline || e == "text"),
        this.isText = e == "text"
    }
    get isInline() {
        return !this.isBlock
    }
    get isTextblock() {
        return this.isBlock && this.inlineContent
    }
    get isLeaf() {
        return this.contentMatch == vo.empty
    }
    get isAtom() {
        return this.isLeaf || !!this.spec.atom
    }
    isInGroup(e) {
        return this.groups.indexOf(e) > -1
    }
    get whitespace() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal")
    }
    hasRequiredAttrs() {
        for (let e in this.attrs)
            if (this.attrs[e].isRequired)
                return !0;
        return !1
    }
    compatibleContent(e) {
        return this == e || this.contentMatch.compatible(e.contentMatch)
    }
    computeAttrs(e) {
        return !e && this.defaultAttrs ? this.defaultAttrs : LS(this.attrs, e)
    }
    create(e=null, n, r) {
        if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
        return new Ci(this,this.computeAttrs(e),Z.from(n),Ve.setFrom(r))
    }
    createChecked(e=null, n, r) {
        return n = Z.from(n),
        this.checkContent(n),
        new Ci(this,this.computeAttrs(e),n,Ve.setFrom(r))
    }
    createAndFill(e=null, n, r) {
        if (e = this.computeAttrs(e),
        n = Z.from(n),
        n.size) {
            let a = this.contentMatch.fillBefore(n);
            if (!a)
                return null;
            n = a.append(n)
        }
        let o = this.contentMatch.matchFragment(n)
          , l = o && o.fillBefore(Z.empty, !0);
        return l ? new Ci(this,e,n.append(l),Ve.setFrom(r)) : null
    }
    validContent(e) {
        let n = this.contentMatch.matchFragment(e);
        if (!n || !n.validEnd)
            return !1;
        for (let r = 0; r < e.childCount; r++)
            if (!this.allowsMarks(e.child(r).marks))
                return !1;
        return !0
    }
    checkContent(e) {
        if (!this.validContent(e))
            throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`)
    }
    checkAttrs(e) {
        zS(this.attrs, e, "node", this.name)
    }
    allowsMarkType(e) {
        return this.markSet == null || this.markSet.indexOf(e) > -1
    }
    allowsMarks(e) {
        if (this.markSet == null)
            return !0;
        for (let n = 0; n < e.length; n++)
            if (!this.allowsMarkType(e[n].type))
                return !1;
        return !0
    }
    allowedMarks(e) {
        if (this.markSet == null)
            return e;
        let n;
        for (let r = 0; r < e.length; r++)
            this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
        return n ? n.length ? n : Ve.none : e
    }
    static compile(e, n) {
        let r = Object.create(null);
        e.forEach( (l, a) => r[l] = new BS(l,n,a));
        let o = n.spec.topNode || "doc";
        if (!r[o])
            throw new RangeError("Schema is missing its top node type ('" + o + "')");
        if (!r.text)
            throw new RangeError("Every schema needs a 'text' type");
        for (let l in r.text.attrs)
            throw new RangeError("The text node type should not have attributes");
        return r
    }
}
;
function bE(t, e, n) {
    let r = n.split("|");
    return o => {
        let l = o === null ? "null" : typeof o;
        if (r.indexOf(l) < 0)
            throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${l}`)
    }
}
class CE {
    constructor(e, n, r) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"),
        this.default = r.default,
        this.validate = typeof r.validate == "string" ? bE(e, n, r.validate) : r.validate
    }
    get isRequired() {
        return !this.hasDefault
    }
}
class Af {
    constructor(e, n, r, o) {
        this.name = e,
        this.rank = n,
        this.schema = r,
        this.spec = o,
        this.attrs = _S(e, o.attrs),
        this.excluded = null;
        let l = DS(this.attrs);
        this.instance = l ? new Ve(this,l) : null
    }
    create(e=null) {
        return !e && this.instance ? this.instance : new Ve(this,LS(this.attrs, e))
    }
    static compile(e, n) {
        let r = Object.create(null)
          , o = 0;
        return e.forEach( (l, a) => r[l] = new Af(l,o++,n,a)),
        r
    }
    removeFromSet(e) {
        for (var n = 0; n < e.length; n++)
            e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)),
            n--);
        return e
    }
    isInSet(e) {
        for (let n = 0; n < e.length; n++)
            if (e[n].type == this)
                return e[n]
    }
    checkAttrs(e) {
        zS(this.attrs, e, "mark", this.name)
    }
    excludes(e) {
        return this.excluded.indexOf(e) > -1
    }
}
class jS {
    constructor(e) {
        this.linebreakReplacement = null,
        this.cached = Object.create(null);
        let n = this.spec = {};
        for (let o in e)
            n[o] = e[o];
        n.nodes = Tt.from(e.nodes),
        n.marks = Tt.from(e.marks || {}),
        this.nodes = Uv.compile(this.spec.nodes, this),
        this.marks = Af.compile(this.spec.marks, this);
        let r = Object.create(null);
        for (let o in this.nodes) {
            if (o in this.marks)
                throw new RangeError(o + " can not be both a node and a mark");
            let l = this.nodes[o]
              , a = l.spec.content || ""
              , u = l.spec.marks;
            if (l.contentMatch = r[a] || (r[a] = vo.parse(a, this.nodes)),
            l.inlineContent = l.contentMatch.inlineContent,
            l.spec.linebreakReplacement) {
                if (this.linebreakReplacement)
                    throw new RangeError("Multiple linebreak nodes defined");
                if (!l.isInline || !l.isLeaf)
                    throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
                this.linebreakReplacement = l
            }
            l.markSet = u == "_" ? null : u ? Pv(this, u.split(" ")) : u == "" || !l.inlineContent ? [] : null
        }
        for (let o in this.marks) {
            let l = this.marks[o]
              , a = l.spec.excludes;
            l.excluded = a == null ? [l] : a == "" ? [] : Pv(this, a.split(" "))
        }
        this.nodeFromJSON = o => Ci.fromJSON(this, o),
        this.markFromJSON = o => Ve.fromJSON(this, o),
        this.topNodeType = this.nodes[this.spec.topNode || "doc"],
        this.cached.wrappings = Object.create(null)
    }
    node(e, n=null, r, o) {
        if (typeof e == "string")
            e = this.nodeType(e);
        else if (e instanceof Uv) {
            if (e.schema != this)
                throw new RangeError("Node type from different schema used (" + e.name + ")")
        } else
            throw new RangeError("Invalid node type: " + e);
        return e.createChecked(n, r, o)
    }
    text(e, n) {
        let r = this.nodes.text;
        return new Du(r,r.defaultAttrs,e,Ve.setFrom(n))
    }
    mark(e, n) {
        return typeof e == "string" && (e = this.marks[e]),
        e.create(n)
    }
    nodeType(e) {
        let n = this.nodes[e];
        if (!n)
            throw new RangeError("Unknown node type: " + e);
        return n
    }
}
function Pv(t, e) {
    let n = [];
    for (let r = 0; r < e.length; r++) {
        let o = e[r]
          , l = t.marks[o]
          , a = l;
        if (l)
            n.push(l);
        else
            for (let u in t.marks) {
                let f = t.marks[u];
                (o == "_" || f.spec.group && f.spec.group.split(" ").indexOf(o) > -1) && n.push(a = f)
            }
        if (!a)
            throw new SyntaxError("Unknown mark type: '" + e[r] + "'")
    }
    return n
}
function SE(t) {
    return t.tag != null
}
function xE(t) {
    return t.style != null
}
class Si {
    constructor(e, n) {
        this.schema = e,
        this.rules = n,
        this.tags = [],
        this.styles = [];
        let r = this.matchedStyles = [];
        n.forEach(o => {
            if (SE(o))
                this.tags.push(o);
            else if (xE(o)) {
                let l = /[^=]*/.exec(o.style)[0];
                r.indexOf(l) < 0 && r.push(l),
                this.styles.push(o)
            }
        }
        ),
        this.normalizeLists = !this.tags.some(o => {
            if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
                return !1;
            let l = e.nodes[o.node];
            return l.contentMatch.matchType(l)
        }
        )
    }
    parse(e, n={}) {
        let r = new $v(this,n,!1);
        return r.addAll(e, Ve.none, n.from, n.to),
        r.finish()
    }
    parseSlice(e, n={}) {
        let r = new $v(this,n,!0);
        return r.addAll(e, Ve.none, n.from, n.to),
        te.maxOpen(r.finish())
    }
    matchTag(e, n, r) {
        for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
            let l = this.tags[o];
            if (TE(e, l.tag) && (l.namespace === void 0 || e.namespaceURI == l.namespace) && (!l.context || n.matchesContext(l.context))) {
                if (l.getAttrs) {
                    let a = l.getAttrs(e);
                    if (a === !1)
                        continue;
                    l.attrs = a || void 0
                }
                return l
            }
        }
    }
    matchStyle(e, n, r, o) {
        for (let l = o ? this.styles.indexOf(o) + 1 : 0; l < this.styles.length; l++) {
            let a = this.styles[l]
              , u = a.style;
            if (!(u.indexOf(e) != 0 || a.context && !r.matchesContext(a.context) || u.length > e.length && (u.charCodeAt(e.length) != 61 || u.slice(e.length + 1) != n))) {
                if (a.getAttrs) {
                    let f = a.getAttrs(n);
                    if (f === !1)
                        continue;
                    a.attrs = f || void 0
                }
                return a
            }
        }
    }
    static schemaRules(e) {
        let n = [];
        function r(o) {
            let l = o.priority == null ? 50 : o.priority
              , a = 0;
            for (; a < n.length; a++) {
                let u = n[a];
                if ((u.priority == null ? 50 : u.priority) < l)
                    break
            }
            n.splice(a, 0, o)
        }
        for (let o in e.marks) {
            let l = e.marks[o].spec.parseDOM;
            l && l.forEach(a => {
                r(a = Fv(a)),
                a.mark || a.ignore || a.clearMark || (a.mark = o)
            }
            )
        }
        for (let o in e.nodes) {
            let l = e.nodes[o].spec.parseDOM;
            l && l.forEach(a => {
                r(a = Fv(a)),
                a.node || a.ignore || a.mark || (a.node = o)
            }
            )
        }
        return n
    }
    static fromSchema(e) {
        return e.cached.domParser || (e.cached.domParser = new Si(e,Si.schemaRules(e)))
    }
}
const HS = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
}
  , wE = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
}
  , IS = {
    ol: !0,
    ul: !0
}
  , ca = 1
  , bm = 2
  , Qs = 4;
function qv(t, e, n) {
    return e != null ? (e ? ca : 0) | (e === "full" ? bm : 0) : t && t.whitespace == "pre" ? ca | bm : n & ~Qs
}
class Yc {
    constructor(e, n, r, o, l, a) {
        this.type = e,
        this.attrs = n,
        this.marks = r,
        this.solid = o,
        this.options = a,
        this.content = [],
        this.activeMarks = Ve.none,
        this.match = l || (a & Qs ? null : e.contentMatch)
    }
    findWrapping(e) {
        if (!this.match) {
            if (!this.type)
                return [];
            let n = this.type.contentMatch.fillBefore(Z.from(e));
            if (n)
                this.match = this.type.contentMatch.matchFragment(n);
            else {
                let r = this.type.contentMatch, o;
                return (o = r.findWrapping(e.type)) ? (this.match = r,
                o) : null
            }
        }
        return this.match.findWrapping(e.type)
    }
    finish(e) {
        if (!(this.options & ca)) {
            let r = this.content[this.content.length - 1], o;
            if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
                let l = r;
                r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = l.withText(l.text.slice(0, l.text.length - o[0].length))
            }
        }
        let n = Z.from(this.content);
        return !e && this.match && (n = n.append(this.match.fillBefore(Z.empty, !0))),
        this.type ? this.type.create(this.attrs, n, this.marks) : n
    }
    inlineContext(e) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !HS.hasOwnProperty(e.parentNode.nodeName.toLowerCase())
    }
}
class $v {
    constructor(e, n, r) {
        this.parser = e,
        this.options = n,
        this.isOpen = r,
        this.open = 0,
        this.localPreserveWS = !1;
        let o = n.topNode, l, a = qv(null, n.preserveWhitespace, 0) | (r ? Qs : 0);
        o ? l = new Yc(o.type,o.attrs,Ve.none,!0,n.topMatch || o.type.contentMatch,a) : r ? l = new Yc(null,null,Ve.none,!0,null,a) : l = new Yc(e.schema.topNodeType,null,Ve.none,!0,null,a),
        this.nodes = [l],
        this.find = n.findPositions,
        this.needsBlock = !1
    }
    get top() {
        return this.nodes[this.open]
    }
    addDOM(e, n) {
        e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n)
    }
    addTextNode(e, n) {
        let r = e.nodeValue
          , o = this.top
          , l = o.options & bm ? "full" : this.localPreserveWS || (o.options & ca) > 0
          , {schema: a} = this.parser;
        if (l === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
            if (l)
                if (l === "full")
                    r = r.replace(/\r\n?/g, `
`);
                else if (a.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(a.linebreakReplacement.create())) {
                    let u = r.split(/\r?\n|\r/);
                    for (let f = 0; f < u.length; f++)
                        f && this.insertNode(a.linebreakReplacement.create(), n, !0),
                        u[f] && this.insertNode(a.text(u[f]), n, !/\S/.test(u[f]));
                    r = ""
                } else
                    r = r.replace(/\r?\n|\r/g, " ");
            else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "),
            /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
                let u = o.content[o.content.length - 1]
                  , f = e.previousSibling;
                (!u || f && f.nodeName == "BR" || u.isText && /[ \t\r\n\u000c]$/.test(u.text)) && (r = r.slice(1))
            }
            r && this.insertNode(a.text(r), n, !/\S/.test(r)),
            this.findInText(e)
        } else
            this.findInside(e)
    }
    addElement(e, n, r) {
        let o = this.localPreserveWS
          , l = this.top;
        (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
        let a = e.nodeName.toLowerCase(), u;
        IS.hasOwnProperty(a) && this.parser.normalizeLists && EE(e);
        let f = this.options.ruleFromNode && this.options.ruleFromNode(e) || (u = this.parser.matchTag(e, this, r));
        e: if (f ? f.ignore : wE.hasOwnProperty(a))
            this.findInside(e),
            this.ignoreFallback(e, n);
        else if (!f || f.skip || f.closeParent) {
            f && f.closeParent ? this.open = Math.max(0, this.open - 1) : f && f.skip.nodeType && (e = f.skip);
            let h, p = this.needsBlock;
            if (HS.hasOwnProperty(a))
                l.content.length && l.content[0].isInline && this.open && (this.open--,
                l = this.top),
                h = !0,
                l.type || (this.needsBlock = !0);
            else if (!e.firstChild) {
                this.leafFallback(e, n);
                break e
            }
            let m = f && f.skip ? n : this.readStyles(e, n);
            m && this.addAll(e, m),
            h && this.sync(l),
            this.needsBlock = p
        } else {
            let h = this.readStyles(e, n);
            h && this.addElementByRule(e, f, h, f.consuming === !1 ? u : void 0)
        }
        this.localPreserveWS = o
    }
    leafFallback(e, n) {
        e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n)
    }
    ignoreFallback(e, n) {
        e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0)
    }
    readStyles(e, n) {
        let r = e.style;
        if (r && r.length)
            for (let o = 0; o < this.parser.matchedStyles.length; o++) {
                let l = this.parser.matchedStyles[o]
                  , a = r.getPropertyValue(l);
                if (a)
                    for (let u = void 0; ; ) {
                        let f = this.parser.matchStyle(l, a, this, u);
                        if (!f)
                            break;
                        if (f.ignore)
                            return null;
                        if (f.clearMark ? n = n.filter(h => !f.clearMark(h)) : n = n.concat(this.parser.schema.marks[f.mark].create(f.attrs)),
                        f.consuming === !1)
                            u = f;
                        else
                            break
                    }
            }
        return n
    }
    addElementByRule(e, n, r, o) {
        let l, a;
        if (n.node)
            if (a = this.parser.schema.nodes[n.node],
            a.isLeaf)
                this.insertNode(a.create(n.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
            else {
                let f = this.enter(a, n.attrs || null, r, n.preserveWhitespace);
                f && (l = !0,
                r = f)
            }
        else {
            let f = this.parser.schema.marks[n.mark];
            r = r.concat(f.create(n.attrs))
        }
        let u = this.top;
        if (a && a.isLeaf)
            this.findInside(e);
        else if (o)
            this.addElement(e, r, o);
        else if (n.getContent)
            this.findInside(e),
            n.getContent(e, this.parser.schema).forEach(f => this.insertNode(f, r, !1));
        else {
            let f = e;
            typeof n.contentElement == "string" ? f = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? f = n.contentElement(e) : n.contentElement && (f = n.contentElement),
            this.findAround(e, f, !0),
            this.addAll(f, r),
            this.findAround(e, f, !1)
        }
        l && this.sync(u) && this.open--
    }
    addAll(e, n, r, o) {
        let l = r || 0;
        for (let a = r ? e.childNodes[r] : e.firstChild, u = o == null ? null : e.childNodes[o]; a != u; a = a.nextSibling,
        ++l)
            this.findAtPoint(e, l),
            this.addDOM(a, n);
        this.findAtPoint(e, l)
    }
    findPlace(e, n, r) {
        let o, l;
        for (let a = this.open, u = 0; a >= 0; a--) {
            let f = this.nodes[a]
              , h = f.findWrapping(e);
            if (h && (!o || o.length > h.length + u) && (o = h,
            l = f,
            !h.length))
                break;
            if (f.solid) {
                if (r)
                    break;
                u += 2
            }
        }
        if (!o)
            return null;
        this.sync(l);
        for (let a = 0; a < o.length; a++)
            n = this.enterInner(o[a], null, n, !1);
        return n
    }
    insertNode(e, n, r) {
        if (e.isInline && this.needsBlock && !this.top.type) {
            let l = this.textblockFromContext();
            l && (n = this.enterInner(l, null, n))
        }
        let o = this.findPlace(e, n, r);
        if (o) {
            this.closeExtra();
            let l = this.top;
            l.match && (l.match = l.match.matchType(e.type));
            let a = Ve.none;
            for (let u of o.concat(e.marks))
                (l.type ? l.type.allowsMarkType(u.type) : Kv(u.type, e.type)) && (a = u.addToSet(a));
            return l.content.push(e.mark(a)),
            !0
        }
        return !1
    }
    enter(e, n, r, o) {
        let l = this.findPlace(e.create(n), r, !1);
        return l && (l = this.enterInner(e, n, r, !0, o)),
        l
    }
    enterInner(e, n, r, o=!1, l) {
        this.closeExtra();
        let a = this.top;
        a.match = a.match && a.match.matchType(e);
        let u = qv(e, l, a.options);
        a.options & Qs && a.content.length == 0 && (u |= Qs);
        let f = Ve.none;
        return r = r.filter(h => (a.type ? a.type.allowsMarkType(h.type) : Kv(h.type, e)) ? (f = h.addToSet(f),
        !1) : !0),
        this.nodes.push(new Yc(e,n,f,o,null,u)),
        this.open++,
        r
    }
    closeExtra(e=!1) {
        let n = this.nodes.length - 1;
        if (n > this.open) {
            for (; n > this.open; n--)
                this.nodes[n - 1].content.push(this.nodes[n].finish(e));
            this.nodes.length = this.open + 1
        }
    }
    finish() {
        return this.open = 0,
        this.closeExtra(this.isOpen),
        this.nodes[0].finish(!!(this.isOpen || this.options.topOpen))
    }
    sync(e) {
        for (let n = this.open; n >= 0; n--) {
            if (this.nodes[n] == e)
                return this.open = n,
                !0;
            this.localPreserveWS && (this.nodes[n].options |= ca)
        }
        return !1
    }
    get currentPos() {
        this.closeExtra();
        let e = 0;
        for (let n = this.open; n >= 0; n--) {
            let r = this.nodes[n].content;
            for (let o = r.length - 1; o >= 0; o--)
                e += r[o].nodeSize;
            n && e++
        }
        return e
    }
    findAtPoint(e, n) {
        if (this.find)
            for (let r = 0; r < this.find.length; r++)
                this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos)
    }
    findInside(e) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos)
    }
    findAround(e, n, r) {
        if (e != n && this.find)
            for (let o = 0; o < this.find.length; o++)
                this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos)
    }
    findInText(e) {
        if (this.find)
            for (let n = 0; n < this.find.length; n++)
                this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset))
    }
    matchesContext(e) {
        if (e.indexOf("|") > -1)
            return e.split(/\s*\|\s*/).some(this.matchesContext, this);
        let n = e.split("/")
          , r = this.options.context
          , o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type)
          , l = -(r ? r.depth + 1 : 0) + (o ? 0 : 1)
          , a = (u, f) => {
            for (; u >= 0; u--) {
                let h = n[u];
                if (h == "") {
                    if (u == n.length - 1 || u == 0)
                        continue;
                    for (; f >= l; f--)
                        if (a(u - 1, f))
                            return !0;
                    return !1
                } else {
                    let p = f > 0 || f == 0 && o ? this.nodes[f].type : r && f >= l ? r.node(f - l).type : null;
                    if (!p || p.name != h && !p.isInGroup(h))
                        return !1;
                    f--
                }
            }
            return !0
        }
        ;
        return a(n.length - 1, this.open)
    }
    textblockFromContext() {
        let e = this.options.context;
        if (e)
            for (let n = e.depth; n >= 0; n--) {
                let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
                if (r && r.isTextblock && r.defaultAttrs)
                    return r
            }
        for (let n in this.parser.schema.nodes) {
            let r = this.parser.schema.nodes[n];
            if (r.isTextblock && r.defaultAttrs)
                return r
        }
    }
}
function EE(t) {
    for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
        let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
        r && IS.hasOwnProperty(r) && n ? (n.appendChild(e),
        e = n) : r == "li" ? n = e : r && (n = null)
    }
}
function TE(t, e) {
    return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e)
}
function Fv(t) {
    let e = {};
    for (let n in t)
        e[n] = t[n];
    return e
}
function Kv(t, e) {
    let n = e.schema.nodes;
    for (let r in n) {
        let o = n[r];
        if (!o.allowsMarkType(t))
            continue;
        let l = []
          , a = u => {
            l.push(u);
            for (let f = 0; f < u.edgeCount; f++) {
                let {type: h, next: p} = u.edge(f);
                if (h == e || l.indexOf(p) < 0 && a(p))
                    return !0
            }
        }
        ;
        if (a(o.contentMatch))
            return !0
    }
}
class ko {
    constructor(e, n) {
        this.nodes = e,
        this.marks = n
    }
    serializeFragment(e, n={}, r) {
        r || (r = Tp(n).createDocumentFragment());
        let o = r
          , l = [];
        return e.forEach(a => {
            if (l.length || a.marks.length) {
                let u = 0
                  , f = 0;
                for (; u < l.length && f < a.marks.length; ) {
                    let h = a.marks[f];
                    if (!this.marks[h.type.name]) {
                        f++;
                        continue
                    }
                    if (!h.eq(l[u][0]) || h.type.spec.spanning === !1)
                        break;
                    u++,
                    f++
                }
                for (; u < l.length; )
                    o = l.pop()[1];
                for (; f < a.marks.length; ) {
                    let h = a.marks[f++]
                      , p = this.serializeMark(h, a.isInline, n);
                    p && (l.push([h, o]),
                    o.appendChild(p.dom),
                    o = p.contentDOM || p.dom)
                }
            }
            o.appendChild(this.serializeNodeInner(a, n))
        }
        ),
        r
    }
    serializeNodeInner(e, n) {
        let {dom: r, contentDOM: o} = yu(Tp(n), this.nodes[e.type.name](e), null, e.attrs);
        if (o) {
            if (e.isLeaf)
                throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(e.content, n, o)
        }
        return r
    }
    serializeNode(e, n={}) {
        let r = this.serializeNodeInner(e, n);
        for (let o = e.marks.length - 1; o >= 0; o--) {
            let l = this.serializeMark(e.marks[o], e.isInline, n);
            l && ((l.contentDOM || l.dom).appendChild(r),
            r = l.dom)
        }
        return r
    }
    serializeMark(e, n, r={}) {
        let o = this.marks[e.type.name];
        return o && yu(Tp(r), o(e, n), null, e.attrs)
    }
    static renderSpec(e, n, r=null, o) {
        return yu(e, n, r, o)
    }
    static fromSchema(e) {
        return e.cached.domSerializer || (e.cached.domSerializer = new ko(this.nodesFromSchema(e),this.marksFromSchema(e)))
    }
    static nodesFromSchema(e) {
        let n = Gv(e.nodes);
        return n.text || (n.text = r => r.text),
        n
    }
    static marksFromSchema(e) {
        return Gv(e.marks)
    }
}
function Gv(t) {
    let e = {};
    for (let n in t) {
        let r = t[n].spec.toDOM;
        r && (e[n] = r)
    }
    return e
}
function Tp(t) {
    return t.document || window.document
}
const Yv = new WeakMap;
function kE(t) {
    let e = Yv.get(t);
    return e === void 0 && Yv.set(t, e = ME(t)),
    e
}
function ME(t) {
    let e = null;
    function n(r) {
        if (r && typeof r == "object")
            if (Array.isArray(r))
                if (typeof r[0] == "string")
                    e || (e = []),
                    e.push(r);
                else
                    for (let o = 0; o < r.length; o++)
                        n(r[o]);
            else
                for (let o in r)
                    n(r[o])
    }
    return n(t),
    e
}
function yu(t, e, n, r) {
    if (typeof e == "string")
        return {
            dom: t.createTextNode(e)
        };
    if (e.nodeType != null)
        return {
            dom: e
        };
    if (e.dom && e.dom.nodeType != null)
        return e;
    let o = e[0], l;
    if (typeof o != "string")
        throw new RangeError("Invalid array passed to renderSpec");
    if (r && (l = kE(r)) && l.indexOf(e) > -1)
        throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let a = o.indexOf(" ");
    a > 0 && (n = o.slice(0, a),
    o = o.slice(a + 1));
    let u, f = n ? t.createElementNS(n, o) : t.createElement(o), h = e[1], p = 1;
    if (h && typeof h == "object" && h.nodeType == null && !Array.isArray(h)) {
        p = 2;
        for (let m in h)
            if (h[m] != null) {
                let y = m.indexOf(" ");
                y > 0 ? f.setAttributeNS(m.slice(0, y), m.slice(y + 1), h[m]) : m == "style" && f.style ? f.style.cssText = h[m] : f.setAttribute(m, h[m])
            }
    }
    for (let m = p; m < e.length; m++) {
        let y = e[m];
        if (y === 0) {
            if (m < e.length - 1 || m > p)
                throw new RangeError("Content hole must be the only child of its parent node");
            return {
                dom: f,
                contentDOM: f
            }
        } else {
            let {dom: b, contentDOM: C} = yu(t, y, n, r);
            if (f.appendChild(b),
            C) {
                if (u)
                    throw new RangeError("Multiple content holes");
                u = C
            }
        }
    }
    return {
        dom: f,
        contentDOM: u
    }
}
const VS = 65535
  , US = Math.pow(2, 16);
function AE(t, e) {
    return t + e * US
}
function Zv(t) {
    return t & VS
}
function NE(t) {
    return (t - (t & VS)) / US
}
const PS = 1
  , qS = 2
  , vu = 4
  , $S = 8;
class Cm {
    constructor(e, n, r) {
        this.pos = e,
        this.delInfo = n,
        this.recover = r
    }
    get deleted() {
        return (this.delInfo & $S) > 0
    }
    get deletedBefore() {
        return (this.delInfo & (PS | vu)) > 0
    }
    get deletedAfter() {
        return (this.delInfo & (qS | vu)) > 0
    }
    get deletedAcross() {
        return (this.delInfo & vu) > 0
    }
}
class un {
    constructor(e, n=!1) {
        if (this.ranges = e,
        this.inverted = n,
        !e.length && un.empty)
            return un.empty
    }
    recover(e) {
        let n = 0
          , r = Zv(e);
        if (!this.inverted)
            for (let o = 0; o < r; o++)
                n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
        return this.ranges[r * 3] + n + NE(e)
    }
    mapResult(e, n=1) {
        return this._map(e, n, !1)
    }
    map(e, n=1) {
        return this._map(e, n, !0)
    }
    _map(e, n, r) {
        let o = 0
          , l = this.inverted ? 2 : 1
          , a = this.inverted ? 1 : 2;
        for (let u = 0; u < this.ranges.length; u += 3) {
            let f = this.ranges[u] - (this.inverted ? o : 0);
            if (f > e)
                break;
            let h = this.ranges[u + l]
              , p = this.ranges[u + a]
              , m = f + h;
            if (e <= m) {
                let y = h ? e == f ? -1 : e == m ? 1 : n : n
                  , b = f + o + (y < 0 ? 0 : p);
                if (r)
                    return b;
                let C = e == (n < 0 ? f : m) ? null : AE(u / 3, e - f)
                  , S = e == f ? qS : e == m ? PS : vu;
                return (n < 0 ? e != f : e != m) && (S |= $S),
                new Cm(b,S,C)
            }
            o += p - h
        }
        return r ? e + o : new Cm(e + o,0,null)
    }
    touches(e, n) {
        let r = 0
          , o = Zv(n)
          , l = this.inverted ? 2 : 1
          , a = this.inverted ? 1 : 2;
        for (let u = 0; u < this.ranges.length; u += 3) {
            let f = this.ranges[u] - (this.inverted ? r : 0);
            if (f > e)
                break;
            let h = this.ranges[u + l]
              , p = f + h;
            if (e <= p && u == o * 3)
                return !0;
            r += this.ranges[u + a] - h
        }
        return !1
    }
    forEach(e) {
        let n = this.inverted ? 2 : 1
          , r = this.inverted ? 1 : 2;
        for (let o = 0, l = 0; o < this.ranges.length; o += 3) {
            let a = this.ranges[o]
              , u = a - (this.inverted ? l : 0)
              , f = a + (this.inverted ? 0 : l)
              , h = this.ranges[o + n]
              , p = this.ranges[o + r];
            e(u, u + h, f, f + p),
            l += p - h
        }
    }
    invert() {
        return new un(this.ranges,!this.inverted)
    }
    toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
    }
    static offset(e) {
        return e == 0 ? un.empty : new un(e < 0 ? [0, -e, 0] : [0, 0, e])
    }
}
un.empty = new un([]);
class ua {
    constructor(e, n, r=0, o=e ? e.length : 0) {
        this.mirror = n,
        this.from = r,
        this.to = o,
        this._maps = e || [],
        this.ownData = !(e || n)
    }
    get maps() {
        return this._maps
    }
    slice(e=0, n=this.maps.length) {
        return new ua(this._maps,this.mirror,e,n)
    }
    appendMap(e, n) {
        this.ownData || (this._maps = this._maps.slice(),
        this.mirror = this.mirror && this.mirror.slice(),
        this.ownData = !0),
        this.to = this._maps.push(e),
        n != null && this.setMirror(this._maps.length - 1, n)
    }
    appendMapping(e) {
        for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
            let o = e.getMirror(n);
            this.appendMap(e._maps[n], o != null && o < n ? r + o : void 0)
        }
    }
    getMirror(e) {
        if (this.mirror) {
            for (let n = 0; n < this.mirror.length; n++)
                if (this.mirror[n] == e)
                    return this.mirror[n + (n % 2 ? -1 : 1)]
        }
    }
    setMirror(e, n) {
        this.mirror || (this.mirror = []),
        this.mirror.push(e, n)
    }
    appendMappingInverted(e) {
        for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) {
            let o = e.getMirror(n);
            this.appendMap(e._maps[n].invert(), o != null && o > n ? r - o - 1 : void 0)
        }
    }
    invert() {
        let e = new ua;
        return e.appendMappingInverted(this),
        e
    }
    map(e, n=1) {
        if (this.mirror)
            return this._map(e, n, !0);
        for (let r = this.from; r < this.to; r++)
            e = this._maps[r].map(e, n);
        return e
    }
    mapResult(e, n=1) {
        return this._map(e, n, !1)
    }
    _map(e, n, r) {
        let o = 0;
        for (let l = this.from; l < this.to; l++) {
            let a = this._maps[l]
              , u = a.mapResult(e, n);
            if (u.recover != null) {
                let f = this.getMirror(l);
                if (f != null && f > l && f < this.to) {
                    l = f,
                    e = this._maps[f].recover(u.recover);
                    continue
                }
            }
            o |= u.delInfo,
            e = u.pos
        }
        return r ? e : new Cm(e,o,null)
    }
}
const kp = Object.create(null);
class zt {
    getMap() {
        return un.empty
    }
    merge(e) {
        return null
    }
    static fromJSON(e, n) {
        if (!n || !n.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
        let r = kp[n.stepType];
        if (!r)
            throw new RangeError(`No step type ${n.stepType} defined`);
        return r.fromJSON(e, n)
    }
    static jsonID(e, n) {
        if (e in kp)
            throw new RangeError("Duplicate use of step JSON ID " + e);
        return kp[e] = n,
        n.prototype.jsonID = e,
        n
    }
}
class ft {
    constructor(e, n) {
        this.doc = e,
        this.failed = n
    }
    static ok(e) {
        return new ft(e,null)
    }
    static fail(e) {
        return new ft(null,e)
    }
    static fromReplace(e, n, r, o) {
        try {
            return ft.ok(e.replace(n, r, o))
        } catch (l) {
            if (l instanceof Nu)
                return ft.fail(l.message);
            throw l
        }
    }
}
function m1(t, e, n) {
    let r = [];
    for (let o = 0; o < t.childCount; o++) {
        let l = t.child(o);
        l.content.size && (l = l.copy(m1(l.content, e, l))),
        l.isInline && (l = e(l, n, o)),
        r.push(l)
    }
    return Z.fromArray(r)
}
class yi extends zt {
    constructor(e, n, r) {
        super(),
        this.from = e,
        this.to = n,
        this.mark = r
    }
    apply(e) {
        let n = e.slice(this.from, this.to)
          , r = e.resolve(this.from)
          , o = r.node(r.sharedDepth(this.to))
          , l = new te(m1(n.content, (a, u) => !a.isAtom || !u.type.allowsMarkType(this.mark.type) ? a : a.mark(this.mark.addToSet(a.marks)), o),n.openStart,n.openEnd);
        return ft.fromReplace(e, this.from, this.to, l)
    }
    invert() {
        return new _n(this.from,this.to,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new yi(n.pos,r.pos,this.mark)
    }
    merge(e) {
        return e instanceof yi && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new yi(Math.min(this.from, e.from),Math.max(this.to, e.to),this.mark) : null
    }
    toJSON() {
        return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        return new yi(n.from,n.to,e.markFromJSON(n.mark))
    }
}
zt.jsonID("addMark", yi);
class _n extends zt {
    constructor(e, n, r) {
        super(),
        this.from = e,
        this.to = n,
        this.mark = r
    }
    apply(e) {
        let n = e.slice(this.from, this.to)
          , r = new te(m1(n.content, o => o.mark(this.mark.removeFromSet(o.marks)), e),n.openStart,n.openEnd);
        return ft.fromReplace(e, this.from, this.to, r)
    }
    invert() {
        return new yi(this.from,this.to,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1);
        return n.deleted && r.deleted || n.pos >= r.pos ? null : new _n(n.pos,r.pos,this.mark)
    }
    merge(e) {
        return e instanceof _n && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new _n(Math.min(this.from, e.from),Math.max(this.to, e.to),this.mark) : null
    }
    toJSON() {
        return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
        }
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        return new _n(n.from,n.to,e.markFromJSON(n.mark))
    }
}
zt.jsonID("removeMark", _n);
class vi extends zt {
    constructor(e, n) {
        super(),
        this.pos = e,
        this.mark = n
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return ft.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
        return ft.fromReplace(e, this.pos, this.pos + 1, new te(Z.from(r),0,n.isLeaf ? 0 : 1))
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        if (n) {
            let r = this.mark.addToSet(n.marks);
            if (r.length == n.marks.length) {
                for (let o = 0; o < n.marks.length; o++)
                    if (!n.marks[o].isInSet(r))
                        return new vi(this.pos,n.marks[o]);
                return new vi(this.pos,this.mark)
            }
        }
        return new bo(this.pos,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new vi(n.pos,this.mark)
    }
    toJSON() {
        return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
        return new vi(n.pos,e.markFromJSON(n.mark))
    }
}
zt.jsonID("addNodeMark", vi);
class bo extends zt {
    constructor(e, n) {
        super(),
        this.pos = e,
        this.mark = n
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return ft.fail("No node at mark step's position");
        let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
        return ft.fromReplace(e, this.pos, this.pos + 1, new te(Z.from(r),0,n.isLeaf ? 0 : 1))
    }
    invert(e) {
        let n = e.nodeAt(this.pos);
        return !n || !this.mark.isInSet(n.marks) ? this : new vi(this.pos,this.mark)
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new bo(n.pos,this.mark)
    }
    toJSON() {
        return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
        return new bo(n.pos,e.markFromJSON(n.mark))
    }
}
zt.jsonID("removeNodeMark", bo);
class gt extends zt {
    constructor(e, n, r, o=!1) {
        super(),
        this.from = e,
        this.to = n,
        this.slice = r,
        this.structure = o
    }
    apply(e) {
        return this.structure && Sm(e, this.from, this.to) ? ft.fail("Structure replace would overwrite content") : ft.fromReplace(e, this.from, this.to, this.slice)
    }
    getMap() {
        return new un([this.from, this.to - this.from, this.slice.size])
    }
    invert(e) {
        return new gt(this.from,this.from + this.slice.size,e.slice(this.from, this.to))
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1);
        return n.deletedAcross && r.deletedAcross ? null : new gt(n.pos,Math.max(n.pos, r.pos),this.slice,this.structure)
    }
    merge(e) {
        if (!(e instanceof gt) || e.structure || this.structure)
            return null;
        if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
            let n = this.slice.size + e.slice.size == 0 ? te.empty : new te(this.slice.content.append(e.slice.content),this.slice.openStart,e.slice.openEnd);
            return new gt(this.from,this.to + (e.to - e.from),n,this.structure)
        } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
            let n = this.slice.size + e.slice.size == 0 ? te.empty : new te(e.slice.content.append(this.slice.content),e.slice.openStart,this.slice.openEnd);
            return new gt(e.from,this.to,n,this.structure)
        } else
            return null
    }
    toJSON() {
        let e = {
            stepType: "replace",
            from: this.from,
            to: this.to
        };
        return this.slice.size && (e.slice = this.slice.toJSON()),
        this.structure && (e.structure = !0),
        e
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        return new gt(n.from,n.to,te.fromJSON(e, n.slice),!!n.structure)
    }
}
zt.jsonID("replace", gt);
class vt extends zt {
    constructor(e, n, r, o, l, a, u=!1) {
        super(),
        this.from = e,
        this.to = n,
        this.gapFrom = r,
        this.gapTo = o,
        this.slice = l,
        this.insert = a,
        this.structure = u
    }
    apply(e) {
        if (this.structure && (Sm(e, this.from, this.gapFrom) || Sm(e, this.gapTo, this.to)))
            return ft.fail("Structure gap-replace would overwrite content");
        let n = e.slice(this.gapFrom, this.gapTo);
        if (n.openStart || n.openEnd)
            return ft.fail("Gap is not a flat range");
        let r = this.slice.insertAt(this.insert, n.content);
        return r ? ft.fromReplace(e, this.from, this.to, r) : ft.fail("Content does not fit in gap")
    }
    getMap() {
        return new un([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
    }
    invert(e) {
        let n = this.gapTo - this.gapFrom;
        return new vt(this.from,this.from + this.slice.size + n,this.from + this.insert,this.from + this.insert + n,e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),this.gapFrom - this.from,this.structure)
    }
    map(e) {
        let n = e.mapResult(this.from, 1)
          , r = e.mapResult(this.to, -1)
          , o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1)
          , l = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
        return n.deletedAcross && r.deletedAcross || o < n.pos || l > r.pos ? null : new vt(n.pos,r.pos,o,l,this.slice,this.insert,this.structure)
    }
    toJSON() {
        let e = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
        };
        return this.slice.size && (e.slice = this.slice.toJSON()),
        this.structure && (e.structure = !0),
        e
    }
    static fromJSON(e, n) {
        if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        return new vt(n.from,n.to,n.gapFrom,n.gapTo,te.fromJSON(e, n.slice),n.insert,!!n.structure)
    }
}
zt.jsonID("replaceAround", vt);
function Sm(t, e, n) {
    let r = t.resolve(e)
      , o = n - e
      , l = r.depth;
    for (; o > 0 && l > 0 && r.indexAfter(l) == r.node(l).childCount; )
        l--,
        o--;
    if (o > 0) {
        let a = r.node(l).maybeChild(r.indexAfter(l));
        for (; o > 0; ) {
            if (!a || a.isLeaf)
                return !0;
            a = a.firstChild,
            o--
        }
    }
    return !1
}
function RE(t, e, n, r) {
    let o = [], l = [], a, u;
    t.doc.nodesBetween(e, n, (f, h, p) => {
        if (!f.isInline)
            return;
        let m = f.marks;
        if (!r.isInSet(m) && p.type.allowsMarkType(r.type)) {
            let y = Math.max(h, e)
              , b = Math.min(h + f.nodeSize, n)
              , C = r.addToSet(m);
            for (let S = 0; S < m.length; S++)
                m[S].isInSet(C) || (a && a.to == y && a.mark.eq(m[S]) ? a.to = b : o.push(a = new _n(y,b,m[S])));
            u && u.to == y ? u.to = b : l.push(u = new yi(y,b,r))
        }
    }
    ),
    o.forEach(f => t.step(f)),
    l.forEach(f => t.step(f))
}
function OE(t, e, n, r) {
    let o = []
      , l = 0;
    t.doc.nodesBetween(e, n, (a, u) => {
        if (!a.isInline)
            return;
        l++;
        let f = null;
        if (r instanceof Af) {
            let h = a.marks, p;
            for (; p = r.isInSet(h); )
                (f || (f = [])).push(p),
                h = p.removeFromSet(h)
        } else
            r ? r.isInSet(a.marks) && (f = [r]) : f = a.marks;
        if (f && f.length) {
            let h = Math.min(u + a.nodeSize, n);
            for (let p = 0; p < f.length; p++) {
                let m = f[p], y;
                for (let b = 0; b < o.length; b++) {
                    let C = o[b];
                    C.step == l - 1 && m.eq(o[b].style) && (y = C)
                }
                y ? (y.to = h,
                y.step = l) : o.push({
                    style: m,
                    from: Math.max(u, e),
                    to: h,
                    step: l
                })
            }
        }
    }
    ),
    o.forEach(a => t.step(new _n(a.from,a.to,a.style)))
}
function g1(t, e, n, r=n.contentMatch, o=!0) {
    let l = t.doc.nodeAt(e)
      , a = []
      , u = e + 1;
    for (let f = 0; f < l.childCount; f++) {
        let h = l.child(f)
          , p = u + h.nodeSize
          , m = r.matchType(h.type);
        if (!m)
            a.push(new gt(u,p,te.empty));
        else {
            r = m;
            for (let y = 0; y < h.marks.length; y++)
                n.allowsMarkType(h.marks[y].type) || t.step(new _n(u,p,h.marks[y]));
            if (o && h.isText && n.whitespace != "pre") {
                let y, b = /\r?\n|\r/g, C;
                for (; y = b.exec(h.text); )
                    C || (C = new te(Z.from(n.schema.text(" ", n.allowedMarks(h.marks))),0,0)),
                    a.push(new gt(u + y.index,u + y.index + y[0].length,C))
            }
        }
        u = p
    }
    if (!r.validEnd) {
        let f = r.fillBefore(Z.empty, !0);
        t.replace(u, u, new te(f,0,0))
    }
    for (let f = a.length - 1; f >= 0; f--)
        t.step(a[f])
}
function DE(t, e, n) {
    return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n))
}
function Ul(t) {
    let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
    for (let r = t.depth, o = 0, l = 0; ; --r) {
        let a = t.$from.node(r)
          , u = t.$from.index(r) + o
          , f = t.$to.indexAfter(r) - l;
        if (r < t.depth && a.canReplace(u, f, n))
            return r;
        if (r == 0 || a.type.spec.isolating || !DE(a, u, f))
            break;
        u && (o = 1),
        f < a.childCount && (l = 1)
    }
    return null
}
function LE(t, e, n) {
    let {$from: r, $to: o, depth: l} = e
      , a = r.before(l + 1)
      , u = o.after(l + 1)
      , f = a
      , h = u
      , p = Z.empty
      , m = 0;
    for (let C = l, S = !1; C > n; C--)
        S || r.index(C) > 0 ? (S = !0,
        p = Z.from(r.node(C).copy(p)),
        m++) : f--;
    let y = Z.empty
      , b = 0;
    for (let C = l, S = !1; C > n; C--)
        S || o.after(C + 1) < o.end(C) ? (S = !0,
        y = Z.from(o.node(C).copy(y)),
        b++) : h++;
    t.step(new vt(f,h,a,u,new te(p.append(y),m,b),p.size - m,!0))
}
function y1(t, e, n=null, r=t) {
    let o = zE(t, e)
      , l = o && _E(r, e);
    return l ? o.map(Wv).concat({
        type: e,
        attrs: n
    }).concat(l.map(Wv)) : null
}
function Wv(t) {
    return {
        type: t,
        attrs: null
    }
}
function zE(t, e) {
    let {parent: n, startIndex: r, endIndex: o} = t
      , l = n.contentMatchAt(r).findWrapping(e);
    if (!l)
        return null;
    let a = l.length ? l[0] : e;
    return n.canReplaceWith(r, o, a) ? l : null
}
function _E(t, e) {
    let {parent: n, startIndex: r, endIndex: o} = t
      , l = n.child(r)
      , a = e.contentMatch.findWrapping(l.type);
    if (!a)
        return null;
    let f = (a.length ? a[a.length - 1] : e).contentMatch;
    for (let h = r; f && h < o; h++)
        f = f.matchType(n.child(h).type);
    return !f || !f.validEnd ? null : a
}
function BE(t, e, n) {
    let r = Z.empty;
    for (let a = n.length - 1; a >= 0; a--) {
        if (r.size) {
            let u = n[a].type.contentMatch.matchFragment(r);
            if (!u || !u.validEnd)
                throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper")
        }
        r = Z.from(n[a].type.create(n[a].attrs, r))
    }
    let o = e.start
      , l = e.end;
    t.step(new vt(o,l,o,l,new te(r,0,0),n.length,!0))
}
function jE(t, e, n, r, o) {
    if (!r.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
    let l = t.steps.length;
    t.doc.nodesBetween(e, n, (a, u) => {
        let f = typeof o == "function" ? o(a) : o;
        if (a.isTextblock && !a.hasMarkup(r, f) && HE(t.doc, t.mapping.slice(l).map(u), r)) {
            let h = null;
            if (r.schema.linebreakReplacement) {
                let b = r.whitespace == "pre"
                  , C = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
                b && !C ? h = !1 : !b && C && (h = !0)
            }
            h === !1 && KS(t, a, u, l),
            g1(t, t.mapping.slice(l).map(u, 1), r, void 0, h === null);
            let p = t.mapping.slice(l)
              , m = p.map(u, 1)
              , y = p.map(u + a.nodeSize, 1);
            return t.step(new vt(m,y,m + 1,y - 1,new te(Z.from(r.create(f, null, a.marks)),0,0),1,!0)),
            h === !0 && FS(t, a, u, l),
            !1
        }
    }
    )
}
function FS(t, e, n, r) {
    e.forEach( (o, l) => {
        if (o.isText) {
            let a, u = /\r?\n|\r/g;
            for (; a = u.exec(o.text); ) {
                let f = t.mapping.slice(r).map(n + 1 + l + a.index);
                t.replaceWith(f, f + 1, e.type.schema.linebreakReplacement.create())
            }
        }
    }
    )
}
function KS(t, e, n, r) {
    e.forEach( (o, l) => {
        if (o.type == o.type.schema.linebreakReplacement) {
            let a = t.mapping.slice(r).map(n + 1 + l);
            t.replaceWith(a, a + 1, e.type.schema.text(`
`))
        }
    }
    )
}
function HE(t, e, n) {
    let r = t.resolve(e)
      , o = r.index();
    return r.parent.canReplaceWith(o, o + 1, n)
}
function IE(t, e, n, r, o) {
    let l = t.doc.nodeAt(e);
    if (!l)
        throw new RangeError("No node at given position");
    n || (n = l.type);
    let a = n.create(r, null, o || l.marks);
    if (l.isLeaf)
        return t.replaceWith(e, e + l.nodeSize, a);
    if (!n.validContent(l.content))
        throw new RangeError("Invalid content for node type " + n.name);
    t.step(new vt(e,e + l.nodeSize,e + 1,e + l.nodeSize - 1,new te(Z.from(a),0,0),1,!0))
}
function Ar(t, e, n=1, r) {
    let o = t.resolve(e)
      , l = o.depth - n
      , a = r && r[r.length - 1] || o.parent;
    if (l < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !a.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
        return !1;
    for (let h = o.depth - 1, p = n - 2; h > l; h--,
    p--) {
        let m = o.node(h)
          , y = o.index(h);
        if (m.type.spec.isolating)
            return !1;
        let b = m.content.cutByIndex(y, m.childCount)
          , C = r && r[p + 1];
        C && (b = b.replaceChild(0, C.type.create(C.attrs)));
        let S = r && r[p] || m;
        if (!m.canReplace(y + 1, m.childCount) || !S.type.validContent(b))
            return !1
    }
    let u = o.indexAfter(l)
      , f = r && r[0];
    return o.node(l).canReplaceWith(u, u, f ? f.type : o.node(l + 1).type)
}
function VE(t, e, n=1, r) {
    let o = t.doc.resolve(e)
      , l = Z.empty
      , a = Z.empty;
    for (let u = o.depth, f = o.depth - n, h = n - 1; u > f; u--,
    h--) {
        l = Z.from(o.node(u).copy(l));
        let p = r && r[h];
        a = Z.from(p ? p.type.create(p.attrs, a) : o.node(u).copy(a))
    }
    t.step(new gt(e,e,new te(l.append(a),n,n),!0))
}
function Di(t, e) {
    let n = t.resolve(e)
      , r = n.index();
    return GS(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1)
}
function UE(t, e) {
    e.content.size || t.type.compatibleContent(e.type);
    let n = t.contentMatchAt(t.childCount)
      , {linebreakReplacement: r} = t.type.schema;
    for (let o = 0; o < e.childCount; o++) {
        let l = e.child(o)
          , a = l.type == r ? t.type.schema.nodes.text : l.type;
        if (n = n.matchType(a),
        !n || !t.type.allowsMarks(l.marks))
            return !1
    }
    return n.validEnd
}
function GS(t, e) {
    return !!(t && e && !t.isLeaf && UE(t, e))
}
function Nf(t, e, n=-1) {
    let r = t.resolve(e);
    for (let o = r.depth; ; o--) {
        let l, a, u = r.index(o);
        if (o == r.depth ? (l = r.nodeBefore,
        a = r.nodeAfter) : n > 0 ? (l = r.node(o + 1),
        u++,
        a = r.node(o).maybeChild(u)) : (l = r.node(o).maybeChild(u - 1),
        a = r.node(o + 1)),
        l && !l.isTextblock && GS(l, a) && r.node(o).canReplace(u, u + 1))
            return e;
        if (o == 0)
            break;
        e = n < 0 ? r.before(o) : r.after(o)
    }
}
function PE(t, e, n) {
    let r = null
      , {linebreakReplacement: o} = t.doc.type.schema
      , l = t.doc.resolve(e - n)
      , a = l.node().type;
    if (o && a.inlineContent) {
        let p = a.whitespace == "pre"
          , m = !!a.contentMatch.matchType(o);
        p && !m ? r = !1 : !p && m && (r = !0)
    }
    let u = t.steps.length;
    if (r === !1) {
        let p = t.doc.resolve(e + n);
        KS(t, p.node(), p.before(), u)
    }
    a.inlineContent && g1(t, e + n - 1, a, l.node().contentMatchAt(l.index()), r == null);
    let f = t.mapping.slice(u)
      , h = f.map(e - n);
    if (t.step(new gt(h,f.map(e + n, -1),te.empty,!0)),
    r === !0) {
        let p = t.doc.resolve(h);
        FS(t, p.node(), p.before(), t.steps.length)
    }
    return t
}
function qE(t, e, n) {
    let r = t.resolve(e);
    if (r.parent.canReplaceWith(r.index(), r.index(), n))
        return e;
    if (r.parentOffset == 0)
        for (let o = r.depth - 1; o >= 0; o--) {
            let l = r.index(o);
            if (r.node(o).canReplaceWith(l, l, n))
                return r.before(o + 1);
            if (l > 0)
                return null
        }
    if (r.parentOffset == r.parent.content.size)
        for (let o = r.depth - 1; o >= 0; o--) {
            let l = r.indexAfter(o);
            if (r.node(o).canReplaceWith(l, l, n))
                return r.after(o + 1);
            if (l < r.node(o).childCount)
                return null
        }
    return null
}
function YS(t, e, n) {
    let r = t.resolve(e);
    if (!n.content.size)
        return e;
    let o = n.content;
    for (let l = 0; l < n.openStart; l++)
        o = o.firstChild.content;
    for (let l = 1; l <= (n.openStart == 0 && n.size ? 2 : 1); l++)
        for (let a = r.depth; a >= 0; a--) {
            let u = a == r.depth ? 0 : r.pos <= (r.start(a + 1) + r.end(a + 1)) / 2 ? -1 : 1
              , f = r.index(a) + (u > 0 ? 1 : 0)
              , h = r.node(a)
              , p = !1;
            if (l == 1)
                p = h.canReplace(f, f, o);
            else {
                let m = h.contentMatchAt(f).findWrapping(o.firstChild.type);
                p = m && h.canReplaceWith(f, f, m[0])
            }
            if (p)
                return u == 0 ? r.pos : u < 0 ? r.before(a + 1) : r.after(a + 1)
        }
    return null
}
function Rf(t, e, n=e, r=te.empty) {
    if (e == n && !r.size)
        return null;
    let o = t.resolve(e)
      , l = t.resolve(n);
    return ZS(o, l, r) ? new gt(e,n,r) : new $E(o,l,r).fit()
}
function ZS(t, e, n) {
    return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content)
}
class $E {
    constructor(e, n, r) {
        this.$from = e,
        this.$to = n,
        this.unplaced = r,
        this.frontier = [],
        this.placed = Z.empty;
        for (let o = 0; o <= e.depth; o++) {
            let l = e.node(o);
            this.frontier.push({
                type: l.type,
                match: l.contentMatchAt(e.indexAfter(o))
            })
        }
        for (let o = e.depth; o > 0; o--)
            this.placed = Z.from(e.node(o).copy(this.placed))
    }
    get depth() {
        return this.frontier.length - 1
    }
    fit() {
        for (; this.unplaced.size; ) {
            let h = this.findFittable();
            h ? this.placeNodes(h) : this.openMore() || this.dropNode()
        }
        let e = this.mustMoveInline()
          , n = this.placed.size - this.depth - this.$from.depth
          , r = this.$from
          , o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
        if (!o)
            return null;
        let l = this.placed
          , a = r.depth
          , u = o.depth;
        for (; a && u && l.childCount == 1; )
            l = l.firstChild.content,
            a--,
            u--;
        let f = new te(l,a,u);
        return e > -1 ? new vt(r.pos,e,this.$to.pos,this.$to.end(),f,n) : f.size || r.pos != this.$to.pos ? new gt(r.pos,o.pos,f) : null
    }
    findFittable() {
        let e = this.unplaced.openStart;
        for (let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
            let l = n.firstChild;
            if (n.childCount > 1 && (o = 0),
            l.type.spec.isolating && o <= r) {
                e = r;
                break
            }
            n = l.content
        }
        for (let n = 1; n <= 2; n++)
            for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
                let o, l = null;
                r ? (l = Mp(this.unplaced.content, r - 1).firstChild,
                o = l.content) : o = this.unplaced.content;
                let a = o.firstChild;
                for (let u = this.depth; u >= 0; u--) {
                    let {type: f, match: h} = this.frontier[u], p, m = null;
                    if (n == 1 && (a ? h.matchType(a.type) || (m = h.fillBefore(Z.from(a), !1)) : l && f.compatibleContent(l.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: u,
                            parent: l,
                            inject: m
                        };
                    if (n == 2 && a && (p = h.findWrapping(a.type)))
                        return {
                            sliceDepth: r,
                            frontierDepth: u,
                            parent: l,
                            wrap: p
                        };
                    if (l && h.matchType(l.type))
                        break
                }
            }
    }
    openMore() {
        let {content: e, openStart: n, openEnd: r} = this.unplaced
          , o = Mp(e, n);
        return !o.childCount || o.firstChild.isLeaf ? !1 : (this.unplaced = new te(e,n + 1,Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)),
        !0)
    }
    dropNode() {
        let {content: e, openStart: n, openEnd: r} = this.unplaced
          , o = Mp(e, n);
        if (o.childCount <= 1 && n > 0) {
            let l = e.size - n <= n + o.size;
            this.unplaced = new te($s(e, n - 1, 1),n - 1,l ? n - 1 : r)
        } else
            this.unplaced = new te($s(e, n, 1),n,r)
    }
    placeNodes({sliceDepth: e, frontierDepth: n, parent: r, inject: o, wrap: l}) {
        for (; this.depth > n; )
            this.closeFrontierNode();
        if (l)
            for (let S = 0; S < l.length; S++)
                this.openFrontierNode(l[S]);
        let a = this.unplaced
          , u = r ? r.content : a.content
          , f = a.openStart - e
          , h = 0
          , p = []
          , {match: m, type: y} = this.frontier[n];
        if (o) {
            for (let S = 0; S < o.childCount; S++)
                p.push(o.child(S));
            m = m.matchFragment(o)
        }
        let b = u.size + e - (a.content.size - a.openEnd);
        for (; h < u.childCount; ) {
            let S = u.child(h)
              , w = m.matchType(S.type);
            if (!w)
                break;
            h++,
            (h > 1 || f == 0 || S.content.size) && (m = w,
            p.push(WS(S.mark(y.allowedMarks(S.marks)), h == 1 ? f : 0, h == u.childCount ? b : -1)))
        }
        let C = h == u.childCount;
        C || (b = -1),
        this.placed = Fs(this.placed, n, Z.from(p)),
        this.frontier[n].match = m,
        C && b < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
        for (let S = 0, w = u; S < b; S++) {
            let k = w.lastChild;
            this.frontier.push({
                type: k.type,
                match: k.contentMatchAt(k.childCount)
            }),
            w = k.content
        }
        this.unplaced = C ? e == 0 ? te.empty : new te($s(a.content, e - 1, 1),e - 1,b < 0 ? a.openEnd : e - 1) : new te($s(a.content, e, h),a.openStart,a.openEnd)
    }
    mustMoveInline() {
        if (!this.$to.parent.isTextblock)
            return -1;
        let e = this.frontier[this.depth], n;
        if (!e.type.isTextblock || !Ap(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
            return -1;
        let {depth: r} = this.$to
          , o = this.$to.after(r);
        for (; r > 1 && o == this.$to.end(--r); )
            ++o;
        return o
    }
    findCloseLevel(e) {
        e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
            let {match: r, type: o} = this.frontier[n]
              , l = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1))
              , a = Ap(e, n, o, r, l);
            if (a) {
                for (let u = n - 1; u >= 0; u--) {
                    let {match: f, type: h} = this.frontier[u]
                      , p = Ap(e, u, h, f, !0);
                    if (!p || p.childCount)
                        continue e
                }
                return {
                    depth: n,
                    fit: a,
                    move: l ? e.doc.resolve(e.after(n + 1)) : e
                }
            }
        }
    }
    close(e) {
        let n = this.findCloseLevel(e);
        if (!n)
            return null;
        for (; this.depth > n.depth; )
            this.closeFrontierNode();
        n.fit.childCount && (this.placed = Fs(this.placed, n.depth, n.fit)),
        e = n.move;
        for (let r = n.depth + 1; r <= e.depth; r++) {
            let o = e.node(r)
              , l = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
            this.openFrontierNode(o.type, o.attrs, l)
        }
        return e
    }
    openFrontierNode(e, n=null, r) {
        let o = this.frontier[this.depth];
        o.match = o.match.matchType(e),
        this.placed = Fs(this.placed, this.depth, Z.from(e.create(n, r))),
        this.frontier.push({
            type: e,
            match: e.contentMatch
        })
    }
    closeFrontierNode() {
        let n = this.frontier.pop().match.fillBefore(Z.empty, !0);
        n.childCount && (this.placed = Fs(this.placed, this.frontier.length, n))
    }
}
function $s(t, e, n) {
    return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy($s(t.firstChild.content, e - 1, n)))
}
function Fs(t, e, n) {
    return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Fs(t.lastChild.content, e - 1, n)))
}
function Mp(t, e) {
    for (let n = 0; n < e; n++)
        t = t.firstChild.content;
    return t
}
function WS(t, e, n) {
    if (e <= 0)
        return t;
    let r = t.content;
    return e > 1 && (r = r.replaceChild(0, WS(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))),
    e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r),
    n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(Z.empty, !0)))),
    t.copy(r)
}
function Ap(t, e, n, r, o) {
    let l = t.node(e)
      , a = o ? t.indexAfter(e) : t.index(e);
    if (a == l.childCount && !n.compatibleContent(l.type))
        return null;
    let u = r.fillBefore(l.content, !0, a);
    return u && !FE(n, l.content, a) ? u : null
}
function FE(t, e, n) {
    for (let r = n; r < e.childCount; r++)
        if (!t.allowsMarks(e.child(r).marks))
            return !0;
    return !1
}
function KE(t) {
    return t.spec.defining || t.spec.definingForContent
}
function GE(t, e, n, r) {
    if (!r.size)
        return t.deleteRange(e, n);
    let o = t.doc.resolve(e)
      , l = t.doc.resolve(n);
    if (ZS(o, l, r))
        return t.step(new gt(e,n,r));
    let a = JS(o, l);
    a[a.length - 1] == 0 && a.pop();
    let u = -(o.depth + 1);
    a.unshift(u);
    for (let y = o.depth, b = o.pos - 1; y > 0; y--,
    b--) {
        let C = o.node(y).type.spec;
        if (C.defining || C.definingAsContext || C.isolating)
            break;
        a.indexOf(y) > -1 ? u = y : o.before(y) == b && a.splice(1, 0, -y)
    }
    let f = a.indexOf(u)
      , h = []
      , p = r.openStart;
    for (let y = r.content, b = 0; ; b++) {
        let C = y.firstChild;
        if (h.push(C),
        b == r.openStart)
            break;
        y = C.content
    }
    for (let y = p - 1; y >= 0; y--) {
        let b = h[y]
          , C = KE(b.type);
        if (C && !b.sameMarkup(o.node(Math.abs(u) - 1)))
            p = y;
        else if (C || !b.type.isTextblock)
            break
    }
    for (let y = r.openStart; y >= 0; y--) {
        let b = (y + p + 1) % (r.openStart + 1)
          , C = h[b];
        if (C)
            for (let S = 0; S < a.length; S++) {
                let w = a[(S + f) % a.length]
                  , k = !0;
                w < 0 && (k = !1,
                w = -w);
                let A = o.node(w - 1)
                  , O = o.index(w - 1);
                if (A.canReplaceWith(O, O, C.type, C.marks))
                    return t.replace(o.before(w), k ? l.after(w) : n, new te(XS(r.content, 0, r.openStart, b),b,r.openEnd))
            }
    }
    let m = t.steps.length;
    for (let y = a.length - 1; y >= 0 && (t.replace(e, n, r),
    !(t.steps.length > m)); y--) {
        let b = a[y];
        b < 0 || (e = o.before(b),
        n = l.after(b))
    }
}
function XS(t, e, n, r, o) {
    if (e < n) {
        let l = t.firstChild;
        t = t.replaceChild(0, l.copy(XS(l.content, e + 1, n, r, l)))
    }
    if (e > r) {
        let l = o.contentMatchAt(0)
          , a = l.fillBefore(t).append(t);
        t = a.append(l.matchFragment(a).fillBefore(Z.empty, !0))
    }
    return t
}
function YE(t, e, n, r) {
    if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
        let o = qE(t.doc, e, r.type);
        o != null && (e = n = o)
    }
    t.replaceRange(e, n, new te(Z.from(r),0,0))
}
function ZE(t, e, n) {
    let r = t.doc.resolve(e)
      , o = t.doc.resolve(n)
      , l = JS(r, o);
    for (let a = 0; a < l.length; a++) {
        let u = l[a]
          , f = a == l.length - 1;
        if (f && u == 0 || r.node(u).type.contentMatch.validEnd)
            return t.delete(r.start(u), o.end(u));
        if (u > 0 && (f || r.node(u - 1).canReplace(r.index(u - 1), o.indexAfter(u - 1))))
            return t.delete(r.before(u), o.after(u))
    }
    for (let a = 1; a <= r.depth && a <= o.depth; a++)
        if (e - r.start(a) == r.depth - a && n > r.end(a) && o.end(a) - n != o.depth - a && r.start(a - 1) == o.start(a - 1) && r.node(a - 1).canReplace(r.index(a - 1), o.index(a - 1)))
            return t.delete(r.before(a), n);
    t.delete(e, n)
}
function JS(t, e) {
    let n = []
      , r = Math.min(t.depth, e.depth);
    for (let o = r; o >= 0; o--) {
        let l = t.start(o);
        if (l < t.pos - (t.depth - o) || e.end(o) > e.pos + (e.depth - o) || t.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
            break;
        (l == e.start(o) || o == t.depth && o == e.depth && t.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == l - 1) && n.push(o)
    }
    return n
}
class Ml extends zt {
    constructor(e, n, r) {
        super(),
        this.pos = e,
        this.attr = n,
        this.value = r
    }
    apply(e) {
        let n = e.nodeAt(this.pos);
        if (!n)
            return ft.fail("No node at attribute step's position");
        let r = Object.create(null);
        for (let l in n.attrs)
            r[l] = n.attrs[l];
        r[this.attr] = this.value;
        let o = n.type.create(r, null, n.marks);
        return ft.fromReplace(e, this.pos, this.pos + 1, new te(Z.from(o),0,n.isLeaf ? 0 : 1))
    }
    getMap() {
        return un.empty
    }
    invert(e) {
        return new Ml(this.pos,this.attr,e.nodeAt(this.pos).attrs[this.attr])
    }
    map(e) {
        let n = e.mapResult(this.pos, 1);
        return n.deletedAfter ? null : new Ml(n.pos,this.attr,this.value)
    }
    toJSON() {
        return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number" || typeof n.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
        return new Ml(n.pos,n.attr,n.value)
    }
}
zt.jsonID("attr", Ml);
class fa extends zt {
    constructor(e, n) {
        super(),
        this.attr = e,
        this.value = n
    }
    apply(e) {
        let n = Object.create(null);
        for (let o in e.attrs)
            n[o] = e.attrs[o];
        n[this.attr] = this.value;
        let r = e.type.create(n, e.content, e.marks);
        return ft.ok(r)
    }
    getMap() {
        return un.empty
    }
    invert(e) {
        return new fa(this.attr,e.attrs[this.attr])
    }
    map(e) {
        return this
    }
    toJSON() {
        return {
            stepType: "docAttr",
            attr: this.attr,
            value: this.value
        }
    }
    static fromJSON(e, n) {
        if (typeof n.attr != "string")
            throw new RangeError("Invalid input for DocAttrStep.fromJSON");
        return new fa(n.attr,n.value)
    }
}
zt.jsonID("docAttr", fa);
let Ol = class extends Error {
}
;
Ol = function t(e) {
    let n = Error.call(this, e);
    return n.__proto__ = t.prototype,
    n
}
;
Ol.prototype = Object.create(Error.prototype);
Ol.prototype.constructor = Ol;
Ol.prototype.name = "TransformError";
class v1 {
    constructor(e) {
        this.doc = e,
        this.steps = [],
        this.docs = [],
        this.mapping = new ua
    }
    get before() {
        return this.docs.length ? this.docs[0] : this.doc
    }
    step(e) {
        let n = this.maybeStep(e);
        if (n.failed)
            throw new Ol(n.failed);
        return this
    }
    maybeStep(e) {
        let n = e.apply(this.doc);
        return n.failed || this.addStep(e, n.doc),
        n
    }
    get docChanged() {
        return this.steps.length > 0
    }
    changedRange() {
        let e = 1e9
          , n = -1e9;
        for (let r = 0; r < this.mapping.maps.length; r++) {
            let o = this.mapping.maps[r];
            r && (e = o.map(e, 1),
            n = o.map(n, -1)),
            o.forEach( (l, a, u, f) => {
                e = Math.min(e, u),
                n = Math.max(n, f)
            }
            )
        }
        return e == 1e9 ? null : {
            from: e,
            to: n
        }
    }
    addStep(e, n) {
        this.docs.push(this.doc),
        this.steps.push(e),
        this.mapping.appendMap(e.getMap()),
        this.doc = n
    }
    replace(e, n=e, r=te.empty) {
        let o = Rf(this.doc, e, n, r);
        return o && this.step(o),
        this
    }
    replaceWith(e, n, r) {
        return this.replace(e, n, new te(Z.from(r),0,0))
    }
    delete(e, n) {
        return this.replace(e, n, te.empty)
    }
    insert(e, n) {
        return this.replaceWith(e, e, n)
    }
    replaceRange(e, n, r) {
        return GE(this, e, n, r),
        this
    }
    replaceRangeWith(e, n, r) {
        return YE(this, e, n, r),
        this
    }
    deleteRange(e, n) {
        return ZE(this, e, n),
        this
    }
    lift(e, n) {
        return LE(this, e, n),
        this
    }
    join(e, n=1) {
        return PE(this, e, n),
        this
    }
    wrap(e, n) {
        return BE(this, e, n),
        this
    }
    setBlockType(e, n=e, r, o=null) {
        return jE(this, e, n, r, o),
        this
    }
    setNodeMarkup(e, n, r=null, o) {
        return IE(this, e, n, r, o),
        this
    }
    setNodeAttribute(e, n, r) {
        return this.step(new Ml(e,n,r)),
        this
    }
    setDocAttribute(e, n) {
        return this.step(new fa(e,n)),
        this
    }
    addNodeMark(e, n) {
        return this.step(new vi(e,n)),
        this
    }
    removeNodeMark(e, n) {
        let r = this.doc.nodeAt(e);
        if (!r)
            throw new RangeError("No node at position " + e);
        if (n instanceof Ve)
            n.isInSet(r.marks) && this.step(new bo(e,n));
        else {
            let o = r.marks, l, a = [];
            for (; l = n.isInSet(o); )
                a.push(new bo(e,l)),
                o = l.removeFromSet(o);
            for (let u = a.length - 1; u >= 0; u--)
                this.step(a[u])
        }
        return this
    }
    split(e, n=1, r) {
        return VE(this, e, n, r),
        this
    }
    addMark(e, n, r) {
        return RE(this, e, n, r),
        this
    }
    removeMark(e, n, r) {
        return OE(this, e, n, r),
        this
    }
    clearIncompatible(e, n, r) {
        return g1(this, e, n, r),
        this
    }
}
const Np = Object.create(null);
class ye {
    constructor(e, n, r) {
        this.$anchor = e,
        this.$head = n,
        this.ranges = r || [new QS(e.min(n),e.max(n))]
    }
    get anchor() {
        return this.$anchor.pos
    }
    get head() {
        return this.$head.pos
    }
    get from() {
        return this.$from.pos
    }
    get to() {
        return this.$to.pos
    }
    get $from() {
        return this.ranges[0].$from
    }
    get $to() {
        return this.ranges[0].$to
    }
    get empty() {
        let e = this.ranges;
        for (let n = 0; n < e.length; n++)
            if (e[n].$from.pos != e[n].$to.pos)
                return !1;
        return !0
    }
    content() {
        return this.$from.doc.slice(this.from, this.to, !0)
    }
    replace(e, n=te.empty) {
        let r = n.content.lastChild
          , o = null;
        for (let u = 0; u < n.openEnd; u++)
            o = r,
            r = r.lastChild;
        let l = e.steps.length
          , a = this.ranges;
        for (let u = 0; u < a.length; u++) {
            let {$from: f, $to: h} = a[u]
              , p = e.mapping.slice(l);
            e.replaceRange(p.map(f.pos), p.map(h.pos), u ? te.empty : n),
            u == 0 && Qv(e, l, (r ? r.isInline : o && o.isTextblock) ? -1 : 1)
        }
    }
    replaceWith(e, n) {
        let r = e.steps.length
          , o = this.ranges;
        for (let l = 0; l < o.length; l++) {
            let {$from: a, $to: u} = o[l]
              , f = e.mapping.slice(r)
              , h = f.map(a.pos)
              , p = f.map(u.pos);
            l ? e.deleteRange(h, p) : (e.replaceRangeWith(h, p, n),
            Qv(e, r, n.isInline ? -1 : 1))
        }
    }
    static findFrom(e, n, r=!1) {
        let o = e.parent.inlineContent ? new se(e) : Sl(e.node(0), e.parent, e.pos, e.index(), n, r);
        if (o)
            return o;
        for (let l = e.depth - 1; l >= 0; l--) {
            let a = n < 0 ? Sl(e.node(0), e.node(l), e.before(l + 1), e.index(l), n, r) : Sl(e.node(0), e.node(l), e.after(l + 1), e.index(l) + 1, n, r);
            if (a)
                return a
        }
        return null
    }
    static near(e, n=1) {
        return this.findFrom(e, n) || this.findFrom(e, -n) || new Zt(e.node(0))
    }
    static atStart(e) {
        return Sl(e, e, 0, 0, 1) || new Zt(e)
    }
    static atEnd(e) {
        return Sl(e, e, e.content.size, e.childCount, -1) || new Zt(e)
    }
    static fromJSON(e, n) {
        if (!n || !n.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
        let r = Np[n.type];
        if (!r)
            throw new RangeError(`No selection type ${n.type} defined`);
        return r.fromJSON(e, n)
    }
    static jsonID(e, n) {
        if (e in Np)
            throw new RangeError("Duplicate use of selection JSON ID " + e);
        return Np[e] = n,
        n.prototype.jsonID = e,
        n
    }
    getBookmark() {
        return se.between(this.$anchor, this.$head).getBookmark()
    }
}
ye.prototype.visible = !0;
class QS {
    constructor(e, n) {
        this.$from = e,
        this.$to = n
    }
}
let Xv = !1;
function Jv(t) {
    !Xv && !t.parent.inlineContent && (Xv = !0,
    console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"))
}
class se extends ye {
    constructor(e, n=e) {
        Jv(e),
        Jv(n),
        super(e, n)
    }
    get $cursor() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        if (!r.parent.inlineContent)
            return ye.near(r);
        let o = e.resolve(n.map(this.anchor));
        return new se(o.parent.inlineContent ? o : r,r)
    }
    replace(e, n=te.empty) {
        if (super.replace(e, n),
        n == te.empty) {
            let r = this.$from.marksAcross(this.$to);
            r && e.ensureMarks(r)
        }
    }
    eq(e) {
        return e instanceof se && e.anchor == this.anchor && e.head == this.head
    }
    getBookmark() {
        return new Of(this.anchor,this.head)
    }
    toJSON() {
        return {
            type: "text",
            anchor: this.anchor,
            head: this.head
        }
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != "number" || typeof n.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new se(e.resolve(n.anchor),e.resolve(n.head))
    }
    static create(e, n, r=n) {
        let o = e.resolve(n);
        return new this(o,r == n ? o : e.resolve(r))
    }
    static between(e, n, r) {
        let o = e.pos - n.pos;
        if ((!r || o) && (r = o >= 0 ? 1 : -1),
        !n.parent.inlineContent) {
            let l = ye.findFrom(n, r, !0) || ye.findFrom(n, -r, !0);
            if (l)
                n = l.$head;
            else
                return ye.near(n, r)
        }
        return e.parent.inlineContent || (o == 0 ? e = n : (e = (ye.findFrom(e, -r, !0) || ye.findFrom(e, r, !0)).$anchor,
        e.pos < n.pos != o < 0 && (e = n))),
        new se(e,n)
    }
}
ye.jsonID("text", se);
class Of {
    constructor(e, n) {
        this.anchor = e,
        this.head = n
    }
    map(e) {
        return new Of(e.map(this.anchor),e.map(this.head))
    }
    resolve(e) {
        return se.between(e.resolve(this.anchor), e.resolve(this.head))
    }
}
class le extends ye {
    constructor(e) {
        let n = e.nodeAfter
          , r = e.node(0).resolve(e.pos + n.nodeSize);
        super(e, r),
        this.node = n
    }
    map(e, n) {
        let {deleted: r, pos: o} = n.mapResult(this.anchor)
          , l = e.resolve(o);
        return r ? ye.near(l) : new le(l)
    }
    content() {
        return new te(Z.from(this.node),0,0)
    }
    eq(e) {
        return e instanceof le && e.anchor == this.anchor
    }
    toJSON() {
        return {
            type: "node",
            anchor: this.anchor
        }
    }
    getBookmark() {
        return new b1(this.anchor)
    }
    static fromJSON(e, n) {
        if (typeof n.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new le(e.resolve(n.anchor))
    }
    static create(e, n) {
        return new le(e.resolve(n))
    }
    static isSelectable(e) {
        return !e.isText && e.type.spec.selectable !== !1
    }
}
le.prototype.visible = !1;
ye.jsonID("node", le);
class b1 {
    constructor(e) {
        this.anchor = e
    }
    map(e) {
        let {deleted: n, pos: r} = e.mapResult(this.anchor);
        return n ? new Of(r,r) : new b1(r)
    }
    resolve(e) {
        let n = e.resolve(this.anchor)
          , r = n.nodeAfter;
        return r && le.isSelectable(r) ? new le(n) : ye.near(n)
    }
}
class Zt extends ye {
    constructor(e) {
        super(e.resolve(0), e.resolve(e.content.size))
    }
    replace(e, n=te.empty) {
        if (n == te.empty) {
            e.delete(0, e.doc.content.size);
            let r = ye.atStart(e.doc);
            r.eq(e.selection) || e.setSelection(r)
        } else
            super.replace(e, n)
    }
    toJSON() {
        return {
            type: "all"
        }
    }
    static fromJSON(e) {
        return new Zt(e)
    }
    map(e) {
        return new Zt(e)
    }
    eq(e) {
        return e instanceof Zt
    }
    getBookmark() {
        return WE
    }
}
ye.jsonID("all", Zt);
const WE = {
    map() {
        return this
    },
    resolve(t) {
        return new Zt(t)
    }
};
function Sl(t, e, n, r, o, l=!1) {
    if (e.inlineContent)
        return se.create(t, n);
    for (let a = r - (o > 0 ? 0 : 1); o > 0 ? a < e.childCount : a >= 0; a += o) {
        let u = e.child(a);
        if (u.isAtom) {
            if (!l && le.isSelectable(u))
                return le.create(t, n - (o < 0 ? u.nodeSize : 0))
        } else {
            let f = Sl(t, u, n + o, o < 0 ? u.childCount : 0, o, l);
            if (f)
                return f
        }
        n += u.nodeSize * o
    }
    return null
}
function Qv(t, e, n) {
    let r = t.steps.length - 1;
    if (r < e)
        return;
    let o = t.steps[r];
    if (!(o instanceof gt || o instanceof vt))
        return;
    let l = t.mapping.maps[r], a;
    l.forEach( (u, f, h, p) => {
        a == null && (a = p)
    }
    ),
    t.setSelection(ye.near(t.doc.resolve(a), n))
}
const eb = 1
  , Zc = 2
  , tb = 4;
class XE extends v1 {
    constructor(e) {
        super(e.doc),
        this.curSelectionFor = 0,
        this.updated = 0,
        this.meta = Object.create(null),
        this.time = Date.now(),
        this.curSelection = e.selection,
        this.storedMarks = e.storedMarks
    }
    get selection() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)),
        this.curSelectionFor = this.steps.length),
        this.curSelection
    }
    setSelection(e) {
        if (e.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = e,
        this.curSelectionFor = this.steps.length,
        this.updated = (this.updated | eb) & ~Zc,
        this.storedMarks = null,
        this
    }
    get selectionSet() {
        return (this.updated & eb) > 0
    }
    setStoredMarks(e) {
        return this.storedMarks = e,
        this.updated |= Zc,
        this
    }
    ensureMarks(e) {
        return Ve.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e),
        this
    }
    addStoredMark(e) {
        return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()))
    }
    removeStoredMark(e) {
        return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()))
    }
    get storedMarksSet() {
        return (this.updated & Zc) > 0
    }
    addStep(e, n) {
        super.addStep(e, n),
        this.updated = this.updated & ~Zc,
        this.storedMarks = null
    }
    setTime(e) {
        return this.time = e,
        this
    }
    replaceSelection(e) {
        return this.selection.replace(this, e),
        this
    }
    replaceSelectionWith(e, n=!0) {
        let r = this.selection;
        return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Ve.none))),
        r.replaceWith(this, e),
        this
    }
    deleteSelection() {
        return this.selection.replace(this),
        this
    }
    insertText(e, n, r) {
        let o = this.doc.type.schema;
        if (n == null)
            return e ? this.replaceSelectionWith(o.text(e), !0) : this.deleteSelection();
        {
            if (r == null && (r = n),
            !e)
                return this.deleteRange(n, r);
            let l = this.storedMarks;
            if (!l) {
                let a = this.doc.resolve(n);
                l = r == n ? a.marks() : a.marksAcross(this.doc.resolve(r))
            }
            return this.replaceRangeWith(n, r, o.text(e, l)),
            !this.selection.empty && this.selection.to == n + e.length && this.setSelection(ye.near(this.selection.$to)),
            this
        }
    }
    setMeta(e, n) {
        return this.meta[typeof e == "string" ? e : e.key] = n,
        this
    }
    getMeta(e) {
        return this.meta[typeof e == "string" ? e : e.key]
    }
    get isGeneric() {
        for (let e in this.meta)
            return !1;
        return !0
    }
    scrollIntoView() {
        return this.updated |= tb,
        this
    }
    get scrolledIntoView() {
        return (this.updated & tb) > 0
    }
}
function nb(t, e) {
    return !e || !t ? t : t.bind(e)
}
class Ks {
    constructor(e, n, r) {
        this.name = e,
        this.init = nb(n.init, r),
        this.apply = nb(n.apply, r)
    }
}
const JE = [new Ks("doc",{
    init(t) {
        return t.doc || t.schema.topNodeType.createAndFill()
    },
    apply(t) {
        return t.doc
    }
}), new Ks("selection",{
    init(t, e) {
        return t.selection || ye.atStart(e.doc)
    },
    apply(t) {
        return t.selection
    }
}), new Ks("storedMarks",{
    init(t) {
        return t.storedMarks || null
    },
    apply(t, e, n, r) {
        return r.selection.$cursor ? t.storedMarks : null
    }
}), new Ks("scrollToSelection",{
    init() {
        return 0
    },
    apply(t, e) {
        return t.scrolledIntoView ? e + 1 : e
    }
})];
class Rp {
    constructor(e, n) {
        this.schema = e,
        this.plugins = [],
        this.pluginsByKey = Object.create(null),
        this.fields = JE.slice(),
        n && n.forEach(r => {
            if (this.pluginsByKey[r.key])
                throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
            this.plugins.push(r),
            this.pluginsByKey[r.key] = r,
            r.spec.state && this.fields.push(new Ks(r.key,r.spec.state,r))
        }
        )
    }
}
class kl {
    constructor(e) {
        this.config = e
    }
    get schema() {
        return this.config.schema
    }
    get plugins() {
        return this.config.plugins
    }
    apply(e) {
        return this.applyTransaction(e).state
    }
    filterTransaction(e, n=-1) {
        for (let r = 0; r < this.config.plugins.length; r++)
            if (r != n) {
                let o = this.config.plugins[r];
                if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, e, this))
                    return !1
            }
        return !0
    }
    applyTransaction(e) {
        if (!this.filterTransaction(e))
            return {
                state: this,
                transactions: []
            };
        let n = [e]
          , r = this.applyInner(e)
          , o = null;
        for (; ; ) {
            let l = !1;
            for (let a = 0; a < this.config.plugins.length; a++) {
                let u = this.config.plugins[a];
                if (u.spec.appendTransaction) {
                    let f = o ? o[a].n : 0
                      , h = o ? o[a].state : this
                      , p = f < n.length && u.spec.appendTransaction.call(u, f ? n.slice(f) : n, h, r);
                    if (p && r.filterTransaction(p, a)) {
                        if (p.setMeta("appendedTransaction", e),
                        !o) {
                            o = [];
                            for (let m = 0; m < this.config.plugins.length; m++)
                                o.push(m < a ? {
                                    state: r,
                                    n: n.length
                                } : {
                                    state: this,
                                    n: 0
                                })
                        }
                        n.push(p),
                        r = r.applyInner(p),
                        l = !0
                    }
                    o && (o[a] = {
                        state: r,
                        n: n.length
                    })
                }
            }
            if (!l)
                return {
                    state: r,
                    transactions: n
                }
        }
    }
    applyInner(e) {
        if (!e.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
        let n = new kl(this.config)
          , r = this.config.fields;
        for (let o = 0; o < r.length; o++) {
            let l = r[o];
            n[l.name] = l.apply(e, this[l.name], this, n)
        }
        return n
    }
    get tr() {
        return new XE(this)
    }
    static create(e) {
        let n = new Rp(e.doc ? e.doc.type.schema : e.schema,e.plugins)
          , r = new kl(n);
        for (let o = 0; o < n.fields.length; o++)
            r[n.fields[o].name] = n.fields[o].init(e, r);
        return r
    }
    reconfigure(e) {
        let n = new Rp(this.schema,e.plugins)
          , r = n.fields
          , o = new kl(n);
        for (let l = 0; l < r.length; l++) {
            let a = r[l].name;
            o[a] = this.hasOwnProperty(a) ? this[a] : r[l].init(e, o)
        }
        return o
    }
    toJSON(e) {
        let n = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
        };
        if (this.storedMarks && (n.storedMarks = this.storedMarks.map(r => r.toJSON())),
        e && typeof e == "object")
            for (let r in e) {
                if (r == "doc" || r == "selection")
                    throw new RangeError("The JSON fields `doc` and `selection` are reserved");
                let o = e[r]
                  , l = o.spec.state;
                l && l.toJSON && (n[r] = l.toJSON.call(o, this[o.key]))
            }
        return n
    }
    static fromJSON(e, n, r) {
        if (!n)
            throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!e.schema)
            throw new RangeError("Required config field 'schema' missing");
        let o = new Rp(e.schema,e.plugins)
          , l = new kl(o);
        return o.fields.forEach(a => {
            if (a.name == "doc")
                l.doc = Ci.fromJSON(e.schema, n.doc);
            else if (a.name == "selection")
                l.selection = ye.fromJSON(l.doc, n.selection);
            else if (a.name == "storedMarks")
                n.storedMarks && (l.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
            else {
                if (r)
                    for (let u in r) {
                        let f = r[u]
                          , h = f.spec.state;
                        if (f.key == a.name && h && h.fromJSON && Object.prototype.hasOwnProperty.call(n, u)) {
                            l[a.name] = h.fromJSON.call(f, e, n[u], l);
                            return
                        }
                    }
                l[a.name] = a.init(e, l)
            }
        }
        ),
        l
    }
}
function ex(t, e, n) {
    for (let r in t) {
        let o = t[r];
        o instanceof Function ? o = o.bind(e) : r == "handleDOMEvents" && (o = ex(o, e, {})),
        n[r] = o
    }
    return n
}
class Ye {
    constructor(e) {
        this.spec = e,
        this.props = {},
        e.props && ex(e.props, this, this.props),
        this.key = e.key ? e.key.key : tx("plugin")
    }
    getState(e) {
        return e[this.key]
    }
}
const Op = Object.create(null);
function tx(t) {
    return t in Op ? t + "$" + ++Op[t] : (Op[t] = 0,
    t + "$")
}
class nt {
    constructor(e="key") {
        this.key = tx(e)
    }
    get(e) {
        return e.config.pluginsByKey[this.key]
    }
    getState(e) {
        return e[this.key]
    }
}
const C1 = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()),
!0);
function nx(t, e) {
    let {$cursor: n} = t.selection;
    return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n
}
const rx = (t, e, n) => {
    let r = nx(t, n);
    if (!r)
        return !1;
    let o = S1(r);
    if (!o) {
        let a = r.blockRange()
          , u = a && Ul(a);
        return u == null ? !1 : (e && e(t.tr.lift(a, u).scrollIntoView()),
        !0)
    }
    let l = o.nodeBefore;
    if (dx(t, o, e, -1))
        return !0;
    if (r.parent.content.size == 0 && (Dl(l, "end") || le.isSelectable(l)))
        for (let a = r.depth; ; a--) {
            let u = Rf(t.doc, r.before(a), r.after(a), te.empty);
            if (u && u.slice.size < u.to - u.from) {
                if (e) {
                    let f = t.tr.step(u);
                    f.setSelection(Dl(l, "end") ? ye.findFrom(f.doc.resolve(f.mapping.map(o.pos, -1)), -1) : le.create(f.doc, o.pos - l.nodeSize)),
                    e(f.scrollIntoView())
                }
                return !0
            }
            if (a == 1 || r.node(a - 1).childCount > 1)
                break
        }
    return l.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos - l.nodeSize, o.pos).scrollIntoView()),
    !0) : !1
}
  , QE = (t, e, n) => {
    let r = nx(t, n);
    if (!r)
        return !1;
    let o = S1(r);
    return o ? ix(t, o, e) : !1
}
  , e6 = (t, e, n) => {
    let r = lx(t, n);
    if (!r)
        return !1;
    let o = x1(r);
    return o ? ix(t, o, e) : !1
}
;
function ix(t, e, n) {
    let r = e.nodeBefore
      , o = r
      , l = e.pos - 1;
    for (; !o.isTextblock; l--) {
        if (o.type.spec.isolating)
            return !1;
        let p = o.lastChild;
        if (!p)
            return !1;
        o = p
    }
    let a = e.nodeAfter
      , u = a
      , f = e.pos + 1;
    for (; !u.isTextblock; f++) {
        if (u.type.spec.isolating)
            return !1;
        let p = u.firstChild;
        if (!p)
            return !1;
        u = p
    }
    let h = Rf(t.doc, l, f, te.empty);
    if (!h || h.from != l || h instanceof gt && h.slice.size >= f - l)
        return !1;
    if (n) {
        let p = t.tr.step(h);
        p.setSelection(se.create(p.doc, l)),
        n(p.scrollIntoView())
    }
    return !0
}
function Dl(t, e, n=!1) {
    for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
        if (r.isTextblock)
            return !0;
        if (n && r.childCount != 1)
            return !1
    }
    return !1
}
const ox = (t, e, n) => {
    let {$head: r, empty: o} = t.selection
      , l = r;
    if (!o)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
            return !1;
        l = S1(r)
    }
    let a = l && l.nodeBefore;
    return !a || !le.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(le.create(t.doc, l.pos - a.nodeSize)).scrollIntoView()),
    !0)
}
;
function S1(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            if (t.index(e) > 0)
                return t.doc.resolve(t.before(e + 1));
            if (t.node(e).type.spec.isolating)
                break
        }
    return null
}
function lx(t, e) {
    let {$cursor: n} = t.selection;
    return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n
}
const sx = (t, e, n) => {
    let r = lx(t, n);
    if (!r)
        return !1;
    let o = x1(r);
    if (!o)
        return !1;
    let l = o.nodeAfter;
    if (dx(t, o, e, 1))
        return !0;
    if (r.parent.content.size == 0 && (Dl(l, "start") || le.isSelectable(l))) {
        let a = Rf(t.doc, r.before(), r.after(), te.empty);
        if (a && a.slice.size < a.to - a.from) {
            if (e) {
                let u = t.tr.step(a);
                u.setSelection(Dl(l, "start") ? ye.findFrom(u.doc.resolve(u.mapping.map(o.pos)), 1) : le.create(u.doc, u.mapping.map(o.pos))),
                e(u.scrollIntoView())
            }
            return !0
        }
    }
    return l.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos, o.pos + l.nodeSize).scrollIntoView()),
    !0) : !1
}
  , ax = (t, e, n) => {
    let {$head: r, empty: o} = t.selection
      , l = r;
    if (!o)
        return !1;
    if (r.parent.isTextblock) {
        if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
            return !1;
        l = x1(r)
    }
    let a = l && l.nodeAfter;
    return !a || !le.isSelectable(a) ? !1 : (e && e(t.tr.setSelection(le.create(t.doc, l.pos)).scrollIntoView()),
    !0)
}
;
function x1(t) {
    if (!t.parent.type.spec.isolating)
        for (let e = t.depth - 1; e >= 0; e--) {
            let n = t.node(e);
            if (t.index(e) + 1 < n.childCount)
                return t.doc.resolve(t.after(e + 1));
            if (n.type.spec.isolating)
                break
        }
    return null
}
const t6 = (t, e) => {
    let n = t.selection, r = n instanceof le, o;
    if (r) {
        if (n.node.isTextblock || !Di(t.doc, n.from))
            return !1;
        o = n.from
    } else if (o = Nf(t.doc, n.from, -1),
    o == null)
        return !1;
    if (e) {
        let l = t.tr.join(o);
        r && l.setSelection(le.create(l.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)),
        e(l.scrollIntoView())
    }
    return !0
}
  , n6 = (t, e) => {
    let n = t.selection, r;
    if (n instanceof le) {
        if (n.node.isTextblock || !Di(t.doc, n.to))
            return !1;
        r = n.to
    } else if (r = Nf(t.doc, n.to, 1),
    r == null)
        return !1;
    return e && e(t.tr.join(r).scrollIntoView()),
    !0
}
  , r6 = (t, e) => {
    let {$from: n, $to: r} = t.selection
      , o = n.blockRange(r)
      , l = o && Ul(o);
    return l == null ? !1 : (e && e(t.tr.lift(o, l).scrollIntoView()),
    !0)
}
  , cx = (t, e) => {
    let {$head: n, $anchor: r} = t.selection;
    return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()),
    !0)
}
;
function w1(t) {
    for (let e = 0; e < t.edgeCount; e++) {
        let {type: n} = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
const i6 = (t, e) => {
    let {$head: n, $anchor: r} = t.selection;
    if (!n.parent.type.spec.code || !n.sameParent(r))
        return !1;
    let o = n.node(-1)
      , l = n.indexAfter(-1)
      , a = w1(o.contentMatchAt(l));
    if (!a || !o.canReplaceWith(l, l, a))
        return !1;
    if (e) {
        let u = n.after()
          , f = t.tr.replaceWith(u, u, a.createAndFill());
        f.setSelection(ye.near(f.doc.resolve(u), 1)),
        e(f.scrollIntoView())
    }
    return !0
}
  , ux = (t, e) => {
    let n = t.selection
      , {$from: r, $to: o} = n;
    if (n instanceof Zt || r.parent.inlineContent || o.parent.inlineContent)
        return !1;
    let l = w1(o.parent.contentMatchAt(o.indexAfter()));
    if (!l || !l.isTextblock)
        return !1;
    if (e) {
        let a = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos
          , u = t.tr.insert(a, l.createAndFill());
        u.setSelection(se.create(u.doc, a + 1)),
        e(u.scrollIntoView())
    }
    return !0
}
  , fx = (t, e) => {
    let {$cursor: n} = t.selection;
    if (!n || n.parent.content.size)
        return !1;
    if (n.depth > 1 && n.after() != n.end(-1)) {
        let l = n.before();
        if (Ar(t.doc, l))
            return e && e(t.tr.split(l).scrollIntoView()),
            !0
    }
    let r = n.blockRange()
      , o = r && Ul(r);
    return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()),
    !0)
}
;
function o6(t) {
    return (e, n) => {
        let {$from: r, $to: o} = e.selection;
        if (e.selection instanceof le && e.selection.node.isBlock)
            return !r.parentOffset || !Ar(e.doc, r.pos) ? !1 : (n && n(e.tr.split(r.pos).scrollIntoView()),
            !0);
        if (!r.depth)
            return !1;
        let l = [], a, u, f = !1, h = !1;
        for (let b = r.depth; ; b--)
            if (r.node(b).isBlock) {
                f = r.end(b) == r.pos + (r.depth - b),
                h = r.start(b) == r.pos - (r.depth - b),
                u = w1(r.node(b - 1).contentMatchAt(r.indexAfter(b - 1))),
                l.unshift(f && u ? {
                    type: u
                } : null),
                a = b;
                break
            } else {
                if (b == 1)
                    return !1;
                l.unshift(null)
            }
        let p = e.tr;
        (e.selection instanceof se || e.selection instanceof Zt) && p.deleteSelection();
        let m = p.mapping.map(r.pos)
          , y = Ar(p.doc, m, l.length, l);
        if (y || (l[0] = u ? {
            type: u
        } : null,
        y = Ar(p.doc, m, l.length, l)),
        !y)
            return !1;
        if (p.split(m, l.length, l),
        !f && h && r.node(a).type != u) {
            let b = p.mapping.map(r.before(a))
              , C = p.doc.resolve(b);
            u && r.node(a - 1).canReplaceWith(C.index(), C.index() + 1, u) && p.setNodeMarkup(p.mapping.map(r.before(a)), u)
        }
        return n && n(p.scrollIntoView()),
        !0
    }
}
const l6 = o6()
  , s6 = (t, e) => {
    let {$from: n, to: r} = t.selection, o, l = n.sharedDepth(r);
    return l == 0 ? !1 : (o = n.before(l),
    e && e(t.tr.setSelection(le.create(t.doc, o))),
    !0)
}
;
function a6(t, e, n) {
    let r = e.nodeBefore
      , o = e.nodeAfter
      , l = e.index();
    return !r || !o || !r.type.compatibleContent(o.type) ? !1 : !r.content.size && e.parent.canReplace(l - 1, l) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()),
    !0) : !e.parent.canReplace(l, l + 1) || !(o.isTextblock || Di(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()),
    !0)
}
function dx(t, e, n, r) {
    let o = e.nodeBefore, l = e.nodeAfter, a, u, f = o.type.spec.isolating || l.type.spec.isolating;
    if (!f && a6(t, e, n))
        return !0;
    let h = !f && e.parent.canReplace(e.index(), e.index() + 1);
    if (h && (a = (u = o.contentMatchAt(o.childCount)).findWrapping(l.type)) && u.matchType(a[0] || l.type).validEnd) {
        if (n) {
            let b = e.pos + l.nodeSize
              , C = Z.empty;
            for (let k = a.length - 1; k >= 0; k--)
                C = Z.from(a[k].create(null, C));
            C = Z.from(o.copy(C));
            let S = t.tr.step(new vt(e.pos - 1,b,e.pos,b,new te(C,1,0),a.length,!0))
              , w = S.doc.resolve(b + 2 * a.length);
            w.nodeAfter && w.nodeAfter.type == o.type && Di(S.doc, w.pos) && S.join(w.pos),
            n(S.scrollIntoView())
        }
        return !0
    }
    let p = l.type.spec.isolating || r > 0 && f ? null : ye.findFrom(e, 1)
      , m = p && p.$from.blockRange(p.$to)
      , y = m && Ul(m);
    if (y != null && y >= e.depth)
        return n && n(t.tr.lift(m, y).scrollIntoView()),
        !0;
    if (h && Dl(l, "start", !0) && Dl(o, "end")) {
        let b = o
          , C = [];
        for (; C.push(b),
        !b.isTextblock; )
            b = b.lastChild;
        let S = l
          , w = 1;
        for (; !S.isTextblock; S = S.firstChild)
            w++;
        if (b.canReplace(b.childCount, b.childCount, S.content)) {
            if (n) {
                let k = Z.empty;
                for (let O = C.length - 1; O >= 0; O--)
                    k = Z.from(C[O].copy(k));
                let A = t.tr.step(new vt(e.pos - C.length,e.pos + l.nodeSize,e.pos + w,e.pos + l.nodeSize - w,new te(k,C.length,0),0,!0));
                n(A.scrollIntoView())
            }
            return !0
        }
    }
    return !1
}
function hx(t) {
    return function(e, n) {
        let r = e.selection
          , o = t < 0 ? r.$from : r.$to
          , l = o.depth;
        for (; o.node(l).isInline; ) {
            if (!l)
                return !1;
            l--
        }
        return o.node(l).isTextblock ? (n && n(e.tr.setSelection(se.create(e.doc, t < 0 ? o.start(l) : o.end(l)))),
        !0) : !1
    }
}
const c6 = hx(-1)
  , u6 = hx(1);
function f6(t, e=null) {
    return function(n, r) {
        let {$from: o, $to: l} = n.selection
          , a = o.blockRange(l)
          , u = a && y1(a, t, e);
        return u ? (r && r(n.tr.wrap(a, u).scrollIntoView()),
        !0) : !1
    }
}
function rb(t, e=null) {
    return function(n, r) {
        let o = !1;
        for (let l = 0; l < n.selection.ranges.length && !o; l++) {
            let {$from: {pos: a}, $to: {pos: u}} = n.selection.ranges[l];
            n.doc.nodesBetween(a, u, (f, h) => {
                if (o)
                    return !1;
                if (!(!f.isTextblock || f.hasMarkup(t, e)))
                    if (f.type == t)
                        o = !0;
                    else {
                        let p = n.doc.resolve(h)
                          , m = p.index();
                        o = p.parent.canReplaceWith(m, m + 1, t)
                    }
            }
            )
        }
        if (!o)
            return !1;
        if (r) {
            let l = n.tr;
            for (let a = 0; a < n.selection.ranges.length; a++) {
                let {$from: {pos: u}, $to: {pos: f}} = n.selection.ranges[a];
                l.setBlockType(u, f, t, e)
            }
            r(l.scrollIntoView())
        }
        return !0
    }
}
function E1(...t) {
    return function(e, n, r) {
        for (let o = 0; o < t.length; o++)
            if (t[o](e, n, r))
                return !0;
        return !1
    }
}
E1(C1, rx, ox);
E1(C1, sx, ax);
E1(cx, ux, fx, l6);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function d6(t, e=null) {
    return function(n, r) {
        let {$from: o, $to: l} = n.selection
          , a = o.blockRange(l);
        if (!a)
            return !1;
        let u = r ? n.tr : null;
        return h6(u, a, t, e) ? (r && r(u.scrollIntoView()),
        !0) : !1
    }
}
function h6(t, e, n, r=null) {
    let o = !1
      , l = e
      , a = e.$from.doc;
    if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
        if (e.$from.index(e.depth - 1) == 0)
            return !1;
        let f = a.resolve(e.start - 2);
        l = new Ou(f,f,e.depth),
        e.endIndex < e.parent.childCount && (e = new Ou(e.$from,a.resolve(e.$to.end(e.depth)),e.depth)),
        o = !0
    }
    let u = y1(l, n, r, e);
    return u ? (t && p6(t, e, u, o, n),
    !0) : !1
}
function p6(t, e, n, r, o) {
    let l = Z.empty;
    for (let p = n.length - 1; p >= 0; p--)
        l = Z.from(n[p].type.create(n[p].attrs, l));
    t.step(new vt(e.start - (r ? 2 : 0),e.end,e.start,e.end,new te(l,0,0),n.length,!0));
    let a = 0;
    for (let p = 0; p < n.length; p++)
        n[p].type == o && (a = p + 1);
    let u = n.length - a
      , f = e.start + n.length - (r ? 2 : 0)
      , h = e.parent;
    for (let p = e.startIndex, m = e.endIndex, y = !0; p < m; p++,
    y = !1)
        !y && Ar(t.doc, f, u) && (t.split(f, u),
        f += 2 * u),
        f += h.child(p).nodeSize;
    return t
}
function m6(t) {
    return function(e, n) {
        let {$from: r, $to: o} = e.selection
          , l = r.blockRange(o, a => a.childCount > 0 && a.firstChild.type == t);
        return l ? n ? r.node(l.depth - 1).type == t ? g6(e, n, t, l) : y6(e, n, l) : !0 : !1
    }
}
function g6(t, e, n, r) {
    let o = t.tr
      , l = r.end
      , a = r.$to.end(r.depth);
    l < a && (o.step(new vt(l - 1,a,l,a,new te(Z.from(n.create(null, r.parent.copy())),1,0),1,!0)),
    r = new Ou(o.doc.resolve(r.$from.pos),o.doc.resolve(a),r.depth));
    const u = Ul(r);
    if (u == null)
        return !1;
    o.lift(r, u);
    let f = o.doc.resolve(o.mapping.map(l, -1) - 1);
    return Di(o.doc, f.pos) && f.nodeBefore.type == f.nodeAfter.type && o.join(f.pos),
    e(o.scrollIntoView()),
    !0
}
function y6(t, e, n) {
    let r = t.tr
      , o = n.parent;
    for (let b = n.end, C = n.endIndex - 1, S = n.startIndex; C > S; C--)
        b -= o.child(C).nodeSize,
        r.delete(b - 1, b + 1);
    let l = r.doc.resolve(n.start)
      , a = l.nodeAfter;
    if (r.mapping.map(n.end) != n.start + l.nodeAfter.nodeSize)
        return !1;
    let u = n.startIndex == 0
      , f = n.endIndex == o.childCount
      , h = l.node(-1)
      , p = l.index(-1);
    if (!h.canReplace(p + (u ? 0 : 1), p + 1, a.content.append(f ? Z.empty : Z.from(o))))
        return !1;
    let m = l.pos
      , y = m + a.nodeSize;
    return r.step(new vt(m - (u ? 1 : 0),y + (f ? 1 : 0),m + 1,y - 1,new te((u ? Z.empty : Z.from(o.copy(Z.empty))).append(f ? Z.empty : Z.from(o.copy(Z.empty))),u ? 0 : 1,f ? 0 : 1),u ? 0 : 1)),
    e(r.scrollIntoView()),
    !0
}
function v6(t) {
    return function(e, n) {
        let {$from: r, $to: o} = e.selection
          , l = r.blockRange(o, h => h.childCount > 0 && h.firstChild.type == t);
        if (!l)
            return !1;
        let a = l.startIndex;
        if (a == 0)
            return !1;
        let u = l.parent
          , f = u.child(a - 1);
        if (f.type != t)
            return !1;
        if (n) {
            let h = f.lastChild && f.lastChild.type == u.type
              , p = Z.from(h ? t.create() : null)
              , m = new te(Z.from(t.create(null, Z.from(u.type.create(null, p)))),h ? 3 : 1,0)
              , y = l.start
              , b = l.end;
            n(e.tr.step(new vt(y - (h ? 3 : 1),b,y,b,m,1,!0)).scrollIntoView())
        }
        return !0
    }
}
const kt = function(t) {
    for (var e = 0; ; e++)
        if (t = t.previousSibling,
        !t)
            return e
}
  , Ll = function(t) {
    let e = t.assignedSlot || t.parentNode;
    return e && e.nodeType == 11 ? e.host : e
};
let xm = null;
const kr = function(t, e, n) {
    let r = xm || (xm = document.createRange());
    return r.setEnd(t, n ?? t.nodeValue.length),
    r.setStart(t, e || 0),
    r
}
  , b6 = function() {
    xm = null
}
  , Co = function(t, e, n, r) {
    return n && (ib(t, e, n, r, -1) || ib(t, e, n, r, 1))
}
  , C6 = /^(img|br|input|textarea|hr)$/i;
function ib(t, e, n, r, o) {
    for (var l; ; ) {
        if (t == n && e == r)
            return !0;
        if (e == (o < 0 ? 0 : Mn(t))) {
            let a = t.parentNode;
            if (!a || a.nodeType != 1 || xa(t) || C6.test(t.nodeName) || t.contentEditable == "false")
                return !1;
            e = kt(t) + (o < 0 ? 0 : 1),
            t = a
        } else if (t.nodeType == 1) {
            let a = t.childNodes[e + (o < 0 ? -1 : 0)];
            if (a.nodeType == 1 && a.contentEditable == "false")
                if (!((l = a.pmViewDesc) === null || l === void 0) && l.ignoreForSelection)
                    e += o;
                else
                    return !1;
            else
                t = a,
                e = o < 0 ? Mn(t) : 0
        } else
            return !1
    }
}
function Mn(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function S6(t, e) {
    for (; ; ) {
        if (t.nodeType == 3 && e)
            return t;
        if (t.nodeType == 1 && e > 0) {
            if (t.contentEditable == "false")
                return null;
            t = t.childNodes[e - 1],
            e = Mn(t)
        } else if (t.parentNode && !xa(t))
            e = kt(t),
            t = t.parentNode;
        else
            return null
    }
}
function x6(t, e) {
    for (; ; ) {
        if (t.nodeType == 3 && e < t.nodeValue.length)
            return t;
        if (t.nodeType == 1 && e < t.childNodes.length) {
            if (t.contentEditable == "false")
                return null;
            t = t.childNodes[e],
            e = 0
        } else if (t.parentNode && !xa(t))
            e = kt(t) + 1,
            t = t.parentNode;
        else
            return null
    }
}
function w6(t, e, n) {
    for (let r = e == 0, o = e == Mn(t); r || o; ) {
        if (t == n)
            return !0;
        let l = kt(t);
        if (t = t.parentNode,
        !t)
            return !1;
        r = r && l == 0,
        o = o && l == Mn(t)
    }
}
function xa(t) {
    let e;
    for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
        ;
    return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t)
}
const Df = function(t) {
    return t.focusNode && Co(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
};
function so(t, e) {
    let n = document.createEvent("Event");
    return n.initEvent("keydown", !0, !0),
    n.keyCode = t,
    n.key = n.code = e,
    n
}
function E6(t) {
    let e = t.activeElement;
    for (; e && e.shadowRoot; )
        e = e.shadowRoot.activeElement;
    return e
}
function T6(t, e, n) {
    if (t.caretPositionFromPoint)
        try {
            let r = t.caretPositionFromPoint(e, n);
            if (r)
                return {
                    node: r.offsetNode,
                    offset: Math.min(Mn(r.offsetNode), r.offset)
                }
        } catch {}
    if (t.caretRangeFromPoint) {
        let r = t.caretRangeFromPoint(e, n);
        if (r)
            return {
                node: r.startContainer,
                offset: Math.min(Mn(r.startContainer), r.startOffset)
            }
    }
}
const Wn = typeof navigator < "u" ? navigator : null
  , ob = typeof document < "u" ? document : null
  , Li = Wn && Wn.userAgent || ""
  , wm = /Edge\/(\d+)/.exec(Li)
  , px = /MSIE \d/.exec(Li)
  , Em = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Li)
  , Wt = !!(px || Em || wm)
  , xi = px ? document.documentMode : Em ? +Em[1] : wm ? +wm[1] : 0
  , An = !Wt && /gecko\/(\d+)/i.test(Li);
An && +(/Firefox\/(\d+)/.exec(Li) || [0, 0])[1];
const Tm = !Wt && /Chrome\/(\d+)/.exec(Li)
  , At = !!Tm
  , mx = Tm ? +Tm[1] : 0
  , Dt = !Wt && !!Wn && /Apple Computer/.test(Wn.vendor)
  , zl = Dt && (/Mobile\/\w+/.test(Li) || !!Wn && Wn.maxTouchPoints > 2)
  , kn = zl || (Wn ? /Mac/.test(Wn.platform) : !1)
  , gx = Wn ? /Win/.test(Wn.platform) : !1
  , Mr = /Android \d/.test(Li)
  , wa = !!ob && "webkitFontSmoothing"in ob.documentElement.style
  , k6 = wa ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function M6(t) {
    let e = t.defaultView && t.defaultView.visualViewport;
    return e ? {
        left: 0,
        right: e.width,
        top: 0,
        bottom: e.height
    } : {
        left: 0,
        right: t.documentElement.clientWidth,
        top: 0,
        bottom: t.documentElement.clientHeight
    }
}
function Sr(t, e) {
    return typeof t == "number" ? t : t[e]
}
function A6(t) {
    let e = t.getBoundingClientRect()
      , n = e.width / t.offsetWidth || 1
      , r = e.height / t.offsetHeight || 1;
    return {
        left: e.left,
        right: e.left + t.clientWidth * n,
        top: e.top,
        bottom: e.top + t.clientHeight * r
    }
}
function lb(t, e, n) {
    let r = t.someProp("scrollThreshold") || 0
      , o = t.someProp("scrollMargin") || 5
      , l = t.dom.ownerDocument;
    for (let a = n || t.dom; a; ) {
        if (a.nodeType != 1) {
            a = Ll(a);
            continue
        }
        let u = a
          , f = u == l.body
          , h = f ? M6(l) : A6(u)
          , p = 0
          , m = 0;
        if (e.top < h.top + Sr(r, "top") ? m = -(h.top - e.top + Sr(o, "top")) : e.bottom > h.bottom - Sr(r, "bottom") && (m = e.bottom - e.top > h.bottom - h.top ? e.top + Sr(o, "top") - h.top : e.bottom - h.bottom + Sr(o, "bottom")),
        e.left < h.left + Sr(r, "left") ? p = -(h.left - e.left + Sr(o, "left")) : e.right > h.right - Sr(r, "right") && (p = e.right - h.right + Sr(o, "right")),
        p || m)
            if (f)
                l.defaultView.scrollBy(p, m);
            else {
                let b = u.scrollLeft
                  , C = u.scrollTop;
                m && (u.scrollTop += m),
                p && (u.scrollLeft += p);
                let S = u.scrollLeft - b
                  , w = u.scrollTop - C;
                e = {
                    left: e.left - S,
                    top: e.top - w,
                    right: e.right - S,
                    bottom: e.bottom - w
                }
            }
        let y = f ? "fixed" : getComputedStyle(a).position;
        if (/^(fixed|sticky)$/.test(y))
            break;
        a = y == "absolute" ? a.offsetParent : Ll(a)
    }
}
function N6(t) {
    let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, o;
    for (let l = (e.left + e.right) / 2, a = n + 1; a < Math.min(innerHeight, e.bottom); a += 5) {
        let u = t.root.elementFromPoint(l, a);
        if (!u || u == t.dom || !t.dom.contains(u))
            continue;
        let f = u.getBoundingClientRect();
        if (f.top >= n - 20) {
            r = u,
            o = f.top;
            break
        }
    }
    return {
        refDOM: r,
        refTop: o,
        stack: yx(t.dom)
    }
}
function yx(t) {
    let e = []
      , n = t.ownerDocument;
    for (let r = t; r && (e.push({
        dom: r,
        top: r.scrollTop,
        left: r.scrollLeft
    }),
    t != n); r = Ll(r))
        ;
    return e
}
function R6({refDOM: t, refTop: e, stack: n}) {
    let r = t ? t.getBoundingClientRect().top : 0;
    vx(n, r == 0 ? 0 : r - e)
}
function vx(t, e) {
    for (let n = 0; n < t.length; n++) {
        let {dom: r, top: o, left: l} = t[n];
        r.scrollTop != o + e && (r.scrollTop = o + e),
        r.scrollLeft != l && (r.scrollLeft = l)
    }
}
let gl = null;
function O6(t) {
    if (t.setActive)
        return t.setActive();
    if (gl)
        return t.focus(gl);
    let e = yx(t);
    t.focus(gl == null ? {
        get preventScroll() {
            return gl = {
                preventScroll: !0
            },
            !0
        }
    } : void 0),
    gl || (gl = !1,
    vx(e, 0))
}
function bx(t, e) {
    let n, r = 2e8, o, l = 0, a = e.top, u = e.top, f, h;
    for (let p = t.firstChild, m = 0; p; p = p.nextSibling,
    m++) {
        let y;
        if (p.nodeType == 1)
            y = p.getClientRects();
        else if (p.nodeType == 3)
            y = kr(p).getClientRects();
        else
            continue;
        for (let b = 0; b < y.length; b++) {
            let C = y[b];
            if (C.top <= a && C.bottom >= u) {
                a = Math.max(C.bottom, a),
                u = Math.min(C.top, u);
                let S = C.left > e.left ? C.left - e.left : C.right < e.left ? e.left - C.right : 0;
                if (S < r) {
                    n = p,
                    r = S,
                    o = S && n.nodeType == 3 ? {
                        left: C.right < e.left ? C.right : C.left,
                        top: e.top
                    } : e,
                    p.nodeType == 1 && S && (l = m + (e.left >= (C.left + C.right) / 2 ? 1 : 0));
                    continue
                }
            } else
                C.top > e.top && !f && C.left <= e.left && C.right >= e.left && (f = p,
                h = {
                    left: Math.max(C.left, Math.min(C.right, e.left)),
                    top: C.top
                });
            !n && (e.left >= C.right && e.top >= C.top || e.left >= C.left && e.top >= C.bottom) && (l = m + 1)
        }
    }
    return !n && f && (n = f,
    o = h,
    r = 0),
    n && n.nodeType == 3 ? D6(n, o) : !n || r && n.nodeType == 1 ? {
        node: t,
        offset: l
    } : bx(n, o)
}
function D6(t, e) {
    let n = t.nodeValue.length, r = document.createRange(), o;
    for (let l = 0; l < n; l++) {
        r.setEnd(t, l + 1),
        r.setStart(t, l);
        let a = ci(r, 1);
        if (a.top != a.bottom && T1(e, a)) {
            o = {
                node: t,
                offset: l + (e.left >= (a.left + a.right) / 2 ? 1 : 0)
            };
            break
        }
    }
    return r.detach(),
    o || {
        node: t,
        offset: 0
    }
}
function T1(t, e) {
    return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1
}
function L6(t, e) {
    let n = t.parentNode;
    return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t
}
function z6(t, e, n) {
    let {node: r, offset: o} = bx(e, n)
      , l = -1;
    if (r.nodeType == 1 && !r.firstChild) {
        let a = r.getBoundingClientRect();
        l = a.left != a.right && n.left > (a.left + a.right) / 2 ? 1 : -1
    }
    return t.docView.posFromDOM(r, o, l)
}
function _6(t, e, n, r) {
    let o = -1;
    for (let l = e, a = !1; l != t.dom; ) {
        let u = t.docView.nearestDesc(l, !0), f;
        if (!u)
            return null;
        if (u.dom.nodeType == 1 && (u.node.isBlock && u.parent || !u.contentDOM) && ((f = u.dom.getBoundingClientRect()).width || f.height) && (u.node.isBlock && u.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(u.dom.nodeName) && (!a && f.left > r.left || f.top > r.top ? o = u.posBefore : (!a && f.right < r.left || f.bottom < r.top) && (o = u.posAfter),
        a = !0),
        !u.contentDOM && o < 0 && !u.node.isText))
            return (u.node.isBlock ? r.top < (f.top + f.bottom) / 2 : r.left < (f.left + f.right) / 2) ? u.posBefore : u.posAfter;
        l = u.dom.parentNode
    }
    return o > -1 ? o : t.docView.posFromDOM(e, n, -1)
}
function Cx(t, e, n) {
    let r = t.childNodes.length;
    if (r && n.top < n.bottom)
        for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), l = o; ; ) {
            let a = t.childNodes[l];
            if (a.nodeType == 1) {
                let u = a.getClientRects();
                for (let f = 0; f < u.length; f++) {
                    let h = u[f];
                    if (T1(e, h))
                        return Cx(a, e, h)
                }
            }
            if ((l = (l + 1) % r) == o)
                break
        }
    return t
}
function B6(t, e) {
    let n = t.dom.ownerDocument, r, o = 0, l = T6(n, e.left, e.top);
    l && ({node: r, offset: o} = l);
    let a = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), u;
    if (!a || !t.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
        let h = t.dom.getBoundingClientRect();
        if (!T1(e, h) || (a = Cx(t.dom, e, h),
        !a))
            return null
    }
    if (Dt)
        for (let h = a; r && h; h = Ll(h))
            h.draggable && (r = void 0);
    if (a = L6(a, e),
    r) {
        if (An && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length),
        o < r.childNodes.length)) {
            let p = r.childNodes[o], m;
            p.nodeName == "IMG" && (m = p.getBoundingClientRect()).right <= e.left && m.bottom > e.top && o++
        }
        let h;
        wa && o && r.nodeType == 1 && (h = r.childNodes[o - 1]).nodeType == 1 && h.contentEditable == "false" && h.getBoundingClientRect().top >= e.top && o--,
        r == t.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? u = t.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (u = _6(t, r, o, e))
    }
    u == null && (u = z6(t, a, e));
    let f = t.docView.nearestDesc(a, !0);
    return {
        pos: u,
        inside: f ? f.posAtStart - f.border : -1
    }
}
function sb(t) {
    return t.top < t.bottom || t.left < t.right
}
function ci(t, e) {
    let n = t.getClientRects();
    if (n.length) {
        let r = n[e < 0 ? 0 : n.length - 1];
        if (sb(r))
            return r
    }
    return Array.prototype.find.call(n, sb) || t.getBoundingClientRect()
}
const j6 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Sx(t, e, n) {
    let {node: r, offset: o, atom: l} = t.docView.domFromPos(e, n < 0 ? -1 : 1)
      , a = wa || An;
    if (r.nodeType == 3)
        if (a && (j6.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
            let f = ci(kr(r, o, o), n);
            if (An && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
                let h = ci(kr(r, o - 1, o - 1), -1);
                if (h.top == f.top) {
                    let p = ci(kr(r, o, o + 1), -1);
                    if (p.top != f.top)
                        return Is(p, p.left < h.left)
                }
            }
            return f
        } else {
            let f = o
              , h = o
              , p = n < 0 ? 1 : -1;
            return n < 0 && !o ? (h++,
            p = -1) : n >= 0 && o == r.nodeValue.length ? (f--,
            p = 1) : n < 0 ? f-- : h++,
            Is(ci(kr(r, f, h), p), p < 0)
        }
    if (!t.state.doc.resolve(e - (l || 0)).parent.inlineContent) {
        if (l == null && o && (n < 0 || o == Mn(r))) {
            let f = r.childNodes[o - 1];
            if (f.nodeType == 1)
                return Dp(f.getBoundingClientRect(), !1)
        }
        if (l == null && o < Mn(r)) {
            let f = r.childNodes[o];
            if (f.nodeType == 1)
                return Dp(f.getBoundingClientRect(), !0)
        }
        return Dp(r.getBoundingClientRect(), n >= 0)
    }
    if (l == null && o && (n < 0 || o == Mn(r))) {
        let f = r.childNodes[o - 1]
          , h = f.nodeType == 3 ? kr(f, Mn(f) - (a ? 0 : 1)) : f.nodeType == 1 && (f.nodeName != "BR" || !f.nextSibling) ? f : null;
        if (h)
            return Is(ci(h, 1), !1)
    }
    if (l == null && o < Mn(r)) {
        let f = r.childNodes[o];
        for (; f.pmViewDesc && f.pmViewDesc.ignoreForCoords; )
            f = f.nextSibling;
        let h = f ? f.nodeType == 3 ? kr(f, 0, a ? 0 : 1) : f.nodeType == 1 ? f : null : null;
        if (h)
            return Is(ci(h, -1), !0)
    }
    return Is(ci(r.nodeType == 3 ? kr(r) : r, -n), n >= 0)
}
function Is(t, e) {
    if (t.width == 0)
        return t;
    let n = e ? t.left : t.right;
    return {
        top: t.top,
        bottom: t.bottom,
        left: n,
        right: n
    }
}
function Dp(t, e) {
    if (t.height == 0)
        return t;
    let n = e ? t.top : t.bottom;
    return {
        top: n,
        bottom: n,
        left: t.left,
        right: t.right
    }
}
function xx(t, e, n) {
    let r = t.state
      , o = t.root.activeElement;
    r != e && t.updateState(e),
    o != t.dom && t.focus();
    try {
        return n()
    } finally {
        r != e && t.updateState(r),
        o != t.dom && o && o.focus()
    }
}
function H6(t, e, n) {
    let r = e.selection
      , o = n == "up" ? r.$from : r.$to;
    return xx(t, e, () => {
        let {node: l} = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
        for (; ; ) {
            let u = t.docView.nearestDesc(l, !0);
            if (!u)
                break;
            if (u.node.isBlock) {
                l = u.contentDOM || u.dom;
                break
            }
            l = u.dom.parentNode
        }
        let a = Sx(t, o.pos, 1);
        for (let u = l.firstChild; u; u = u.nextSibling) {
            let f;
            if (u.nodeType == 1)
                f = u.getClientRects();
            else if (u.nodeType == 3)
                f = kr(u, 0, u.nodeValue.length).getClientRects();
            else
                continue;
            for (let h = 0; h < f.length; h++) {
                let p = f[h];
                if (p.bottom > p.top + 1 && (n == "up" ? a.top - p.top > (p.bottom - a.top) * 2 : p.bottom - a.bottom > (a.bottom - p.top) * 2))
                    return !1
            }
        }
        return !0
    }
    )
}
const I6 = /[\u0590-\u08ac]/;
function V6(t, e, n) {
    let {$head: r} = e.selection;
    if (!r.parent.isTextblock)
        return !1;
    let o = r.parentOffset
      , l = !o
      , a = o == r.parent.content.size
      , u = t.domSelection();
    return u ? !I6.test(r.parent.textContent) || !u.modify ? n == "left" || n == "backward" ? l : a : xx(t, e, () => {
        let {focusNode: f, focusOffset: h, anchorNode: p, anchorOffset: m} = t.domSelectionRange()
          , y = u.caretBidiLevel;
        u.modify("move", n, "character");
        let b = r.depth ? t.docView.domAfterPos(r.before()) : t.dom
          , {focusNode: C, focusOffset: S} = t.domSelectionRange()
          , w = C && !b.contains(C.nodeType == 1 ? C : C.parentNode) || f == C && h == S;
        try {
            u.collapse(p, m),
            f && (f != p || h != m) && u.extend && u.extend(f, h)
        } catch {}
        return y != null && (u.caretBidiLevel = y),
        w
    }
    ) : r.pos == r.start() || r.pos == r.end()
}
let ab = null
  , cb = null
  , ub = !1;
function U6(t, e, n) {
    return ab == e && cb == n ? ub : (ab = e,
    cb = n,
    ub = n == "up" || n == "down" ? H6(t, e, n) : V6(t, e, n))
}
const Nn = 0
  , fb = 1
  , ao = 2
  , Xn = 3;
class Ea {
    constructor(e, n, r, o) {
        this.parent = e,
        this.children = n,
        this.dom = r,
        this.contentDOM = o,
        this.dirty = Nn,
        r.pmViewDesc = this
    }
    matchesWidget(e) {
        return !1
    }
    matchesMark(e) {
        return !1
    }
    matchesNode(e, n, r) {
        return !1
    }
    matchesHack(e) {
        return !1
    }
    parseRule() {
        return null
    }
    stopEvent(e) {
        return !1
    }
    get size() {
        let e = 0;
        for (let n = 0; n < this.children.length; n++)
            e += this.children[n].size;
        return e
    }
    get border() {
        return 0
    }
    destroy() {
        this.parent = void 0,
        this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (let e = 0; e < this.children.length; e++)
            this.children[e].destroy()
    }
    posBeforeChild(e) {
        for (let n = 0, r = this.posAtStart; ; n++) {
            let o = this.children[n];
            if (o == e)
                return r;
            r += o.size
        }
    }
    get posBefore() {
        return this.parent.posBeforeChild(this)
    }
    get posAtStart() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
    }
    get posAfter() {
        return this.posBefore + this.size
    }
    get posAtEnd() {
        return this.posAtStart + this.size - 2 * this.border
    }
    localPosFromDOM(e, n, r) {
        if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
            if (r < 0) {
                let l, a;
                if (e == this.contentDOM)
                    l = e.childNodes[n - 1];
                else {
                    for (; e.parentNode != this.contentDOM; )
                        e = e.parentNode;
                    l = e.previousSibling
                }
                for (; l && !((a = l.pmViewDesc) && a.parent == this); )
                    l = l.previousSibling;
                return l ? this.posBeforeChild(a) + a.size : this.posAtStart
            } else {
                let l, a;
                if (e == this.contentDOM)
                    l = e.childNodes[n];
                else {
                    for (; e.parentNode != this.contentDOM; )
                        e = e.parentNode;
                    l = e.nextSibling
                }
                for (; l && !((a = l.pmViewDesc) && a.parent == this); )
                    l = l.nextSibling;
                return l ? this.posBeforeChild(a) : this.posAtEnd
            }
        let o;
        if (e == this.dom && this.contentDOM)
            o = n > kt(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
            o = e.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
            if (n == 0)
                for (let l = e; ; l = l.parentNode) {
                    if (l == this.dom) {
                        o = !1;
                        break
                    }
                    if (l.previousSibling)
                        break
                }
            if (o == null && n == e.childNodes.length)
                for (let l = e; ; l = l.parentNode) {
                    if (l == this.dom) {
                        o = !0;
                        break
                    }
                    if (l.nextSibling)
                        break
                }
        }
        return o ?? r > 0 ? this.posAtEnd : this.posAtStart
    }
    nearestDesc(e, n=!1) {
        for (let r = !0, o = e; o; o = o.parentNode) {
            let l = this.getDesc(o), a;
            if (l && (!n || l.node))
                if (r && (a = l.nodeDOM) && !(a.nodeType == 1 ? a.contains(e.nodeType == 1 ? e : e.parentNode) : a == e))
                    r = !1;
                else
                    return l
        }
    }
    getDesc(e) {
        let n = e.pmViewDesc;
        for (let r = n; r; r = r.parent)
            if (r == this)
                return n
    }
    posFromDOM(e, n, r) {
        for (let o = e; o; o = o.parentNode) {
            let l = this.getDesc(o);
            if (l)
                return l.localPosFromDOM(e, n, r)
        }
        return -1
    }
    descAt(e) {
        for (let n = 0, r = 0; n < this.children.length; n++) {
            let o = this.children[n]
              , l = r + o.size;
            if (r == e && l != r) {
                for (; !o.border && o.children.length; )
                    for (let a = 0; a < o.children.length; a++) {
                        let u = o.children[a];
                        if (u.size) {
                            o = u;
                            break
                        }
                    }
                return o
            }
            if (e < l)
                return o.descAt(e - r - o.border);
            r = l
        }
    }
    domFromPos(e, n) {
        if (!this.contentDOM)
            return {
                node: this.dom,
                offset: 0,
                atom: e + 1
            };
        let r = 0
          , o = 0;
        for (let l = 0; r < this.children.length; r++) {
            let a = this.children[r]
              , u = l + a.size;
            if (u > e || a instanceof Ex) {
                o = e - l;
                break
            }
            l = u
        }
        if (o)
            return this.children[r].domFromPos(o - this.children[r].border, n);
        for (let l; r && !(l = this.children[r - 1]).size && l instanceof wx && l.side >= 0; r--)
            ;
        if (n <= 0) {
            let l, a = !0;
            for (; l = r ? this.children[r - 1] : null,
            !(!l || l.dom.parentNode == this.contentDOM); r--,
            a = !1)
                ;
            return l && n && a && !l.border && !l.domAtom ? l.domFromPos(l.size, n) : {
                node: this.contentDOM,
                offset: l ? kt(l.dom) + 1 : 0
            }
        } else {
            let l, a = !0;
            for (; l = r < this.children.length ? this.children[r] : null,
            !(!l || l.dom.parentNode == this.contentDOM); r++,
            a = !1)
                ;
            return l && a && !l.border && !l.domAtom ? l.domFromPos(0, n) : {
                node: this.contentDOM,
                offset: l ? kt(l.dom) : this.contentDOM.childNodes.length
            }
        }
    }
    parseRange(e, n, r=0) {
        if (this.children.length == 0)
            return {
                node: this.contentDOM,
                from: e,
                to: n,
                fromOffset: 0,
                toOffset: this.contentDOM.childNodes.length
            };
        let o = -1
          , l = -1;
        for (let a = r, u = 0; ; u++) {
            let f = this.children[u]
              , h = a + f.size;
            if (o == -1 && e <= h) {
                let p = a + f.border;
                if (e >= p && n <= h - f.border && f.node && f.contentDOM && this.contentDOM.contains(f.contentDOM))
                    return f.parseRange(e, n, p);
                e = a;
                for (let m = u; m > 0; m--) {
                    let y = this.children[m - 1];
                    if (y.size && y.dom.parentNode == this.contentDOM && !y.emptyChildAt(1)) {
                        o = kt(y.dom) + 1;
                        break
                    }
                    e -= y.size
                }
                o == -1 && (o = 0)
            }
            if (o > -1 && (h > n || u == this.children.length - 1)) {
                n = h;
                for (let p = u + 1; p < this.children.length; p++) {
                    let m = this.children[p];
                    if (m.size && m.dom.parentNode == this.contentDOM && !m.emptyChildAt(-1)) {
                        l = kt(m.dom);
                        break
                    }
                    n += m.size
                }
                l == -1 && (l = this.contentDOM.childNodes.length);
                break
            }
            a = h
        }
        return {
            node: this.contentDOM,
            from: e,
            to: n,
            fromOffset: o,
            toOffset: l
        }
    }
    emptyChildAt(e) {
        if (this.border || !this.contentDOM || !this.children.length)
            return !1;
        let n = this.children[e < 0 ? 0 : this.children.length - 1];
        return n.size == 0 || n.emptyChildAt(e)
    }
    domAfterPos(e) {
        let {node: n, offset: r} = this.domFromPos(e, 0);
        if (n.nodeType != 1 || r == n.childNodes.length)
            throw new RangeError("No node after pos " + e);
        return n.childNodes[r]
    }
    setSelection(e, n, r, o=!1) {
        let l = Math.min(e, n)
          , a = Math.max(e, n);
        for (let b = 0, C = 0; b < this.children.length; b++) {
            let S = this.children[b]
              , w = C + S.size;
            if (l > C && a < w)
                return S.setSelection(e - C - S.border, n - C - S.border, r, o);
            C = w
        }
        let u = this.domFromPos(e, e ? -1 : 1)
          , f = n == e ? u : this.domFromPos(n, n ? -1 : 1)
          , h = r.root.getSelection()
          , p = r.domSelectionRange()
          , m = !1;
        if ((An || Dt) && e == n) {
            let {node: b, offset: C} = u;
            if (b.nodeType == 3) {
                if (m = !!(C && b.nodeValue[C - 1] == `
`),
                m && C == b.nodeValue.length)
                    for (let S = b, w; S; S = S.parentNode) {
                        if (w = S.nextSibling) {
                            w.nodeName == "BR" && (u = f = {
                                node: w.parentNode,
                                offset: kt(w) + 1
                            });
                            break
                        }
                        let k = S.pmViewDesc;
                        if (k && k.node && k.node.isBlock)
                            break
                    }
            } else {
                let S = b.childNodes[C - 1];
                m = S && (S.nodeName == "BR" || S.contentEditable == "false")
            }
        }
        if (An && p.focusNode && p.focusNode != f.node && p.focusNode.nodeType == 1) {
            let b = p.focusNode.childNodes[p.focusOffset];
            b && b.contentEditable == "false" && (o = !0)
        }
        if (!(o || m && Dt) && Co(u.node, u.offset, p.anchorNode, p.anchorOffset) && Co(f.node, f.offset, p.focusNode, p.focusOffset))
            return;
        let y = !1;
        if ((h.extend || e == n) && !(m && An)) {
            h.collapse(u.node, u.offset);
            try {
                e != n && h.extend(f.node, f.offset),
                y = !0
            } catch {}
        }
        if (!y) {
            if (e > n) {
                let C = u;
                u = f,
                f = C
            }
            let b = document.createRange();
            b.setEnd(f.node, f.offset),
            b.setStart(u.node, u.offset),
            h.removeAllRanges(),
            h.addRange(b)
        }
    }
    ignoreMutation(e) {
        return !this.contentDOM && e.type != "selection"
    }
    get contentLost() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
    }
    markDirty(e, n) {
        for (let r = 0, o = 0; o < this.children.length; o++) {
            let l = this.children[o]
              , a = r + l.size;
            if (r == a ? e <= a && n >= r : e < a && n > r) {
                let u = r + l.border
                  , f = a - l.border;
                if (e >= u && n <= f) {
                    this.dirty = e == r || n == a ? ao : fb,
                    e == u && n == f && (l.contentLost || l.dom.parentNode != this.contentDOM) ? l.dirty = Xn : l.markDirty(e - u, n - u);
                    return
                } else
                    l.dirty = l.dom == l.contentDOM && l.dom.parentNode == this.contentDOM && !l.children.length ? ao : Xn
            }
            r = a
        }
        this.dirty = ao
    }
    markParentsDirty() {
        let e = 1;
        for (let n = this.parent; n; n = n.parent,
        e++) {
            let r = e == 1 ? ao : fb;
            n.dirty < r && (n.dirty = r)
        }
    }
    get domAtom() {
        return !1
    }
    get ignoreForCoords() {
        return !1
    }
    get ignoreForSelection() {
        return !1
    }
    isText(e) {
        return !1
    }
}
class wx extends Ea {
    constructor(e, n, r, o) {
        let l, a = n.type.toDOM;
        if (typeof a == "function" && (a = a(r, () => {
            if (!l)
                return o;
            if (l.parent)
                return l.parent.posBeforeChild(l)
        }
        )),
        !n.type.spec.raw) {
            if (a.nodeType != 1) {
                let u = document.createElement("span");
                u.appendChild(a),
                a = u
            }
            a.contentEditable = "false",
            a.classList.add("ProseMirror-widget")
        }
        super(e, [], a, null),
        this.widget = n,
        this.widget = n,
        l = this
    }
    matchesWidget(e) {
        return this.dirty == Nn && e.type.eq(this.widget.type)
    }
    parseRule() {
        return {
            ignore: !0
        }
    }
    stopEvent(e) {
        let n = this.widget.spec.stopEvent;
        return n ? n(e) : !1
    }
    ignoreMutation(e) {
        return e.type != "selection" || this.widget.spec.ignoreSelection
    }
    destroy() {
        this.widget.type.destroy(this.dom),
        super.destroy()
    }
    get domAtom() {
        return !0
    }
    get ignoreForSelection() {
        return !!this.widget.type.spec.relaxedSide
    }
    get side() {
        return this.widget.type.side
    }
}
class P6 extends Ea {
    constructor(e, n, r, o) {
        super(e, [], n, null),
        this.textDOM = r,
        this.text = o
    }
    get size() {
        return this.text.length
    }
    localPosFromDOM(e, n) {
        return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n
    }
    domFromPos(e) {
        return {
            node: this.textDOM,
            offset: e
        }
    }
    ignoreMutation(e) {
        return e.type === "characterData" && e.target.nodeValue == e.oldValue
    }
}
class So extends Ea {
    constructor(e, n, r, o, l) {
        super(e, [], r, o),
        this.mark = n,
        this.spec = l
    }
    static create(e, n, r, o) {
        let l = o.nodeViews[n.type.name]
          , a = l && l(n, o, r);
        return (!a || !a.dom) && (a = ko.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)),
        new So(e,n,a.dom,a.contentDOM || a.dom,a)
    }
    parseRule() {
        return this.dirty & Xn || this.mark.type.spec.reparseInView ? null : {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM
        }
    }
    matchesMark(e) {
        return this.dirty != Xn && this.mark.eq(e)
    }
    markDirty(e, n) {
        if (super.markDirty(e, n),
        this.dirty != Nn) {
            let r = this.parent;
            for (; !r.node; )
                r = r.parent;
            r.dirty < this.dirty && (r.dirty = this.dirty),
            this.dirty = Nn
        }
    }
    slice(e, n, r) {
        let o = So.create(this.parent, this.mark, !0, r)
          , l = this.children
          , a = this.size;
        n < a && (l = Mm(l, n, a, r)),
        e > 0 && (l = Mm(l, 0, e, r));
        for (let u = 0; u < l.length; u++)
            l[u].parent = o;
        return o.children = l,
        o
    }
    ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e)
    }
    destroy() {
        this.spec.destroy && this.spec.destroy(),
        super.destroy()
    }
}
class wi extends Ea {
    constructor(e, n, r, o, l, a, u, f, h) {
        super(e, [], l, a),
        this.node = n,
        this.outerDeco = r,
        this.innerDeco = o,
        this.nodeDOM = u
    }
    static create(e, n, r, o, l, a) {
        let u = l.nodeViews[n.type.name], f, h = u && u(n, l, () => {
            if (!f)
                return a;
            if (f.parent)
                return f.parent.posBeforeChild(f)
        }
        , r, o), p = h && h.dom, m = h && h.contentDOM;
        if (n.isText) {
            if (!p)
                p = document.createTextNode(n.text);
            else if (p.nodeType != 3)
                throw new RangeError("Text must be rendered as a DOM text node")
        } else
            p || ({dom: p, contentDOM: m} = ko.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
        !m && !n.isText && p.nodeName != "BR" && (p.hasAttribute("contenteditable") || (p.contentEditable = "false"),
        n.type.spec.draggable && (p.draggable = !0));
        let y = p;
        return p = Mx(p, r, n),
        h ? f = new q6(e,n,r,o,p,m || null,y,h,l,a + 1) : n.isText ? new Lf(e,n,r,o,p,y,l) : new wi(e,n,r,o,p,m || null,y,l,a + 1)
    }
    parseRule() {
        if (this.node.type.spec.reparseInView)
            return null;
        let e = {
            node: this.node.type.name,
            attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"),
        !this.contentDOM)
            e.getContent = () => this.node.content;
        else if (!this.contentLost)
            e.contentElement = this.contentDOM;
        else {
            for (let n = this.children.length - 1; n >= 0; n--) {
                let r = this.children[n];
                if (this.dom.contains(r.dom.parentNode)) {
                    e.contentElement = r.dom.parentNode;
                    break
                }
            }
            e.contentElement || (e.getContent = () => Z.empty)
        }
        return e
    }
    matchesNode(e, n, r) {
        return this.dirty == Nn && e.eq(this.node) && Lu(n, this.outerDeco) && r.eq(this.innerDeco)
    }
    get size() {
        return this.node.nodeSize
    }
    get border() {
        return this.node.isLeaf ? 0 : 1
    }
    updateChildren(e, n) {
        let r = this.node.inlineContent
          , o = n
          , l = e.composing ? this.localCompositionInfo(e, n) : null
          , a = l && l.pos > -1 ? l : null
          , u = l && l.pos < 0
          , f = new F6(this,a && a.node,e);
        Y6(this.node, this.innerDeco, (h, p, m) => {
            h.spec.marks ? f.syncToMarks(h.spec.marks, r, e, p) : h.type.side >= 0 && !m && f.syncToMarks(p == this.node.childCount ? Ve.none : this.node.child(p).marks, r, e, p),
            f.placeWidget(h, e, o)
        }
        , (h, p, m, y) => {
            f.syncToMarks(h.marks, r, e, y);
            let b;
            f.findNodeMatch(h, p, m, y) || u && e.state.selection.from > o && e.state.selection.to < o + h.nodeSize && (b = f.findIndexWithChild(l.node)) > -1 && f.updateNodeAt(h, p, m, b, e) || f.updateNextNode(h, p, m, e, y, o) || f.addNode(h, p, m, e, o),
            o += h.nodeSize
        }
        ),
        f.syncToMarks([], r, e, 0),
        this.node.isTextblock && f.addTextblockHacks(),
        f.destroyRest(),
        (f.changed || this.dirty == ao) && (a && this.protectLocalComposition(e, a),
        Tx(this.contentDOM, this.children, e),
        zl && Z6(this.dom))
    }
    localCompositionInfo(e, n) {
        let {from: r, to: o} = e.state.selection;
        if (!(e.state.selection instanceof se) || r < n || o > n + this.node.content.size)
            return null;
        let l = e.input.compositionNode;
        if (!l || !this.dom.contains(l.parentNode))
            return null;
        if (this.node.inlineContent) {
            let a = l.nodeValue
              , u = W6(this.node.content, a, r - n, o - n);
            return u < 0 ? null : {
                node: l,
                pos: u,
                text: a
            }
        } else
            return {
                node: l,
                pos: -1,
                text: ""
            }
    }
    protectLocalComposition(e, {node: n, pos: r, text: o}) {
        if (this.getDesc(n))
            return;
        let l = n;
        for (; l.parentNode != this.contentDOM; l = l.parentNode) {
            for (; l.previousSibling; )
                l.parentNode.removeChild(l.previousSibling);
            for (; l.nextSibling; )
                l.parentNode.removeChild(l.nextSibling);
            l.pmViewDesc && (l.pmViewDesc = void 0)
        }
        let a = new P6(this,l,n,o);
        e.input.compositionNodes.push(a),
        this.children = Mm(this.children, r, r + o.length, e, a)
    }
    update(e, n, r, o) {
        return this.dirty == Xn || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, o),
        !0)
    }
    updateInner(e, n, r, o) {
        this.updateOuterDeco(n),
        this.node = e,
        this.innerDeco = r,
        this.contentDOM && this.updateChildren(o, this.posAtStart),
        this.dirty = Nn
    }
    updateOuterDeco(e) {
        if (Lu(e, this.outerDeco))
            return;
        let n = this.nodeDOM.nodeType != 1
          , r = this.dom;
        this.dom = kx(this.dom, this.nodeDOM, km(this.outerDeco, this.node, n), km(e, this.node, n)),
        this.dom != r && (r.pmViewDesc = void 0,
        this.dom.pmViewDesc = this),
        this.outerDeco = e
    }
    selectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0))
    }
    deselectNode() {
        this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"),
        (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"))
    }
    get domAtom() {
        return this.node.isAtom
    }
}
function db(t, e, n, r, o) {
    Mx(r, e, t);
    let l = new wi(void 0,t,e,n,r,r,r,o,0);
    return l.contentDOM && l.updateChildren(o, 0),
    l
}
class Lf extends wi {
    constructor(e, n, r, o, l, a, u) {
        super(e, n, r, o, l, null, a, u, 0)
    }
    parseRule() {
        let e = this.nodeDOM.parentNode;
        for (; e && e != this.dom && !e.pmIsDeco; )
            e = e.parentNode;
        return {
            skip: e || !0
        }
    }
    update(e, n, r, o) {
        return this.dirty == Xn || this.dirty != Nn && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n),
        (this.dirty != Nn || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text,
        o.trackWrites == this.nodeDOM && (o.trackWrites = null)),
        this.node = e,
        this.dirty = Nn,
        !0)
    }
    inParent() {
        let e = this.parent.contentDOM;
        for (let n = this.nodeDOM; n; n = n.parentNode)
            if (n == e)
                return !0;
        return !1
    }
    domFromPos(e) {
        return {
            node: this.nodeDOM,
            offset: e
        }
    }
    localPosFromDOM(e, n, r) {
        return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r)
    }
    ignoreMutation(e) {
        return e.type != "characterData" && e.type != "selection"
    }
    slice(e, n, r) {
        let o = this.node.cut(e, n)
          , l = document.createTextNode(o.text);
        return new Lf(this.parent,o,this.outerDeco,this.innerDeco,l,l,r)
    }
    markDirty(e, n) {
        super.markDirty(e, n),
        this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Xn)
    }
    get domAtom() {
        return !1
    }
    isText(e) {
        return this.node.text == e
    }
}
class Ex extends Ea {
    parseRule() {
        return {
            ignore: !0
        }
    }
    matchesHack(e) {
        return this.dirty == Nn && this.dom.nodeName == e
    }
    get domAtom() {
        return !0
    }
    get ignoreForCoords() {
        return this.dom.nodeName == "IMG"
    }
}
class q6 extends wi {
    constructor(e, n, r, o, l, a, u, f, h, p) {
        super(e, n, r, o, l, a, u, h, p),
        this.spec = f
    }
    update(e, n, r, o) {
        if (this.dirty == Xn)
            return !1;
        if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
            let l = this.spec.update(e, n, r);
            return l && this.updateInner(e, n, r, o),
            l
        } else
            return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, o)
    }
    selectNode() {
        this.spec.selectNode ? this.spec.selectNode() : super.selectNode()
    }
    deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode()
    }
    setSelection(e, n, r, o) {
        this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, o)
    }
    destroy() {
        this.spec.destroy && this.spec.destroy(),
        super.destroy()
    }
    stopEvent(e) {
        return this.spec.stopEvent ? this.spec.stopEvent(e) : !1
    }
    ignoreMutation(e) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e)
    }
}
function Tx(t, e, n) {
    let r = t.firstChild
      , o = !1;
    for (let l = 0; l < e.length; l++) {
        let a = e[l]
          , u = a.dom;
        if (u.parentNode == t) {
            for (; u != r; )
                r = hb(r),
                o = !0;
            r = r.nextSibling
        } else
            o = !0,
            t.insertBefore(u, r);
        if (a instanceof So) {
            let f = r ? r.previousSibling : t.lastChild;
            Tx(a.contentDOM, a.children, n),
            r = f ? f.nextSibling : t.firstChild
        }
    }
    for (; r; )
        r = hb(r),
        o = !0;
    o && n.trackWrites == t && (n.trackWrites = null)
}
const ea = function(t) {
    t && (this.nodeName = t)
};
ea.prototype = Object.create(null);
const co = [new ea];
function km(t, e, n) {
    if (t.length == 0)
        return co;
    let r = n ? co[0] : new ea
      , o = [r];
    for (let l = 0; l < t.length; l++) {
        let a = t[l].type.attrs;
        if (a) {
            a.nodeName && o.push(r = new ea(a.nodeName));
            for (let u in a) {
                let f = a[u];
                f != null && (n && o.length == 1 && o.push(r = new ea(e.isInline ? "span" : "div")),
                u == "class" ? r.class = (r.class ? r.class + " " : "") + f : u == "style" ? r.style = (r.style ? r.style + ";" : "") + f : u != "nodeName" && (r[u] = f))
            }
        }
    }
    return o
}
function kx(t, e, n, r) {
    if (n == co && r == co)
        return e;
    let o = e;
    for (let l = 0; l < r.length; l++) {
        let a = r[l]
          , u = n[l];
        if (l) {
            let f;
            u && u.nodeName == a.nodeName && o != t && (f = o.parentNode) && f.nodeName.toLowerCase() == a.nodeName || (f = document.createElement(a.nodeName),
            f.pmIsDeco = !0,
            f.appendChild(o),
            u = co[0]),
            o = f
        }
        $6(o, u || co[0], a)
    }
    return o
}
function $6(t, e, n) {
    for (let r in e)
        r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
    for (let r in n)
        r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
    if (e.class != n.class) {
        let r = e.class ? e.class.split(" ").filter(Boolean) : []
          , o = n.class ? n.class.split(" ").filter(Boolean) : [];
        for (let l = 0; l < r.length; l++)
            o.indexOf(r[l]) == -1 && t.classList.remove(r[l]);
        for (let l = 0; l < o.length; l++)
            r.indexOf(o[l]) == -1 && t.classList.add(o[l]);
        t.classList.length == 0 && t.removeAttribute("class")
    }
    if (e.style != n.style) {
        if (e.style) {
            let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
            for (; o = r.exec(e.style); )
                t.style.removeProperty(o[1])
        }
        n.style && (t.style.cssText += n.style)
    }
}
function Mx(t, e, n) {
    return kx(t, t, co, km(e, n, t.nodeType != 1))
}
function Lu(t, e) {
    if (t.length != e.length)
        return !1;
    for (let n = 0; n < t.length; n++)
        if (!t[n].type.eq(e[n].type))
            return !1;
    return !0
}
function hb(t) {
    let e = t.nextSibling;
    return t.parentNode.removeChild(t),
    e
}
class F6 {
    constructor(e, n, r) {
        this.lock = n,
        this.view = r,
        this.index = 0,
        this.stack = [],
        this.changed = !1,
        this.top = e,
        this.preMatch = K6(e.node.content, e)
    }
    destroyBetween(e, n) {
        if (e != n) {
            for (let r = e; r < n; r++)
                this.top.children[r].destroy();
            this.top.children.splice(e, n - e),
            this.changed = !0
        }
    }
    destroyRest() {
        this.destroyBetween(this.index, this.top.children.length)
    }
    syncToMarks(e, n, r, o) {
        let l = 0
          , a = this.stack.length >> 1
          , u = Math.min(a, e.length);
        for (; l < u && (l == a - 1 ? this.top : this.stack[l + 1 << 1]).matchesMark(e[l]) && e[l].type.spec.spanning !== !1; )
            l++;
        for (; l < a; )
            this.destroyRest(),
            this.top.dirty = Nn,
            this.index = this.stack.pop(),
            this.top = this.stack.pop(),
            a--;
        for (; a < e.length; ) {
            this.stack.push(this.top, this.index + 1);
            let f = -1
              , h = this.top.children.length;
            o < this.preMatch.index && (h = Math.min(this.index + 3, h));
            for (let p = this.index; p < h; p++) {
                let m = this.top.children[p];
                if (m.matchesMark(e[a]) && !this.isLocked(m.dom)) {
                    f = p;
                    break
                }
            }
            if (f > -1)
                f > this.index && (this.changed = !0,
                this.destroyBetween(this.index, f)),
                this.top = this.top.children[this.index];
            else {
                let p = So.create(this.top, e[a], n, r);
                this.top.children.splice(this.index, 0, p),
                this.top = p,
                this.changed = !0
            }
            this.index = 0,
            a++
        }
    }
    findNodeMatch(e, n, r, o) {
        let l = -1, a;
        if (o >= this.preMatch.index && (a = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && a.matchesNode(e, n, r))
            l = this.top.children.indexOf(a, this.index);
        else
            for (let u = this.index, f = Math.min(this.top.children.length, u + 5); u < f; u++) {
                let h = this.top.children[u];
                if (h.matchesNode(e, n, r) && !this.preMatch.matched.has(h)) {
                    l = u;
                    break
                }
            }
        return l < 0 ? !1 : (this.destroyBetween(this.index, l),
        this.index++,
        !0)
    }
    updateNodeAt(e, n, r, o, l) {
        let a = this.top.children[o];
        return a.dirty == Xn && a.dom == a.contentDOM && (a.dirty = ao),
        a.update(e, n, r, l) ? (this.destroyBetween(this.index, o),
        this.index++,
        !0) : !1
    }
    findIndexWithChild(e) {
        for (; ; ) {
            let n = e.parentNode;
            if (!n)
                return -1;
            if (n == this.top.contentDOM) {
                let r = e.pmViewDesc;
                if (r) {
                    for (let o = this.index; o < this.top.children.length; o++)
                        if (this.top.children[o] == r)
                            return o
                }
                return -1
            }
            e = n
        }
    }
    updateNextNode(e, n, r, o, l, a) {
        for (let u = this.index; u < this.top.children.length; u++) {
            let f = this.top.children[u];
            if (f instanceof wi) {
                let h = this.preMatch.matched.get(f);
                if (h != null && h != l)
                    return !1;
                let p = f.dom, m, y = this.isLocked(p) && !(e.isText && f.node && f.node.isText && f.nodeDOM.nodeValue == e.text && f.dirty != Xn && Lu(n, f.outerDeco));
                if (!y && f.update(e, n, r, o))
                    return this.destroyBetween(this.index, u),
                    f.dom != p && (this.changed = !0),
                    this.index++,
                    !0;
                if (!y && (m = this.recreateWrapper(f, e, n, r, o, a)))
                    return this.destroyBetween(this.index, u),
                    this.top.children[this.index] = m,
                    m.contentDOM && (m.dirty = ao,
                    m.updateChildren(o, a + 1),
                    m.dirty = Nn),
                    this.changed = !0,
                    this.index++,
                    !0;
                break
            }
        }
        return !1
    }
    recreateWrapper(e, n, r, o, l, a) {
        if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !Lu(r, e.outerDeco) || !o.eq(e.innerDeco))
            return null;
        let u = wi.create(this.top, n, r, o, l, a);
        if (u.contentDOM) {
            u.children = e.children,
            e.children = [];
            for (let f of u.children)
                f.parent = u
        }
        return e.destroy(),
        u
    }
    addNode(e, n, r, o, l) {
        let a = wi.create(this.top, e, n, r, o, l);
        a.contentDOM && a.updateChildren(o, l + 1),
        this.top.children.splice(this.index++, 0, a),
        this.changed = !0
    }
    placeWidget(e, n, r) {
        let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
            this.index++;
        else {
            let l = new wx(this.top,e,n,r);
            this.top.children.splice(this.index++, 0, l),
            this.changed = !0
        }
    }
    addTextblockHacks() {
        let e = this.top.children[this.index - 1]
          , n = this.top;
        for (; e instanceof So; )
            n = e,
            e = n.children[n.children.length - 1];
        (!e || !(e instanceof Lf) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Dt || At) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n),
        this.addHackNode("BR", this.top))
    }
    addHackNode(e, n) {
        if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
            this.index++;
        else {
            let r = document.createElement(e);
            e == "IMG" && (r.className = "ProseMirror-separator",
            r.alt = ""),
            e == "BR" && (r.className = "ProseMirror-trailingBreak");
            let o = new Ex(this.top,[],r,null);
            n != this.top ? n.children.push(o) : n.children.splice(this.index++, 0, o),
            this.changed = !0
        }
    }
    isLocked(e) {
        return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode))
    }
}
function K6(t, e) {
    let n = e
      , r = n.children.length
      , o = t.childCount
      , l = new Map
      , a = [];
    e: for (; o > 0; ) {
        let u;
        for (; ; )
            if (r) {
                let h = n.children[r - 1];
                if (h instanceof So)
                    n = h,
                    r = h.children.length;
                else {
                    u = h,
                    r--;
                    break
                }
            } else {
                if (n == e)
                    break e;
                r = n.parent.children.indexOf(n),
                n = n.parent
            }
        let f = u.node;
        if (f) {
            if (f != t.child(o - 1))
                break;
            --o,
            l.set(u, o),
            a.push(u)
        }
    }
    return {
        index: o,
        matched: l,
        matches: a.reverse()
    }
}
function G6(t, e) {
    return t.type.side - e.type.side
}
function Y6(t, e, n, r) {
    let o = e.locals(t)
      , l = 0;
    if (o.length == 0) {
        for (let h = 0; h < t.childCount; h++) {
            let p = t.child(h);
            r(p, o, e.forChild(l, p), h),
            l += p.nodeSize
        }
        return
    }
    let a = 0
      , u = []
      , f = null;
    for (let h = 0; ; ) {
        let p, m;
        for (; a < o.length && o[a].to == l; ) {
            let w = o[a++];
            w.widget && (p ? (m || (m = [p])).push(w) : p = w)
        }
        if (p)
            if (m) {
                m.sort(G6);
                for (let w = 0; w < m.length; w++)
                    n(m[w], h, !!f)
            } else
                n(p, h, !!f);
        let y, b;
        if (f)
            b = -1,
            y = f,
            f = null;
        else if (h < t.childCount)
            b = h,
            y = t.child(h++);
        else
            break;
        for (let w = 0; w < u.length; w++)
            u[w].to <= l && u.splice(w--, 1);
        for (; a < o.length && o[a].from <= l && o[a].to > l; )
            u.push(o[a++]);
        let C = l + y.nodeSize;
        if (y.isText) {
            let w = C;
            a < o.length && o[a].from < w && (w = o[a].from);
            for (let k = 0; k < u.length; k++)
                u[k].to < w && (w = u[k].to);
            w < C && (f = y.cut(w - l),
            y = y.cut(0, w - l),
            C = w,
            b = -1)
        } else
            for (; a < o.length && o[a].to < C; )
                a++;
        let S = y.isInline && !y.isLeaf ? u.filter(w => !w.inline) : u.slice();
        r(y, S, e.forChild(l, y), b),
        l = C
    }
}
function Z6(t) {
    if (t.nodeName == "UL" || t.nodeName == "OL") {
        let e = t.style.cssText;
        t.style.cssText = e + "; list-style: square !important",
        window.getComputedStyle(t).listStyle,
        t.style.cssText = e
    }
}
function W6(t, e, n, r) {
    for (let o = 0, l = 0; o < t.childCount && l <= r; ) {
        let a = t.child(o++)
          , u = l;
        if (l += a.nodeSize,
        !a.isText)
            continue;
        let f = a.text;
        for (; o < t.childCount; ) {
            let h = t.child(o++);
            if (l += h.nodeSize,
            !h.isText)
                break;
            f += h.text
        }
        if (l >= n) {
            if (l >= r && f.slice(r - e.length - u, r - u) == e)
                return r - e.length;
            let h = u < r ? f.lastIndexOf(e, r - u - 1) : -1;
            if (h >= 0 && h + e.length + u >= n)
                return u + h;
            if (n == r && f.length >= r + e.length - u && f.slice(r - u, r - u + e.length) == e)
                return r
        }
    }
    return -1
}
function Mm(t, e, n, r, o) {
    let l = [];
    for (let a = 0, u = 0; a < t.length; a++) {
        let f = t[a]
          , h = u
          , p = u += f.size;
        h >= n || p <= e ? l.push(f) : (h < e && l.push(f.slice(0, e - h, r)),
        o && (l.push(o),
        o = void 0),
        p > n && l.push(f.slice(n - h, f.size, r)))
    }
    return l
}
function k1(t, e=null) {
    let n = t.domSelectionRange()
      , r = t.state.doc;
    if (!n.focusNode)
        return null;
    let o = t.docView.nearestDesc(n.focusNode)
      , l = o && o.size == 0
      , a = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
    if (a < 0)
        return null;
    let u = r.resolve(a), f, h;
    if (Df(n)) {
        for (f = a; o && !o.node; )
            o = o.parent;
        let m = o.node;
        if (o && m.isAtom && le.isSelectable(m) && o.parent && !(m.isInline && w6(n.focusNode, n.focusOffset, o.dom))) {
            let y = o.posBefore;
            h = new le(a == y ? u : r.resolve(y))
        }
    } else {
        if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
            let m = a
              , y = a;
            for (let b = 0; b < n.rangeCount; b++) {
                let C = n.getRangeAt(b);
                m = Math.min(m, t.docView.posFromDOM(C.startContainer, C.startOffset, 1)),
                y = Math.max(y, t.docView.posFromDOM(C.endContainer, C.endOffset, -1))
            }
            if (m < 0)
                return null;
            [f,a] = y == t.state.selection.anchor ? [y, m] : [m, y],
            u = r.resolve(a)
        } else
            f = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
        if (f < 0)
            return null
    }
    let p = r.resolve(f);
    if (!h) {
        let m = e == "pointer" || t.state.selection.head < u.pos && !l ? 1 : -1;
        h = M1(t, p, u, m)
    }
    return h
}
function Ax(t) {
    return t.editable ? t.hasFocus() : Rx(t) && document.activeElement && document.activeElement.contains(t.dom)
}
function Nr(t, e=!1) {
    let n = t.state.selection;
    if (Nx(t, n),
    !!Ax(t)) {
        if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && At) {
            let r = t.domSelectionRange()
              , o = t.domObserver.currentSelection;
            if (r.anchorNode && o.anchorNode && Co(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
                t.input.mouseDown.delayedSelectionSync = !0,
                t.domObserver.setCurSelection();
                return
            }
        }
        if (t.domObserver.disconnectSelection(),
        t.cursorWrapper)
            J6(t);
        else {
            let {anchor: r, head: o} = n, l, a;
            pb && !(n instanceof se) && (n.$from.parent.inlineContent || (l = mb(t, n.from)),
            !n.empty && !n.$from.parent.inlineContent && (a = mb(t, n.to))),
            t.docView.setSelection(r, o, t, e),
            pb && (l && gb(l),
            a && gb(a)),
            n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"),
            "onselectionchange"in document && X6(t))
        }
        t.domObserver.setCurSelection(),
        t.domObserver.connectSelection()
    }
}
const pb = Dt || At && mx < 63;
function mb(t, e) {
    let {node: n, offset: r} = t.docView.domFromPos(e, 0)
      , o = r < n.childNodes.length ? n.childNodes[r] : null
      , l = r ? n.childNodes[r - 1] : null;
    if (Dt && o && o.contentEditable == "false")
        return Lp(o);
    if ((!o || o.contentEditable == "false") && (!l || l.contentEditable == "false")) {
        if (o)
            return Lp(o);
        if (l)
            return Lp(l)
    }
}
function Lp(t) {
    return t.contentEditable = "true",
    Dt && t.draggable && (t.draggable = !1,
    t.wasDraggable = !0),
    t
}
function gb(t) {
    t.contentEditable = "false",
    t.wasDraggable && (t.draggable = !0,
    t.wasDraggable = null)
}
function X6(t) {
    let e = t.dom.ownerDocument;
    e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
    let n = t.domSelectionRange()
      , r = n.anchorNode
      , o = n.anchorOffset;
    e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
        (n.anchorNode != r || n.anchorOffset != o) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard),
        setTimeout( () => {
            (!Ax(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection")
        }
        , 20))
    }
    )
}
function J6(t) {
    let e = t.domSelection();
    if (!e)
        return;
    let n = t.cursorWrapper.dom
      , r = n.nodeName == "IMG";
    r ? e.collapse(n.parentNode, kt(n) + 1) : e.collapse(n, 0),
    !r && !t.state.selection.visible && Wt && xi <= 11 && (n.disabled = !0,
    n.disabled = !1)
}
function Nx(t, e) {
    if (e instanceof le) {
        let n = t.docView.descAt(e.from);
        n != t.lastSelectedViewDesc && (yb(t),
        n && n.selectNode(),
        t.lastSelectedViewDesc = n)
    } else
        yb(t)
}
function yb(t) {
    t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
    t.lastSelectedViewDesc = void 0)
}
function M1(t, e, n, r) {
    return t.someProp("createSelectionBetween", o => o(t, e, n)) || se.between(e, n, r)
}
function vb(t) {
    return t.editable && !t.hasFocus() ? !1 : Rx(t)
}
function Rx(t) {
    let e = t.domSelectionRange();
    if (!e.anchorNode)
        return !1;
    try {
        return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode))
    } catch {
        return !1
    }
}
function Q6(t) {
    let e = t.docView.domFromPos(t.state.selection.anchor, 0)
      , n = t.domSelectionRange();
    return Co(e.node, e.offset, n.anchorNode, n.anchorOffset)
}
function Am(t, e) {
    let {$anchor: n, $head: r} = t.selection
      , o = e > 0 ? n.max(r) : n.min(r)
      , l = o.parent.inlineContent ? o.depth ? t.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
    return l && ye.findFrom(l, e)
}
function fi(t, e) {
    return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()),
    !0
}
function bb(t, e, n) {
    let r = t.state.selection;
    if (r instanceof se)
        if (n.indexOf("s") > -1) {
            let {$head: o} = r
              , l = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
            if (!l || l.isText || !l.isLeaf)
                return !1;
            let a = t.state.doc.resolve(o.pos + l.nodeSize * (e < 0 ? -1 : 1));
            return fi(t, new se(r.$anchor,a))
        } else if (r.empty) {
            if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
                let o = Am(t.state, e);
                return o && o instanceof le ? fi(t, o) : !1
            } else if (!(kn && n.indexOf("m") > -1)) {
                let o = r.$head, l = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, a;
                if (!l || l.isText)
                    return !1;
                let u = e < 0 ? o.pos - l.nodeSize : o.pos;
                return l.isAtom || (a = t.docView.descAt(u)) && !a.contentDOM ? le.isSelectable(l) ? fi(t, new le(e < 0 ? t.state.doc.resolve(o.pos - l.nodeSize) : o)) : wa ? fi(t, new se(t.state.doc.resolve(e < 0 ? u : u + l.nodeSize))) : !1 : !1
            }
        } else
            return !1;
    else {
        if (r instanceof le && r.node.isInline)
            return fi(t, new se(e > 0 ? r.$to : r.$from));
        {
            let o = Am(t.state, e);
            return o ? fi(t, o) : !1
        }
    }
}
function zu(t) {
    return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length
}
function ta(t, e) {
    let n = t.pmViewDesc;
    return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR")
}
function yl(t, e) {
    return e < 0 ? eT(t) : tT(t)
}
function eT(t) {
    let e = t.domSelectionRange()
      , n = e.focusNode
      , r = e.focusOffset;
    if (!n)
        return;
    let o, l, a = !1;
    for (An && n.nodeType == 1 && r < zu(n) && ta(n.childNodes[r], -1) && (a = !0); ; )
        if (r > 0) {
            if (n.nodeType != 1)
                break;
            {
                let u = n.childNodes[r - 1];
                if (ta(u, -1))
                    o = n,
                    l = --r;
                else if (u.nodeType == 3)
                    n = u,
                    r = n.nodeValue.length;
                else
                    break
            }
        } else {
            if (Ox(n))
                break;
            {
                let u = n.previousSibling;
                for (; u && ta(u, -1); )
                    o = n.parentNode,
                    l = kt(u),
                    u = u.previousSibling;
                if (u)
                    n = u,
                    r = zu(n);
                else {
                    if (n = n.parentNode,
                    n == t.dom)
                        break;
                    r = 0
                }
            }
        }
    a ? Nm(t, n, r) : o && Nm(t, o, l)
}
function tT(t) {
    let e = t.domSelectionRange()
      , n = e.focusNode
      , r = e.focusOffset;
    if (!n)
        return;
    let o = zu(n), l, a;
    for (; ; )
        if (r < o) {
            if (n.nodeType != 1)
                break;
            let u = n.childNodes[r];
            if (ta(u, 1))
                l = n,
                a = ++r;
            else
                break
        } else {
            if (Ox(n))
                break;
            {
                let u = n.nextSibling;
                for (; u && ta(u, 1); )
                    l = u.parentNode,
                    a = kt(u) + 1,
                    u = u.nextSibling;
                if (u)
                    n = u,
                    r = 0,
                    o = zu(n);
                else {
                    if (n = n.parentNode,
                    n == t.dom)
                        break;
                    r = o = 0
                }
            }
        }
    l && Nm(t, l, a)
}
function Ox(t) {
    let e = t.pmViewDesc;
    return e && e.node && e.node.isBlock
}
function nT(t, e) {
    for (; t && e == t.childNodes.length && !xa(t); )
        e = kt(t) + 1,
        t = t.parentNode;
    for (; t && e < t.childNodes.length; ) {
        let n = t.childNodes[e];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        t = n,
        e = 0
    }
}
function rT(t, e) {
    for (; t && !e && !xa(t); )
        e = kt(t),
        t = t.parentNode;
    for (; t && e; ) {
        let n = t.childNodes[e - 1];
        if (n.nodeType == 3)
            return n;
        if (n.nodeType == 1 && n.contentEditable == "false")
            break;
        t = n,
        e = t.childNodes.length
    }
}
function Nm(t, e, n) {
    if (e.nodeType != 3) {
        let l, a;
        (a = nT(e, n)) ? (e = a,
        n = 0) : (l = rT(e, n)) && (e = l,
        n = l.nodeValue.length)
    }
    let r = t.domSelection();
    if (!r)
        return;
    if (Df(r)) {
        let l = document.createRange();
        l.setEnd(e, n),
        l.setStart(e, n),
        r.removeAllRanges(),
        r.addRange(l)
    } else
        r.extend && r.extend(e, n);
    t.domObserver.setCurSelection();
    let {state: o} = t;
    setTimeout( () => {
        t.state == o && Nr(t)
    }
    , 50)
}
function Cb(t, e) {
    let n = t.state.doc.resolve(e);
    if (!(At || gx) && n.parent.inlineContent) {
        let o = t.coordsAtPos(e);
        if (e > n.start()) {
            let l = t.coordsAtPos(e - 1)
              , a = (l.top + l.bottom) / 2;
            if (a > o.top && a < o.bottom && Math.abs(l.left - o.left) > 1)
                return l.left < o.left ? "ltr" : "rtl"
        }
        if (e < n.end()) {
            let l = t.coordsAtPos(e + 1)
              , a = (l.top + l.bottom) / 2;
            if (a > o.top && a < o.bottom && Math.abs(l.left - o.left) > 1)
                return l.left > o.left ? "ltr" : "rtl"
        }
    }
    return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr"
}
function Sb(t, e, n) {
    let r = t.state.selection;
    if (r instanceof se && !r.empty || n.indexOf("s") > -1 || kn && n.indexOf("m") > -1)
        return !1;
    let {$from: o, $to: l} = r;
    if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
        let a = Am(t.state, e);
        if (a && a instanceof le)
            return fi(t, a)
    }
    if (!o.parent.inlineContent) {
        let a = e < 0 ? o : l
          , u = r instanceof Zt ? ye.near(a, e) : ye.findFrom(a, e);
        return u ? fi(t, u) : !1
    }
    return !1
}
function xb(t, e) {
    if (!(t.state.selection instanceof se))
        return !0;
    let {$head: n, $anchor: r, empty: o} = t.state.selection;
    if (!n.sameParent(r))
        return !0;
    if (!o)
        return !1;
    if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
        return !0;
    let l = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
    if (l && !l.isText) {
        let a = t.state.tr;
        return e < 0 ? a.delete(n.pos - l.nodeSize, n.pos) : a.delete(n.pos, n.pos + l.nodeSize),
        t.dispatch(a),
        !0
    }
    return !1
}
function wb(t, e, n) {
    t.domObserver.stop(),
    e.contentEditable = n,
    t.domObserver.start()
}
function iT(t) {
    if (!Dt || t.state.selection.$head.parentOffset > 0)
        return !1;
    let {focusNode: e, focusOffset: n} = t.domSelectionRange();
    if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
        let r = e.firstChild;
        wb(t, r, "true"),
        setTimeout( () => wb(t, r, "false"), 20)
    }
    return !1
}
function oT(t) {
    let e = "";
    return t.ctrlKey && (e += "c"),
    t.metaKey && (e += "m"),
    t.altKey && (e += "a"),
    t.shiftKey && (e += "s"),
    e
}
function lT(t, e) {
    let n = e.keyCode
      , r = oT(e);
    if (n == 8 || kn && n == 72 && r == "c")
        return xb(t, -1) || yl(t, -1);
    if (n == 46 && !e.shiftKey || kn && n == 68 && r == "c")
        return xb(t, 1) || yl(t, 1);
    if (n == 13 || n == 27)
        return !0;
    if (n == 37 || kn && n == 66 && r == "c") {
        let o = n == 37 ? Cb(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
        return bb(t, o, r) || yl(t, o)
    } else if (n == 39 || kn && n == 70 && r == "c") {
        let o = n == 39 ? Cb(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
        return bb(t, o, r) || yl(t, o)
    } else {
        if (n == 38 || kn && n == 80 && r == "c")
            return Sb(t, -1, r) || yl(t, -1);
        if (n == 40 || kn && n == 78 && r == "c")
            return iT(t) || Sb(t, 1, r) || yl(t, 1);
        if (r == (kn ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
            return !0
    }
    return !1
}
function A1(t, e) {
    t.someProp("transformCopied", b => {
        e = b(e, t)
    }
    );
    let n = []
      , {content: r, openStart: o, openEnd: l} = e;
    for (; o > 1 && l > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
        o--,
        l--;
        let b = r.firstChild;
        n.push(b.type.name, b.attrs != b.type.defaultAttrs ? b.attrs : null),
        r = b.content
    }
    let a = t.someProp("clipboardSerializer") || ko.fromSchema(t.state.schema)
      , u = jx()
      , f = u.createElement("div");
    f.appendChild(a.serializeFragment(r, {
        document: u
    }));
    let h = f.firstChild, p, m = 0;
    for (; h && h.nodeType == 1 && (p = Bx[h.nodeName.toLowerCase()]); ) {
        for (let b = p.length - 1; b >= 0; b--) {
            let C = u.createElement(p[b]);
            for (; f.firstChild; )
                C.appendChild(f.firstChild);
            f.appendChild(C),
            m++
        }
        h = f.firstChild
    }
    h && h.nodeType == 1 && h.setAttribute("data-pm-slice", `${o} ${l}${m ? ` -${m}` : ""} ${JSON.stringify(n)}`);
    let y = t.someProp("clipboardTextSerializer", b => b(e, t)) || e.content.textBetween(0, e.content.size, `

`);
    return {
        dom: f,
        text: y,
        slice: e
    }
}
function Dx(t, e, n, r, o) {
    let l = o.parent.type.spec.code, a, u;
    if (!n && !e)
        return null;
    let f = !!e && (r || l || !n);
    if (f) {
        if (t.someProp("transformPastedText", y => {
            e = y(e, l || r, t)
        }
        ),
        l)
            return u = new te(Z.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))),0,0),
            t.someProp("transformPasted", y => {
                u = y(u, t, !0)
            }
            ),
            u;
        let m = t.someProp("clipboardTextParser", y => y(e, o, r, t));
        if (m)
            u = m;
        else {
            let y = o.marks()
              , {schema: b} = t.state
              , C = ko.fromSchema(b);
            a = document.createElement("div"),
            e.split(/(?:\r\n?|\n)+/).forEach(S => {
                let w = a.appendChild(document.createElement("p"));
                S && w.appendChild(C.serializeNode(b.text(S, y)))
            }
            )
        }
    } else
        t.someProp("transformPastedHTML", m => {
            n = m(n, t)
        }
        ),
        a = uT(n),
        wa && fT(a);
    let h = a && a.querySelector("[data-pm-slice]")
      , p = h && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(h.getAttribute("data-pm-slice") || "");
    if (p && p[3])
        for (let m = +p[3]; m > 0; m--) {
            let y = a.firstChild;
            for (; y && y.nodeType != 1; )
                y = y.nextSibling;
            if (!y)
                break;
            a = y
        }
    if (u || (u = (t.someProp("clipboardParser") || t.someProp("domParser") || Si.fromSchema(t.state.schema)).parseSlice(a, {
        preserveWhitespace: !!(f || p),
        context: o,
        ruleFromNode(y) {
            return y.nodeName == "BR" && !y.nextSibling && y.parentNode && !sT.test(y.parentNode.nodeName) ? {
                ignore: !0
            } : null
        }
    })),
    p)
        u = dT(Eb(u, +p[1], +p[2]), p[4]);
    else if (u = te.maxOpen(aT(u.content, o), !0),
    u.openStart || u.openEnd) {
        let m = 0
          , y = 0;
        for (let b = u.content.firstChild; m < u.openStart && !b.type.spec.isolating; m++,
        b = b.firstChild)
            ;
        for (let b = u.content.lastChild; y < u.openEnd && !b.type.spec.isolating; y++,
        b = b.lastChild)
            ;
        u = Eb(u, m, y)
    }
    return t.someProp("transformPasted", m => {
        u = m(u, t, f)
    }
    ),
    u
}
const sT = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function aT(t, e) {
    if (t.childCount < 2)
        return t;
    for (let n = e.depth; n >= 0; n--) {
        let o = e.node(n).contentMatchAt(e.index(n)), l, a = [];
        if (t.forEach(u => {
            if (!a)
                return;
            let f = o.findWrapping(u.type), h;
            if (!f)
                return a = null;
            if (h = a.length && l.length && zx(f, l, u, a[a.length - 1], 0))
                a[a.length - 1] = h;
            else {
                a.length && (a[a.length - 1] = _x(a[a.length - 1], l.length));
                let p = Lx(u, f);
                a.push(p),
                o = o.matchType(p.type),
                l = f
            }
        }
        ),
        a)
            return Z.from(a)
    }
    return t
}
function Lx(t, e, n=0) {
    for (let r = e.length - 1; r >= n; r--)
        t = e[r].create(null, Z.from(t));
    return t
}
function zx(t, e, n, r, o) {
    if (o < t.length && o < e.length && t[o] == e[o]) {
        let l = zx(t, e, n, r.lastChild, o + 1);
        if (l)
            return r.copy(r.content.replaceChild(r.childCount - 1, l));
        if (r.contentMatchAt(r.childCount).matchType(o == t.length - 1 ? n.type : t[o + 1]))
            return r.copy(r.content.append(Z.from(Lx(n, t, o + 1))))
    }
}
function _x(t, e) {
    if (e == 0)
        return t;
    let n = t.content.replaceChild(t.childCount - 1, _x(t.lastChild, e - 1))
      , r = t.contentMatchAt(t.childCount).fillBefore(Z.empty, !0);
    return t.copy(n.append(r))
}
function Rm(t, e, n, r, o, l) {
    let a = e < 0 ? t.firstChild : t.lastChild
      , u = a.content;
    return t.childCount > 1 && (l = 0),
    o < r - 1 && (u = Rm(u, e, n, r, o + 1, l)),
    o >= n && (u = e < 0 ? a.contentMatchAt(0).fillBefore(u, l <= o).append(u) : u.append(a.contentMatchAt(a.childCount).fillBefore(Z.empty, !0))),
    t.replaceChild(e < 0 ? 0 : t.childCount - 1, a.copy(u))
}
function Eb(t, e, n) {
    return e < t.openStart && (t = new te(Rm(t.content, -1, e, t.openStart, 0, t.openEnd),e,t.openEnd)),
    n < t.openEnd && (t = new te(Rm(t.content, 1, n, t.openEnd, 0, 0),t.openStart,n)),
    t
}
const Bx = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
};
let Tb = null;
function jx() {
    return Tb || (Tb = document.implementation.createHTMLDocument("title"))
}
let zp = null;
function cT(t) {
    let e = window.trustedTypes;
    return e ? (zp || (zp = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", {
        createHTML: n => n
    })),
    zp.createHTML(t)) : t
}
function uT(t) {
    let e = /^(\s*<meta [^>]*>)*/.exec(t);
    e && (t = t.slice(e[0].length));
    let n = jx().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), o;
    if ((o = r && Bx[r[1].toLowerCase()]) && (t = o.map(l => "<" + l + ">").join("") + t + o.map(l => "</" + l + ">").reverse().join("")),
    n.innerHTML = cT(t),
    o)
        for (let l = 0; l < o.length; l++)
            n = n.querySelector(o[l]) || n;
    return n
}
function fT(t) {
    let e = t.querySelectorAll(At ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let n = 0; n < e.length; n++) {
        let r = e[n];
        r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r)
    }
}
function dT(t, e) {
    if (!t.size)
        return t;
    let n = t.content.firstChild.type.schema, r;
    try {
        r = JSON.parse(e)
    } catch {
        return t
    }
    let {content: o, openStart: l, openEnd: a} = t;
    for (let u = r.length - 2; u >= 0; u -= 2) {
        let f = n.nodes[r[u]];
        if (!f || f.hasRequiredAttrs())
            break;
        o = Z.from(f.create(r[u + 1], o)),
        l++,
        a++
    }
    return new te(o,l,a)
}
const jt = {}
  , Ht = {}
  , hT = {
    touchstart: !0,
    touchmove: !0
};
class pT {
    constructor() {
        this.shiftKey = !1,
        this.mouseDown = null,
        this.lastKeyCode = null,
        this.lastKeyCodeTime = 0,
        this.lastClick = {
            time: 0,
            x: 0,
            y: 0,
            type: "",
            button: 0
        },
        this.lastSelectionOrigin = null,
        this.lastSelectionTime = 0,
        this.lastIOSEnter = 0,
        this.lastIOSEnterFallbackTimeout = -1,
        this.lastFocus = 0,
        this.lastTouch = 0,
        this.lastChromeDelete = 0,
        this.composing = !1,
        this.compositionNode = null,
        this.composingTimeout = -1,
        this.compositionNodes = [],
        this.compositionEndedAt = -2e8,
        this.compositionID = 1,
        this.badSafariComposition = !1,
        this.compositionPendingChanges = 0,
        this.domChangeCount = 0,
        this.eventHandlers = Object.create(null),
        this.hideSelectionGuard = null
    }
}
function mT(t) {
    for (let e in jt) {
        let n = jt[e];
        t.dom.addEventListener(e, t.input.eventHandlers[e] = r => {
            yT(t, r) && !N1(t, r) && (t.editable || !(r.type in Ht)) && n(t, r)
        }
        , hT[e] ? {
            passive: !0
        } : void 0)
    }
    Dt && t.dom.addEventListener("input", () => null),
    Om(t)
}
function bi(t, e) {
    t.input.lastSelectionOrigin = e,
    t.input.lastSelectionTime = Date.now()
}
function gT(t) {
    t.domObserver.stop();
    for (let e in t.input.eventHandlers)
        t.dom.removeEventListener(e, t.input.eventHandlers[e]);
    clearTimeout(t.input.composingTimeout),
    clearTimeout(t.input.lastIOSEnterFallbackTimeout)
}
function Om(t) {
    t.someProp("handleDOMEvents", e => {
        for (let n in e)
            t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = r => N1(t, r))
    }
    )
}
function N1(t, e) {
    return t.someProp("handleDOMEvents", n => {
        let r = n[e.type];
        return r ? r(t, e) || e.defaultPrevented : !1
    }
    )
}
function yT(t, e) {
    if (!e.bubbles)
        return !0;
    if (e.defaultPrevented)
        return !1;
    for (let n = e.target; n != t.dom; n = n.parentNode)
        if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
            return !1;
    return !0
}
function vT(t, e) {
    !N1(t, e) && jt[e.type] && (t.editable || !(e.type in Ht)) && jt[e.type](t, e)
}
Ht.keydown = (t, e) => {
    let n = e;
    if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey,
    !Ix(t, n) && (t.input.lastKeyCode = n.keyCode,
    t.input.lastKeyCodeTime = Date.now(),
    !(Mr && At && n.keyCode == 13)))
        if (n.keyCode != 229 && t.domObserver.forceFlush(),
        zl && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
            let r = Date.now();
            t.input.lastIOSEnter = r,
            t.input.lastIOSEnterFallbackTimeout = setTimeout( () => {
                t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", o => o(t, so(13, "Enter"))),
                t.input.lastIOSEnter = 0)
            }
            , 200)
        } else
            t.someProp("handleKeyDown", r => r(t, n)) || lT(t, n) ? n.preventDefault() : bi(t, "key")
}
;
Ht.keyup = (t, e) => {
    e.keyCode == 16 && (t.input.shiftKey = !1)
}
;
Ht.keypress = (t, e) => {
    let n = e;
    if (Ix(t, n) || !n.charCode || n.ctrlKey && !n.altKey || kn && n.metaKey)
        return;
    if (t.someProp("handleKeyPress", o => o(t, n))) {
        n.preventDefault();
        return
    }
    let r = t.state.selection;
    if (!(r instanceof se) || !r.$from.sameParent(r.$to)) {
        let o = String.fromCharCode(n.charCode)
          , l = () => t.state.tr.insertText(o).scrollIntoView();
        !/[\r\n]/.test(o) && !t.someProp("handleTextInput", a => a(t, r.$from.pos, r.$to.pos, o, l)) && t.dispatch(l()),
        n.preventDefault()
    }
}
;
function zf(t) {
    return {
        left: t.clientX,
        top: t.clientY
    }
}
function bT(t, e) {
    let n = e.x - t.clientX
      , r = e.y - t.clientY;
    return n * n + r * r < 100
}
function R1(t, e, n, r, o) {
    if (r == -1)
        return !1;
    let l = t.state.doc.resolve(r);
    for (let a = l.depth + 1; a > 0; a--)
        if (t.someProp(e, u => a > l.depth ? u(t, n, l.nodeAfter, l.before(a), o, !0) : u(t, n, l.node(a), l.before(a), o, !1)))
            return !0;
    return !1
}
function Al(t, e, n) {
    if (t.focused || t.focus(),
    t.state.selection.eq(e))
        return;
    let r = t.state.tr.setSelection(e);
    r.setMeta("pointer", !0),
    t.dispatch(r)
}
function CT(t, e) {
    if (e == -1)
        return !1;
    let n = t.state.doc.resolve(e)
      , r = n.nodeAfter;
    return r && r.isAtom && le.isSelectable(r) ? (Al(t, new le(n)),
    !0) : !1
}
function ST(t, e) {
    if (e == -1)
        return !1;
    let n = t.state.selection, r, o;
    n instanceof le && (r = n.node);
    let l = t.state.doc.resolve(e);
    for (let a = l.depth + 1; a > 0; a--) {
        let u = a > l.depth ? l.nodeAfter : l.node(a);
        if (le.isSelectable(u)) {
            r && n.$from.depth > 0 && a >= n.$from.depth && l.before(n.$from.depth + 1) == n.$from.pos ? o = l.before(n.$from.depth) : o = l.before(a);
            break
        }
    }
    return o != null ? (Al(t, le.create(t.state.doc, o)),
    !0) : !1
}
function xT(t, e, n, r, o) {
    return R1(t, "handleClickOn", e, n, r) || t.someProp("handleClick", l => l(t, e, r)) || (o ? ST(t, n) : CT(t, n))
}
function wT(t, e, n, r) {
    return R1(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", o => o(t, e, r))
}
function ET(t, e, n, r) {
    return R1(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", o => o(t, e, r)) || TT(t, n, r)
}
function TT(t, e, n) {
    if (n.button != 0)
        return !1;
    let r = t.state.doc;
    if (e == -1)
        return r.inlineContent ? (Al(t, se.create(r, 0, r.content.size)),
        !0) : !1;
    let o = r.resolve(e);
    for (let l = o.depth + 1; l > 0; l--) {
        let a = l > o.depth ? o.nodeAfter : o.node(l)
          , u = o.before(l);
        if (a.inlineContent)
            Al(t, se.create(r, u + 1, u + 1 + a.content.size));
        else if (le.isSelectable(a))
            Al(t, le.create(r, u));
        else
            continue;
        return !0
    }
}
function O1(t) {
    return _u(t)
}
const Hx = kn ? "metaKey" : "ctrlKey";
jt.mousedown = (t, e) => {
    let n = e;
    t.input.shiftKey = n.shiftKey;
    let r = O1(t)
      , o = Date.now()
      , l = "singleClick";
    o - t.input.lastClick.time < 500 && bT(n, t.input.lastClick) && !n[Hx] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? l = "doubleClick" : t.input.lastClick.type == "doubleClick" && (l = "tripleClick")),
    t.input.lastClick = {
        time: o,
        x: n.clientX,
        y: n.clientY,
        type: l,
        button: n.button
    };
    let a = t.posAtCoords(zf(n));
    a && (l == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(),
    t.input.mouseDown = new kT(t,a,n,!!r)) : (l == "doubleClick" ? wT : ET)(t, a.pos, a.inside, n) ? n.preventDefault() : bi(t, "pointer"))
}
;
class kT {
    constructor(e, n, r, o) {
        this.view = e,
        this.pos = n,
        this.event = r,
        this.flushed = o,
        this.delayedSelectionSync = !1,
        this.mightDrag = null,
        this.startDoc = e.state.doc,
        this.selectNode = !!r[Hx],
        this.allowDefault = r.shiftKey;
        let l, a;
        if (n.inside > -1)
            l = e.state.doc.nodeAt(n.inside),
            a = n.inside;
        else {
            let p = e.state.doc.resolve(n.pos);
            l = p.parent,
            a = p.depth ? p.before() : 0
        }
        const u = o ? null : r.target
          , f = u ? e.docView.nearestDesc(u, !0) : null;
        this.target = f && f.nodeDOM.nodeType == 1 ? f.nodeDOM : null;
        let {selection: h} = e.state;
        (r.button == 0 && l.type.spec.draggable && l.type.spec.selectable !== !1 || h instanceof le && h.from <= a && h.to > a) && (this.mightDrag = {
            node: l,
            pos: a,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && An && !this.target.hasAttribute("contentEditable"))
        }),
        this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(),
        this.mightDrag.addAttr && (this.target.draggable = !0),
        this.mightDrag.setUneditable && setTimeout( () => {
            this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false")
        }
        , 20),
        this.view.domObserver.start()),
        e.root.addEventListener("mouseup", this.up = this.up.bind(this)),
        e.root.addEventListener("mousemove", this.move = this.move.bind(this)),
        bi(e, "pointer")
    }
    done() {
        this.view.root.removeEventListener("mouseup", this.up),
        this.view.root.removeEventListener("mousemove", this.move),
        this.mightDrag && this.target && (this.view.domObserver.stop(),
        this.mightDrag.addAttr && this.target.removeAttribute("draggable"),
        this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"),
        this.view.domObserver.start()),
        this.delayedSelectionSync && setTimeout( () => Nr(this.view)),
        this.view.input.mouseDown = null
    }
    up(e) {
        if (this.done(),
        !this.view.dom.contains(e.target))
            return;
        let n = this.pos;
        this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(zf(e))),
        this.updateAllowDefault(e),
        this.allowDefault || !n ? bi(this.view, "pointer") : xT(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || Dt && this.mightDrag && !this.mightDrag.node.isAtom || At && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Al(this.view, ye.near(this.view.state.doc.resolve(n.pos))),
        e.preventDefault()) : bi(this.view, "pointer")
    }
    move(e) {
        this.updateAllowDefault(e),
        bi(this.view, "pointer"),
        e.buttons == 0 && this.done()
    }
    updateAllowDefault(e) {
        !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0)
    }
}
jt.touchstart = t => {
    t.input.lastTouch = Date.now(),
    O1(t),
    bi(t, "pointer")
}
;
jt.touchmove = t => {
    t.input.lastTouch = Date.now(),
    bi(t, "pointer")
}
;
jt.contextmenu = t => O1(t);
function Ix(t, e) {
    return t.composing ? !0 : Dt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8,
    !0) : !1
}
const MT = Mr ? 5e3 : -1;
Ht.compositionstart = Ht.compositionupdate = t => {
    if (!t.composing) {
        t.domObserver.flush();
        let {state: e} = t
          , n = e.selection.$to;
        if (e.selection instanceof se && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(r => r.type.spec.inclusive === !1) || At && gx && AT(t)))
            t.markCursor = t.state.storedMarks || n.marks(),
            _u(t, !0),
            t.markCursor = null;
        else if (_u(t, !e.selection.empty),
        An && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
            let r = t.domSelectionRange();
            for (let o = r.focusNode, l = r.focusOffset; o && o.nodeType == 1 && l != 0; ) {
                let a = l < 0 ? o.lastChild : o.childNodes[l - 1];
                if (!a)
                    break;
                if (a.nodeType == 3) {
                    let u = t.domSelection();
                    u && u.collapse(a, a.nodeValue.length);
                    break
                } else
                    o = a,
                    l = -1
            }
        }
        t.input.composing = !0
    }
    Vx(t, MT)
}
;
function AT(t) {
    let {focusNode: e, focusOffset: n} = t.domSelectionRange();
    if (!e || e.nodeType != 1 || n >= e.childNodes.length)
        return !1;
    let r = e.childNodes[n];
    return r.nodeType == 1 && r.contentEditable == "false"
}
Ht.compositionend = (t, e) => {
    t.composing && (t.input.composing = !1,
    t.input.compositionEndedAt = e.timeStamp,
    t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0,
    t.input.compositionNode = null,
    t.input.badSafariComposition ? t.domObserver.forceFlush() : t.input.compositionPendingChanges && Promise.resolve().then( () => t.domObserver.flush()),
    t.input.compositionID++,
    Vx(t, 20))
}
;
function Vx(t, e) {
    clearTimeout(t.input.composingTimeout),
    e > -1 && (t.input.composingTimeout = setTimeout( () => _u(t), e))
}
function Ux(t) {
    for (t.composing && (t.input.composing = !1,
    t.input.compositionEndedAt = RT()); t.input.compositionNodes.length > 0; )
        t.input.compositionNodes.pop().markParentsDirty()
}
function NT(t) {
    let e = t.domSelectionRange();
    if (!e.focusNode)
        return null;
    let n = S6(e.focusNode, e.focusOffset)
      , r = x6(e.focusNode, e.focusOffset);
    if (n && r && n != r) {
        let o = r.pmViewDesc
          , l = t.domObserver.lastChangedTextNode;
        if (n == l || r == l)
            return l;
        if (!o || !o.isText(r.nodeValue))
            return r;
        if (t.input.compositionNode == r) {
            let a = n.pmViewDesc;
            if (!(!a || !a.isText(n.nodeValue)))
                return r
        }
    }
    return n || r
}
function RT() {
    let t = document.createEvent("Event");
    return t.initEvent("event", !0, !0),
    t.timeStamp
}
function _u(t, e=!1) {
    if (!(Mr && t.domObserver.flushingSoon >= 0)) {
        if (t.domObserver.forceFlush(),
        Ux(t),
        e || t.docView && t.docView.dirty) {
            let n = k1(t)
              , r = t.state.selection;
            return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state),
            !0
        }
        return !1
    }
}
function OT(t, e) {
    if (!t.dom.parentNode)
        return;
    let n = t.dom.parentNode.appendChild(document.createElement("div"));
    n.appendChild(e),
    n.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let r = getSelection()
      , o = document.createRange();
    o.selectNodeContents(e),
    t.dom.blur(),
    r.removeAllRanges(),
    r.addRange(o),
    setTimeout( () => {
        n.parentNode && n.parentNode.removeChild(n),
        t.focus()
    }
    , 50)
}
const da = Wt && xi < 15 || zl && k6 < 604;
jt.copy = Ht.cut = (t, e) => {
    let n = e
      , r = t.state.selection
      , o = n.type == "cut";
    if (r.empty)
        return;
    let l = da ? null : n.clipboardData
      , a = r.content()
      , {dom: u, text: f} = A1(t, a);
    l ? (n.preventDefault(),
    l.clearData(),
    l.setData("text/html", u.innerHTML),
    l.setData("text/plain", f)) : OT(t, u),
    o && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"))
}
;
function DT(t) {
    return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null
}
function LT(t, e) {
    if (!t.dom.parentNode)
        return;
    let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code
      , r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
    n || (r.contentEditable = "true"),
    r.style.cssText = "position: fixed; left: -10000px; top: 10px",
    r.focus();
    let o = t.input.shiftKey && t.input.lastKeyCode != 45;
    setTimeout( () => {
        t.focus(),
        r.parentNode && r.parentNode.removeChild(r),
        n ? ha(t, r.value, null, o, e) : ha(t, r.textContent, r.innerHTML, o, e)
    }
    , 50)
}
function ha(t, e, n, r, o) {
    let l = Dx(t, e, n, r, t.state.selection.$from);
    if (t.someProp("handlePaste", f => f(t, o, l || te.empty)))
        return !0;
    if (!l)
        return !1;
    let a = DT(l)
      , u = a ? t.state.tr.replaceSelectionWith(a, r) : t.state.tr.replaceSelection(l);
    return t.dispatch(u.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")),
    !0
}
function Px(t) {
    let e = t.getData("text/plain") || t.getData("Text");
    if (e)
        return e;
    let n = t.getData("text/uri-list");
    return n ? n.replace(/\r?\n/g, " ") : ""
}
Ht.paste = (t, e) => {
    let n = e;
    if (t.composing && !Mr)
        return;
    let r = da ? null : n.clipboardData
      , o = t.input.shiftKey && t.input.lastKeyCode != 45;
    r && ha(t, Px(r), r.getData("text/html"), o, n) ? n.preventDefault() : LT(t, n)
}
;
class qx {
    constructor(e, n, r) {
        this.slice = e,
        this.move = n,
        this.node = r
    }
}
const zT = kn ? "altKey" : "ctrlKey";
function $x(t, e) {
    let n = t.someProp("dragCopies", r => !r(e));
    return n ?? !e[zT]
}
jt.dragstart = (t, e) => {
    let n = e
      , r = t.input.mouseDown;
    if (r && r.done(),
    !n.dataTransfer)
        return;
    let o = t.state.selection, l = o.empty ? null : t.posAtCoords(zf(n)), a;
    if (!(l && l.pos >= o.from && l.pos <= (o instanceof le ? o.to - 1 : o.to))) {
        if (r && r.mightDrag)
            a = le.create(t.state.doc, r.mightDrag.pos);
        else if (n.target && n.target.nodeType == 1) {
            let m = t.docView.nearestDesc(n.target, !0);
            m && m.node.type.spec.draggable && m != t.docView && (a = le.create(t.state.doc, m.posBefore))
        }
    }
    let u = (a || t.state.selection).content()
      , {dom: f, text: h, slice: p} = A1(t, u);
    (!n.dataTransfer.files.length || !At || mx > 120) && n.dataTransfer.clearData(),
    n.dataTransfer.setData(da ? "Text" : "text/html", f.innerHTML),
    n.dataTransfer.effectAllowed = "copyMove",
    da || n.dataTransfer.setData("text/plain", h),
    t.dragging = new qx(p,$x(t, n),a)
}
;
jt.dragend = t => {
    let e = t.dragging;
    window.setTimeout( () => {
        t.dragging == e && (t.dragging = null)
    }
    , 50)
}
;
Ht.dragover = Ht.dragenter = (t, e) => e.preventDefault();
Ht.drop = (t, e) => {
    try {
        _T(t, e, t.dragging)
    } finally {
        t.dragging = null
    }
}
;
function _T(t, e, n) {
    if (!e.dataTransfer)
        return;
    let r = t.posAtCoords(zf(e));
    if (!r)
        return;
    let o = t.state.doc.resolve(r.pos)
      , l = n && n.slice;
    l ? t.someProp("transformPasted", b => {
        l = b(l, t, !1)
    }
    ) : l = Dx(t, Px(e.dataTransfer), da ? null : e.dataTransfer.getData("text/html"), !1, o);
    let a = !!(n && $x(t, e));
    if (t.someProp("handleDrop", b => b(t, e, l || te.empty, a))) {
        e.preventDefault();
        return
    }
    if (!l)
        return;
    e.preventDefault();
    let u = l ? YS(t.state.doc, o.pos, l) : o.pos;
    u == null && (u = o.pos);
    let f = t.state.tr;
    if (a) {
        let {node: b} = n;
        b ? b.replace(f) : f.deleteSelection()
    }
    let h = f.mapping.map(u)
      , p = l.openStart == 0 && l.openEnd == 0 && l.content.childCount == 1
      , m = f.doc;
    if (p ? f.replaceRangeWith(h, h, l.content.firstChild) : f.replaceRange(h, h, l),
    f.doc.eq(m))
        return;
    let y = f.doc.resolve(h);
    if (p && le.isSelectable(l.content.firstChild) && y.nodeAfter && y.nodeAfter.sameMarkup(l.content.firstChild))
        f.setSelection(new le(y));
    else {
        let b = f.mapping.map(u);
        f.mapping.maps[f.mapping.maps.length - 1].forEach( (C, S, w, k) => b = k),
        f.setSelection(M1(t, y, f.doc.resolve(b)))
    }
    t.focus(),
    t.dispatch(f.setMeta("uiEvent", "drop"))
}
jt.focus = t => {
    t.input.lastFocus = Date.now(),
    t.focused || (t.domObserver.stop(),
    t.dom.classList.add("ProseMirror-focused"),
    t.domObserver.start(),
    t.focused = !0,
    setTimeout( () => {
        t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Nr(t)
    }
    , 20))
}
;
jt.blur = (t, e) => {
    let n = e;
    t.focused && (t.domObserver.stop(),
    t.dom.classList.remove("ProseMirror-focused"),
    t.domObserver.start(),
    n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(),
    t.focused = !1)
}
;
jt.beforeinput = (t, e) => {
    if (At && Mr && e.inputType == "deleteContentBackward") {
        t.domObserver.flushSoon();
        let {domChangeCount: r} = t.input;
        setTimeout( () => {
            if (t.input.domChangeCount != r || (t.dom.blur(),
            t.focus(),
            t.someProp("handleKeyDown", l => l(t, so(8, "Backspace")))))
                return;
            let {$cursor: o} = t.state.selection;
            o && o.pos > 0 && t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView())
        }
        , 50)
    }
}
;
for (let t in Ht)
    jt[t] = Ht[t];
function pa(t, e) {
    if (t == e)
        return !0;
    for (let n in t)
        if (t[n] !== e[n])
            return !1;
    for (let n in e)
        if (!(n in t))
            return !1;
    return !0
}
class Bu {
    constructor(e, n) {
        this.toDOM = e,
        this.spec = n || mo,
        this.side = this.spec.side || 0
    }
    map(e, n, r, o) {
        let {pos: l, deleted: a} = e.mapResult(n.from + o, this.side < 0 ? -1 : 1);
        return a ? null : new yt(l - r,l - r,this)
    }
    valid() {
        return !0
    }
    eq(e) {
        return this == e || e instanceof Bu && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && pa(this.spec, e.spec))
    }
    destroy(e) {
        this.spec.destroy && this.spec.destroy(e)
    }
}
class Ei {
    constructor(e, n) {
        this.attrs = e,
        this.spec = n || mo
    }
    map(e, n, r, o) {
        let l = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r
          , a = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
        return l >= a ? null : new yt(l,a,this)
    }
    valid(e, n) {
        return n.from < n.to
    }
    eq(e) {
        return this == e || e instanceof Ei && pa(this.attrs, e.attrs) && pa(this.spec, e.spec)
    }
    static is(e) {
        return e.type instanceof Ei
    }
    destroy() {}
}
class D1 {
    constructor(e, n) {
        this.attrs = e,
        this.spec = n || mo
    }
    map(e, n, r, o) {
        let l = e.mapResult(n.from + o, 1);
        if (l.deleted)
            return null;
        let a = e.mapResult(n.to + o, -1);
        return a.deleted || a.pos <= l.pos ? null : new yt(l.pos - r,a.pos - r,this)
    }
    valid(e, n) {
        let {index: r, offset: o} = e.content.findIndex(n.from), l;
        return o == n.from && !(l = e.child(r)).isText && o + l.nodeSize == n.to
    }
    eq(e) {
        return this == e || e instanceof D1 && pa(this.attrs, e.attrs) && pa(this.spec, e.spec)
    }
    destroy() {}
}
class yt {
    constructor(e, n, r) {
        this.from = e,
        this.to = n,
        this.type = r
    }
    copy(e, n) {
        return new yt(e,n,this.type)
    }
    eq(e, n=0) {
        return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to
    }
    map(e, n, r) {
        return this.type.map(e, this, n, r)
    }
    static widget(e, n, r) {
        return new yt(e,e,new Bu(n,r))
    }
    static inline(e, n, r, o) {
        return new yt(e,n,new Ei(r,o))
    }
    static node(e, n, r, o) {
        return new yt(e,n,new D1(r,o))
    }
    get spec() {
        return this.type.spec
    }
    get inline() {
        return this.type instanceof Ei
    }
    get widget() {
        return this.type instanceof Bu
    }
}
const xl = []
  , mo = {};
class Ue {
    constructor(e, n) {
        this.local = e.length ? e : xl,
        this.children = n.length ? n : xl
    }
    static create(e, n) {
        return n.length ? ju(n, e, 0, mo) : Ot
    }
    find(e, n, r) {
        let o = [];
        return this.findInner(e ?? 0, n ?? 1e9, o, 0, r),
        o
    }
    findInner(e, n, r, o, l) {
        for (let a = 0; a < this.local.length; a++) {
            let u = this.local[a];
            u.from <= n && u.to >= e && (!l || l(u.spec)) && r.push(u.copy(u.from + o, u.to + o))
        }
        for (let a = 0; a < this.children.length; a += 3)
            if (this.children[a] < n && this.children[a + 1] > e) {
                let u = this.children[a] + 1;
                this.children[a + 2].findInner(e - u, n - u, r, o + u, l)
            }
    }
    map(e, n, r) {
        return this == Ot || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || mo)
    }
    mapInner(e, n, r, o, l) {
        let a;
        for (let u = 0; u < this.local.length; u++) {
            let f = this.local[u].map(e, r, o);
            f && f.type.valid(n, f) ? (a || (a = [])).push(f) : l.onRemove && l.onRemove(this.local[u].spec)
        }
        return this.children.length ? BT(this.children, a || [], e, n, r, o, l) : a ? new Ue(a.sort(go),xl) : Ot
    }
    add(e, n) {
        return n.length ? this == Ot ? Ue.create(e, n) : this.addInner(e, n, 0) : this
    }
    addInner(e, n, r) {
        let o, l = 0;
        e.forEach( (u, f) => {
            let h = f + r, p;
            if (p = Kx(n, u, h)) {
                for (o || (o = this.children.slice()); l < o.length && o[l] < f; )
                    l += 3;
                o[l] == f ? o[l + 2] = o[l + 2].addInner(u, p, h + 1) : o.splice(l, 0, f, f + u.nodeSize, ju(p, u, h + 1, mo)),
                l += 3
            }
        }
        );
        let a = Fx(l ? Gx(n) : n, -r);
        for (let u = 0; u < a.length; u++)
            a[u].type.valid(e, a[u]) || a.splice(u--, 1);
        return new Ue(a.length ? this.local.concat(a).sort(go) : this.local,o || this.children)
    }
    remove(e) {
        return e.length == 0 || this == Ot ? this : this.removeInner(e, 0)
    }
    removeInner(e, n) {
        let r = this.children
          , o = this.local;
        for (let l = 0; l < r.length; l += 3) {
            let a, u = r[l] + n, f = r[l + 1] + n;
            for (let p = 0, m; p < e.length; p++)
                (m = e[p]) && m.from > u && m.to < f && (e[p] = null,
                (a || (a = [])).push(m));
            if (!a)
                continue;
            r == this.children && (r = this.children.slice());
            let h = r[l + 2].removeInner(a, u + 1);
            h != Ot ? r[l + 2] = h : (r.splice(l, 3),
            l -= 3)
        }
        if (o.length) {
            for (let l = 0, a; l < e.length; l++)
                if (a = e[l])
                    for (let u = 0; u < o.length; u++)
                        o[u].eq(a, n) && (o == this.local && (o = this.local.slice()),
                        o.splice(u--, 1))
        }
        return r == this.children && o == this.local ? this : o.length || r.length ? new Ue(o,r) : Ot
    }
    forChild(e, n) {
        if (this == Ot)
            return this;
        if (n.isLeaf)
            return Ue.empty;
        let r, o;
        for (let u = 0; u < this.children.length; u += 3)
            if (this.children[u] >= e) {
                this.children[u] == e && (r = this.children[u + 2]);
                break
            }
        let l = e + 1
          , a = l + n.content.size;
        for (let u = 0; u < this.local.length; u++) {
            let f = this.local[u];
            if (f.from < a && f.to > l && f.type instanceof Ei) {
                let h = Math.max(l, f.from) - l
                  , p = Math.min(a, f.to) - l;
                h < p && (o || (o = [])).push(f.copy(h, p))
            }
        }
        if (o) {
            let u = new Ue(o.sort(go),xl);
            return r ? new pi([u, r]) : u
        }
        return r || Ot
    }
    eq(e) {
        if (this == e)
            return !0;
        if (!(e instanceof Ue) || this.local.length != e.local.length || this.children.length != e.children.length)
            return !1;
        for (let n = 0; n < this.local.length; n++)
            if (!this.local[n].eq(e.local[n]))
                return !1;
        for (let n = 0; n < this.children.length; n += 3)
            if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
                return !1;
        return !0
    }
    locals(e) {
        return L1(this.localsInner(e))
    }
    localsInner(e) {
        if (this == Ot)
            return xl;
        if (e.inlineContent || !this.local.some(Ei.is))
            return this.local;
        let n = [];
        for (let r = 0; r < this.local.length; r++)
            this.local[r].type instanceof Ei || n.push(this.local[r]);
        return n
    }
    forEachSet(e) {
        e(this)
    }
}
Ue.empty = new Ue([],[]);
Ue.removeOverlap = L1;
const Ot = Ue.empty;
class pi {
    constructor(e) {
        this.members = e
    }
    map(e, n) {
        const r = this.members.map(o => o.map(e, n, mo));
        return pi.from(r)
    }
    forChild(e, n) {
        if (n.isLeaf)
            return Ue.empty;
        let r = [];
        for (let o = 0; o < this.members.length; o++) {
            let l = this.members[o].forChild(e, n);
            l != Ot && (l instanceof pi ? r = r.concat(l.members) : r.push(l))
        }
        return pi.from(r)
    }
    eq(e) {
        if (!(e instanceof pi) || e.members.length != this.members.length)
            return !1;
        for (let n = 0; n < this.members.length; n++)
            if (!this.members[n].eq(e.members[n]))
                return !1;
        return !0
    }
    locals(e) {
        let n, r = !0;
        for (let o = 0; o < this.members.length; o++) {
            let l = this.members[o].localsInner(e);
            if (l.length)
                if (!n)
                    n = l;
                else {
                    r && (n = n.slice(),
                    r = !1);
                    for (let a = 0; a < l.length; a++)
                        n.push(l[a])
                }
        }
        return n ? L1(r ? n : n.sort(go)) : xl
    }
    static from(e) {
        switch (e.length) {
        case 0:
            return Ot;
        case 1:
            return e[0];
        default:
            return new pi(e.every(n => n instanceof Ue) ? e : e.reduce( (n, r) => n.concat(r instanceof Ue ? r : r.members), []))
        }
    }
    forEachSet(e) {
        for (let n = 0; n < this.members.length; n++)
            this.members[n].forEachSet(e)
    }
}
function BT(t, e, n, r, o, l, a) {
    let u = t.slice();
    for (let h = 0, p = l; h < n.maps.length; h++) {
        let m = 0;
        n.maps[h].forEach( (y, b, C, S) => {
            let w = S - C - (b - y);
            for (let k = 0; k < u.length; k += 3) {
                let A = u[k + 1];
                if (A < 0 || y > A + p - m)
                    continue;
                let O = u[k] + p - m;
                b >= O ? u[k + 1] = y <= O ? -2 : -1 : y >= p && w && (u[k] += w,
                u[k + 1] += w)
            }
            m += w
        }
        ),
        p = n.maps[h].map(p, -1)
    }
    let f = !1;
    for (let h = 0; h < u.length; h += 3)
        if (u[h + 1] < 0) {
            if (u[h + 1] == -2) {
                f = !0,
                u[h + 1] = -1;
                continue
            }
            let p = n.map(t[h] + l)
              , m = p - o;
            if (m < 0 || m >= r.content.size) {
                f = !0;
                continue
            }
            let y = n.map(t[h + 1] + l, -1)
              , b = y - o
              , {index: C, offset: S} = r.content.findIndex(m)
              , w = r.maybeChild(C);
            if (w && S == m && S + w.nodeSize == b) {
                let k = u[h + 2].mapInner(n, w, p + 1, t[h] + l + 1, a);
                k != Ot ? (u[h] = m,
                u[h + 1] = b,
                u[h + 2] = k) : (u[h + 1] = -2,
                f = !0)
            } else
                f = !0
        }
    if (f) {
        let h = jT(u, t, e, n, o, l, a)
          , p = ju(h, r, 0, a);
        e = p.local;
        for (let m = 0; m < u.length; m += 3)
            u[m + 1] < 0 && (u.splice(m, 3),
            m -= 3);
        for (let m = 0, y = 0; m < p.children.length; m += 3) {
            let b = p.children[m];
            for (; y < u.length && u[y] < b; )
                y += 3;
            u.splice(y, 0, p.children[m], p.children[m + 1], p.children[m + 2])
        }
    }
    return new Ue(e.sort(go),u)
}
function Fx(t, e) {
    if (!e || !t.length)
        return t;
    let n = [];
    for (let r = 0; r < t.length; r++) {
        let o = t[r];
        n.push(new yt(o.from + e,o.to + e,o.type))
    }
    return n
}
function jT(t, e, n, r, o, l, a) {
    function u(f, h) {
        for (let p = 0; p < f.local.length; p++) {
            let m = f.local[p].map(r, o, h);
            m ? n.push(m) : a.onRemove && a.onRemove(f.local[p].spec)
        }
        for (let p = 0; p < f.children.length; p += 3)
            u(f.children[p + 2], f.children[p] + h + 1)
    }
    for (let f = 0; f < t.length; f += 3)
        t[f + 1] == -1 && u(t[f + 2], e[f] + l + 1);
    return n
}
function Kx(t, e, n) {
    if (e.isLeaf)
        return null;
    let r = n + e.nodeSize
      , o = null;
    for (let l = 0, a; l < t.length; l++)
        (a = t[l]) && a.from > n && a.to < r && ((o || (o = [])).push(a),
        t[l] = null);
    return o
}
function Gx(t) {
    let e = [];
    for (let n = 0; n < t.length; n++)
        t[n] != null && e.push(t[n]);
    return e
}
function ju(t, e, n, r) {
    let o = []
      , l = !1;
    e.forEach( (u, f) => {
        let h = Kx(t, u, f + n);
        if (h) {
            l = !0;
            let p = ju(h, u, n + f + 1, r);
            p != Ot && o.push(f, f + u.nodeSize, p)
        }
    }
    );
    let a = Fx(l ? Gx(t) : t, -n).sort(go);
    for (let u = 0; u < a.length; u++)
        a[u].type.valid(e, a[u]) || (r.onRemove && r.onRemove(a[u].spec),
        a.splice(u--, 1));
    return a.length || o.length ? new Ue(a,o) : Ot
}
function go(t, e) {
    return t.from - e.from || t.to - e.to
}
function L1(t) {
    let e = t;
    for (let n = 0; n < e.length - 1; n++) {
        let r = e[n];
        if (r.from != r.to)
            for (let o = n + 1; o < e.length; o++) {
                let l = e[o];
                if (l.from == r.from) {
                    l.to != r.to && (e == t && (e = t.slice()),
                    e[o] = l.copy(l.from, r.to),
                    kb(e, o + 1, l.copy(r.to, l.to)));
                    continue
                } else {
                    l.from < r.to && (e == t && (e = t.slice()),
                    e[n] = r.copy(r.from, l.from),
                    kb(e, o, r.copy(l.from, r.to)));
                    break
                }
            }
    }
    return e
}
function kb(t, e, n) {
    for (; e < t.length && go(n, t[e]) > 0; )
        e++;
    t.splice(e, 0, n)
}
function _p(t) {
    let e = [];
    return t.someProp("decorations", n => {
        let r = n(t.state);
        r && r != Ot && e.push(r)
    }
    ),
    t.cursorWrapper && e.push(Ue.create(t.state.doc, [t.cursorWrapper.deco])),
    pi.from(e)
}
const HT = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
}
  , IT = Wt && xi <= 11;
class VT {
    constructor() {
        this.anchorNode = null,
        this.anchorOffset = 0,
        this.focusNode = null,
        this.focusOffset = 0
    }
    set(e) {
        this.anchorNode = e.anchorNode,
        this.anchorOffset = e.anchorOffset,
        this.focusNode = e.focusNode,
        this.focusOffset = e.focusOffset
    }
    clear() {
        this.anchorNode = this.focusNode = null
    }
    eq(e) {
        return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset
    }
}
class UT {
    constructor(e, n) {
        this.view = e,
        this.handleDOMChange = n,
        this.queue = [],
        this.flushingSoon = -1,
        this.observer = null,
        this.currentSelection = new VT,
        this.onCharData = null,
        this.suppressingSelectionUpdates = !1,
        this.lastChangedTextNode = null,
        this.observer = window.MutationObserver && new window.MutationObserver(r => {
            for (let o = 0; o < r.length; o++)
                this.queue.push(r[o]);
            Wt && xi <= 11 && r.some(o => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : Dt && e.composing && r.some(o => o.type == "childList" && o.target.nodeName == "TR") ? (e.input.badSafariComposition = !0,
            this.flushSoon()) : this.flush()
        }
        ),
        IT && (this.onCharData = r => {
            this.queue.push({
                target: r.target,
                type: "characterData",
                oldValue: r.prevValue
            }),
            this.flushSoon()
        }
        ),
        this.onSelectionChange = this.onSelectionChange.bind(this)
    }
    flushSoon() {
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout( () => {
            this.flushingSoon = -1,
            this.flush()
        }
        , 20))
    }
    forceFlush() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon),
        this.flushingSoon = -1,
        this.flush())
    }
    start() {
        this.observer && (this.observer.takeRecords(),
        this.observer.observe(this.view.dom, HT)),
        this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData),
        this.connectSelection()
    }
    stop() {
        if (this.observer) {
            let e = this.observer.takeRecords();
            if (e.length) {
                for (let n = 0; n < e.length; n++)
                    this.queue.push(e[n]);
                window.setTimeout( () => this.flush(), 20)
            }
            this.observer.disconnect()
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData),
        this.disconnectSelection()
    }
    connectSelection() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange)
    }
    disconnectSelection() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange)
    }
    suppressSelectionUpdates() {
        this.suppressingSelectionUpdates = !0,
        setTimeout( () => this.suppressingSelectionUpdates = !1, 50)
    }
    onSelectionChange() {
        if (vb(this.view)) {
            if (this.suppressingSelectionUpdates)
                return Nr(this.view);
            if (Wt && xi <= 11 && !this.view.state.selection.empty) {
                let e = this.view.domSelectionRange();
                if (e.focusNode && Co(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
                    return this.flushSoon()
            }
            this.flush()
        }
    }
    setCurSelection() {
        this.currentSelection.set(this.view.domSelectionRange())
    }
    ignoreSelectionChange(e) {
        if (!e.focusNode)
            return !0;
        let n = new Set, r;
        for (let l = e.focusNode; l; l = Ll(l))
            n.add(l);
        for (let l = e.anchorNode; l; l = Ll(l))
            if (n.has(l)) {
                r = l;
                break
            }
        let o = r && this.view.docView.nearestDesc(r);
        if (o && o.ignoreMutation({
            type: "selection",
            target: r.nodeType == 3 ? r.parentNode : r
        }))
            return this.setCurSelection(),
            !0
    }
    pendingRecords() {
        if (this.observer)
            for (let e of this.observer.takeRecords())
                this.queue.push(e);
        return this.queue
    }
    flush() {
        let {view: e} = this;
        if (!e.docView || this.flushingSoon > -1)
            return;
        let n = this.pendingRecords();
        n.length && (this.queue = []);
        let r = e.domSelectionRange()
          , o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && vb(e) && !this.ignoreSelectionChange(r)
          , l = -1
          , a = -1
          , u = !1
          , f = [];
        if (e.editable)
            for (let p = 0; p < n.length; p++) {
                let m = this.registerMutation(n[p], f);
                m && (l = l < 0 ? m.from : Math.min(m.from, l),
                a = a < 0 ? m.to : Math.max(m.to, a),
                m.typeOver && (u = !0))
            }
        if (f.some(p => p.nodeName == "BR") && (e.input.lastKeyCode == 8 || e.input.lastKeyCode == 46)) {
            for (let p of f)
                if (p.nodeName == "BR" && p.parentNode) {
                    let m = p.nextSibling;
                    m && m.nodeType == 1 && m.contentEditable == "false" && p.parentNode.removeChild(p)
                }
        } else if (An && f.length) {
            let p = f.filter(m => m.nodeName == "BR");
            if (p.length == 2) {
                let[m,y] = p;
                m.parentNode && m.parentNode.parentNode == y.parentNode ? y.remove() : m.remove()
            } else {
                let {focusNode: m} = this.currentSelection;
                for (let y of p) {
                    let b = y.parentNode;
                    b && b.nodeName == "LI" && (!m || $T(e, m) != b) && y.remove()
                }
            }
        }
        let h = null;
        l < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Df(r) && (h = k1(e)) && h.eq(ye.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0,
        Nr(e),
        this.currentSelection.set(r),
        e.scrollToSelection()) : (l > -1 || o) && (l > -1 && (e.docView.markDirty(l, a),
        PT(e)),
        e.input.badSafariComposition && (e.input.badSafariComposition = !1,
        FT(e, f)),
        this.handleDOMChange(l, a, u, f),
        e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Nr(e),
        this.currentSelection.set(r))
    }
    registerMutation(e, n) {
        if (n.indexOf(e.target) > -1)
            return null;
        let r = this.view.docView.nearestDesc(e.target);
        if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
            return null;
        if (e.type == "childList") {
            for (let p = 0; p < e.addedNodes.length; p++) {
                let m = e.addedNodes[p];
                n.push(m),
                m.nodeType == 3 && (this.lastChangedTextNode = m)
            }
            if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
                return {
                    from: r.posBefore,
                    to: r.posAfter
                };
            let o = e.previousSibling
              , l = e.nextSibling;
            if (Wt && xi <= 11 && e.addedNodes.length)
                for (let p = 0; p < e.addedNodes.length; p++) {
                    let {previousSibling: m, nextSibling: y} = e.addedNodes[p];
                    (!m || Array.prototype.indexOf.call(e.addedNodes, m) < 0) && (o = m),
                    (!y || Array.prototype.indexOf.call(e.addedNodes, y) < 0) && (l = y)
                }
            let a = o && o.parentNode == e.target ? kt(o) + 1 : 0
              , u = r.localPosFromDOM(e.target, a, -1)
              , f = l && l.parentNode == e.target ? kt(l) : e.target.childNodes.length
              , h = r.localPosFromDOM(e.target, f, 1);
            return {
                from: u,
                to: h
            }
        } else
            return e.type == "attributes" ? {
                from: r.posAtStart - r.border,
                to: r.posAtEnd + r.border
            } : (this.lastChangedTextNode = e.target,
            {
                from: r.posAtStart,
                to: r.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue
            })
    }
}
let Mb = new WeakMap
  , Ab = !1;
function PT(t) {
    if (!Mb.has(t) && (Mb.set(t, null),
    ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
        if (t.requiresGeckoHackNode = An,
        Ab)
            return;
        console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."),
        Ab = !0
    }
}
function Nb(t, e) {
    let n = e.startContainer
      , r = e.startOffset
      , o = e.endContainer
      , l = e.endOffset
      , a = t.domAtPos(t.state.selection.anchor);
    return Co(a.node, a.offset, o, l) && ([n,r,o,l] = [o, l, n, r]),
    {
        anchorNode: n,
        anchorOffset: r,
        focusNode: o,
        focusOffset: l
    }
}
function qT(t, e) {
    if (e.getComposedRanges) {
        let o = e.getComposedRanges(t.root)[0];
        if (o)
            return Nb(t, o)
    }
    let n;
    function r(o) {
        o.preventDefault(),
        o.stopImmediatePropagation(),
        n = o.getTargetRanges()[0]
    }
    return t.dom.addEventListener("beforeinput", r, !0),
    document.execCommand("indent"),
    t.dom.removeEventListener("beforeinput", r, !0),
    n ? Nb(t, n) : null
}
function $T(t, e) {
    for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
        let r = t.docView.nearestDesc(n, !0);
        if (r && r.node.isBlock)
            return n
    }
    return null
}
function FT(t, e) {
    var n;
    let {focusNode: r, focusOffset: o} = t.domSelectionRange();
    for (let l of e)
        if (((n = l.parentNode) === null || n === void 0 ? void 0 : n.nodeName) == "TR") {
            let a = l.nextSibling;
            for (; a && a.nodeName != "TD" && a.nodeName != "TH"; )
                a = a.nextSibling;
            if (a) {
                let u = a;
                for (; ; ) {
                    let f = u.firstChild;
                    if (!f || f.nodeType != 1 || f.contentEditable == "false" || /^(BR|IMG)$/.test(f.nodeName))
                        break;
                    u = f
                }
                u.insertBefore(l, u.firstChild),
                r == l && t.domSelection().collapse(l, o)
            } else
                l.parentNode.removeChild(l)
        }
}
function KT(t, e, n) {
    let {node: r, fromOffset: o, toOffset: l, from: a, to: u} = t.docView.parseRange(e, n), f = t.domSelectionRange(), h, p = f.anchorNode;
    if (p && t.dom.contains(p.nodeType == 1 ? p : p.parentNode) && (h = [{
        node: p,
        offset: f.anchorOffset
    }],
    Df(f) || h.push({
        node: f.focusNode,
        offset: f.focusOffset
    })),
    At && t.input.lastKeyCode === 8)
        for (let w = l; w > o; w--) {
            let k = r.childNodes[w - 1]
              , A = k.pmViewDesc;
            if (k.nodeName == "BR" && !A) {
                l = w;
                break
            }
            if (!A || A.size)
                break
        }
    let m = t.state.doc
      , y = t.someProp("domParser") || Si.fromSchema(t.state.schema)
      , b = m.resolve(a)
      , C = null
      , S = y.parse(r, {
        topNode: b.parent,
        topMatch: b.parent.contentMatchAt(b.index()),
        topOpen: !0,
        from: o,
        to: l,
        preserveWhitespace: b.parent.type.whitespace == "pre" ? "full" : !0,
        findPositions: h,
        ruleFromNode: GT,
        context: b
    });
    if (h && h[0].pos != null) {
        let w = h[0].pos
          , k = h[1] && h[1].pos;
        k == null && (k = w),
        C = {
            anchor: w + a,
            head: k + a
        }
    }
    return {
        doc: S,
        sel: C,
        from: a,
        to: u
    }
}
function GT(t) {
    let e = t.pmViewDesc;
    if (e)
        return e.parseRule();
    if (t.nodeName == "BR" && t.parentNode) {
        if (Dt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
            let n = document.createElement("div");
            return n.appendChild(document.createElement("li")),
            {
                skip: n
            }
        } else if (t.parentNode.lastChild == t || Dt && /^(tr|table)$/i.test(t.parentNode.nodeName))
            return {
                ignore: !0
            }
    } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
        return {
            ignore: !0
        };
    return null
}
const YT = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function ZT(t, e, n, r, o) {
    let l = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
    if (t.input.compositionPendingChanges = 0,
    e < 0) {
        let _ = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null
          , W = k1(t, _);
        if (W && !t.state.selection.eq(W)) {
            if (At && Mr && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", de => de(t, so(13, "Enter"))))
                return;
            let ne = t.state.tr.setSelection(W);
            _ == "pointer" ? ne.setMeta("pointer", !0) : _ == "key" && ne.scrollIntoView(),
            l && ne.setMeta("composition", l),
            t.dispatch(ne)
        }
        return
    }
    let a = t.state.doc.resolve(e)
      , u = a.sharedDepth(n);
    e = a.before(u + 1),
    n = t.state.doc.resolve(n).after(u + 1);
    let f = t.state.selection, h = KT(t, e, n), p = t.state.doc, m = p.slice(h.from, h.to), y, b;
    t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (y = t.state.selection.to,
    b = "end") : (y = t.state.selection.from,
    b = "start"),
    t.input.lastKeyCode = null;
    let C = JT(m.content, h.doc.content, h.from, y, b);
    if (C && t.input.domChangeCount++,
    (zl && t.input.lastIOSEnter > Date.now() - 225 || Mr) && o.some(_ => _.nodeType == 1 && !YT.test(_.nodeName)) && (!C || C.endA >= C.endB) && t.someProp("handleKeyDown", _ => _(t, so(13, "Enter")))) {
        t.input.lastIOSEnter = 0;
        return
    }
    if (!C)
        if (r && f instanceof se && !f.empty && f.$head.sameParent(f.$anchor) && !t.composing && !(h.sel && h.sel.anchor != h.sel.head))
            C = {
                start: f.from,
                endA: f.to,
                endB: f.to
            };
        else {
            if (h.sel) {
                let _ = Rb(t, t.state.doc, h.sel);
                if (_ && !_.eq(t.state.selection)) {
                    let W = t.state.tr.setSelection(_);
                    l && W.setMeta("composition", l),
                    t.dispatch(W)
                }
            }
            return
        }
    t.state.selection.from < t.state.selection.to && C.start == C.endB && t.state.selection instanceof se && (C.start > t.state.selection.from && C.start <= t.state.selection.from + 2 && t.state.selection.from >= h.from ? C.start = t.state.selection.from : C.endA < t.state.selection.to && C.endA >= t.state.selection.to - 2 && t.state.selection.to <= h.to && (C.endB += t.state.selection.to - C.endA,
    C.endA = t.state.selection.to)),
    Wt && xi <= 11 && C.endB == C.start + 1 && C.endA == C.start && C.start > h.from && h.doc.textBetween(C.start - h.from - 1, C.start - h.from + 1) == " " && (C.start--,
    C.endA--,
    C.endB--);
    let S = h.doc.resolveNoCache(C.start - h.from)
      , w = h.doc.resolveNoCache(C.endB - h.from)
      , k = p.resolve(C.start)
      , A = S.sameParent(w) && S.parent.inlineContent && k.end() >= C.endA;
    if ((zl && t.input.lastIOSEnter > Date.now() - 225 && (!A || o.some(_ => _.nodeName == "DIV" || _.nodeName == "P")) || !A && S.pos < h.doc.content.size && (!S.sameParent(w) || !S.parent.inlineContent) && S.pos < w.pos && !/\S/.test(h.doc.textBetween(S.pos, w.pos, "", ""))) && t.someProp("handleKeyDown", _ => _(t, so(13, "Enter")))) {
        t.input.lastIOSEnter = 0;
        return
    }
    if (t.state.selection.anchor > C.start && XT(p, C.start, C.endA, S, w) && t.someProp("handleKeyDown", _ => _(t, so(8, "Backspace")))) {
        Mr && At && t.domObserver.suppressSelectionUpdates();
        return
    }
    At && C.endB == C.start && (t.input.lastChromeDelete = Date.now()),
    Mr && !A && S.start() != w.start() && w.parentOffset == 0 && S.depth == w.depth && h.sel && h.sel.anchor == h.sel.head && h.sel.head == C.endA && (C.endB -= 2,
    w = h.doc.resolveNoCache(C.endB - h.from),
    setTimeout( () => {
        t.someProp("handleKeyDown", function(_) {
            return _(t, so(13, "Enter"))
        })
    }
    , 20));
    let O = C.start, B = C.endA, z = _ => {
        let W = _ || t.state.tr.replace(O, B, h.doc.slice(C.start - h.from, C.endB - h.from));
        if (h.sel) {
            let ne = Rb(t, W.doc, h.sel);
            ne && !(At && t.composing && ne.empty && (C.start != C.endB || t.input.lastChromeDelete < Date.now() - 100) && (ne.head == O || ne.head == W.mapping.map(B) - 1) || Wt && ne.empty && ne.head == O) && W.setSelection(ne)
        }
        return l && W.setMeta("composition", l),
        W.scrollIntoView()
    }
    , $;
    if (A)
        if (S.pos == w.pos) {
            Wt && xi <= 11 && S.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(),
            setTimeout( () => Nr(t), 20));
            let _ = z(t.state.tr.delete(O, B))
              , W = p.resolve(C.start).marksAcross(p.resolve(C.endA));
            W && _.ensureMarks(W),
            t.dispatch(_)
        } else if (C.endA == C.endB && ($ = WT(S.parent.content.cut(S.parentOffset, w.parentOffset), k.parent.content.cut(k.parentOffset, C.endA - k.start())))) {
            let _ = z(t.state.tr);
            $.type == "add" ? _.addMark(O, B, $.mark) : _.removeMark(O, B, $.mark),
            t.dispatch(_)
        } else if (S.parent.child(S.index()).isText && S.index() == w.index() - (w.textOffset ? 0 : 1)) {
            let _ = S.parent.textBetween(S.parentOffset, w.parentOffset)
              , W = () => z(t.state.tr.insertText(_, O, B));
            t.someProp("handleTextInput", ne => ne(t, O, B, _, W)) || t.dispatch(W())
        } else
            t.dispatch(z());
    else
        t.dispatch(z())
}
function Rb(t, e, n) {
    return Math.max(n.anchor, n.head) > e.content.size ? null : M1(t, e.resolve(n.anchor), e.resolve(n.head))
}
function WT(t, e) {
    let n = t.firstChild.marks, r = e.firstChild.marks, o = n, l = r, a, u, f;
    for (let p = 0; p < r.length; p++)
        o = r[p].removeFromSet(o);
    for (let p = 0; p < n.length; p++)
        l = n[p].removeFromSet(l);
    if (o.length == 1 && l.length == 0)
        u = o[0],
        a = "add",
        f = p => p.mark(u.addToSet(p.marks));
    else if (o.length == 0 && l.length == 1)
        u = l[0],
        a = "remove",
        f = p => p.mark(u.removeFromSet(p.marks));
    else
        return null;
    let h = [];
    for (let p = 0; p < e.childCount; p++)
        h.push(f(e.child(p)));
    if (Z.from(h).eq(t))
        return {
            mark: u,
            type: a
        }
}
function XT(t, e, n, r, o) {
    if (n - e <= o.pos - r.pos || Bp(r, !0, !1) < o.pos)
        return !1;
    let l = t.resolve(e);
    if (!r.parent.isTextblock) {
        let u = l.nodeAfter;
        return u != null && n == e + u.nodeSize
    }
    if (l.parentOffset < l.parent.content.size || !l.parent.isTextblock)
        return !1;
    let a = t.resolve(Bp(l, !0, !0));
    return !a.parent.isTextblock || a.pos > n || Bp(a, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(a.parent.content)
}
function Bp(t, e, n) {
    let r = t.depth
      , o = e ? t.end() : t.pos;
    for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
        r--,
        o++,
        e = !1;
    if (n) {
        let l = t.node(r).maybeChild(t.indexAfter(r));
        for (; l && !l.isLeaf; )
            l = l.firstChild,
            o++
    }
    return o
}
function JT(t, e, n, r, o) {
    let l = t.findDiffStart(e, n);
    if (l == null)
        return null;
    let {a, b: u} = t.findDiffEnd(e, n + t.size, n + e.size);
    if (o == "end") {
        let f = Math.max(0, l - Math.min(a, u));
        r -= a + f - l
    }
    if (a < l && t.size < e.size) {
        let f = r <= l && r >= a ? l - r : 0;
        l -= f,
        l && l < e.size && Ob(e.textBetween(l - 1, l + 1)) && (l += f ? 1 : -1),
        u = l + (u - a),
        a = l
    } else if (u < l) {
        let f = r <= l && r >= u ? l - r : 0;
        l -= f,
        l && l < t.size && Ob(t.textBetween(l - 1, l + 1)) && (l += f ? 1 : -1),
        a = l + (a - u),
        u = l
    }
    return {
        start: l,
        endA: a,
        endB: u
    }
}
function Ob(t) {
    if (t.length != 2)
        return !1;
    let e = t.charCodeAt(0)
      , n = t.charCodeAt(1);
    return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319
}
class Yx {
    constructor(e, n) {
        this._root = null,
        this.focused = !1,
        this.trackWrites = null,
        this.mounted = !1,
        this.markCursor = null,
        this.cursorWrapper = null,
        this.lastSelectedViewDesc = void 0,
        this.input = new pT,
        this.prevDirectPlugins = [],
        this.pluginViews = [],
        this.requiresGeckoHackNode = !1,
        this.dragging = null,
        this._props = n,
        this.state = n.state,
        this.directPlugins = n.plugins || [],
        this.directPlugins.forEach(Bb),
        this.dispatch = this.dispatch.bind(this),
        this.dom = e && e.mount || document.createElement("div"),
        e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)),
        this.editable = zb(this),
        Lb(this),
        this.nodeViews = _b(this),
        this.docView = db(this.state.doc, Db(this), _p(this), this.dom, this),
        this.domObserver = new UT(this, (r, o, l, a) => ZT(this, r, o, l, a)),
        this.domObserver.start(),
        mT(this),
        this.updatePluginViews()
    }
    get composing() {
        return this.input.composing
    }
    get props() {
        if (this._props.state != this.state) {
            let e = this._props;
            this._props = {};
            for (let n in e)
                this._props[n] = e[n];
            this._props.state = this.state
        }
        return this._props
    }
    update(e) {
        e.handleDOMEvents != this._props.handleDOMEvents && Om(this);
        let n = this._props;
        this._props = e,
        e.plugins && (e.plugins.forEach(Bb),
        this.directPlugins = e.plugins),
        this.updateStateInner(e.state, n)
    }
    setProps(e) {
        let n = {};
        for (let r in this._props)
            n[r] = this._props[r];
        n.state = this.state;
        for (let r in e)
            n[r] = e[r];
        this.update(n)
    }
    updateState(e) {
        this.updateStateInner(e, this._props)
    }
    updateStateInner(e, n) {
        var r;
        let o = this.state
          , l = !1
          , a = !1;
        e.storedMarks && this.composing && (Ux(this),
        a = !0),
        this.state = e;
        let u = o.plugins != e.plugins || this._props.plugins != n.plugins;
        if (u || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
            let b = _b(this);
            ek(b, this.nodeViews) && (this.nodeViews = b,
            l = !0)
        }
        (u || n.handleDOMEvents != this._props.handleDOMEvents) && Om(this),
        this.editable = zb(this),
        Lb(this);
        let f = _p(this)
          , h = Db(this)
          , p = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve"
          , m = l || !this.docView.matchesNode(e.doc, h, f);
        (m || !e.selection.eq(o.selection)) && (a = !0);
        let y = p == "preserve" && a && this.dom.style.overflowAnchor == null && N6(this);
        if (a) {
            this.domObserver.stop();
            let b = m && (Wt || At) && !this.composing && !o.selection.empty && !e.selection.empty && QT(o.selection, e.selection);
            if (m) {
                let C = At ? this.trackWrites = this.domSelectionRange().focusNode : null;
                this.composing && (this.input.compositionNode = NT(this)),
                (l || !this.docView.update(e.doc, h, f, this)) && (this.docView.updateOuterDeco(h),
                this.docView.destroy(),
                this.docView = db(e.doc, h, f, this.dom, this)),
                C && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (b = !0)
            }
            b || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Q6(this)) ? Nr(this, b) : (Nx(this, e.selection),
            this.domObserver.setCurSelection()),
            this.domObserver.start()
        }
        this.updatePluginViews(o),
        !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o),
        p == "reset" ? this.dom.scrollTop = 0 : p == "to selection" ? this.scrollToSelection() : y && R6(y)
    }
    scrollToSelection() {
        let e = this.domSelectionRange().focusNode;
        if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
            if (!this.someProp("handleScrollToSelection", n => n(this)))
                if (this.state.selection instanceof le) {
                    let n = this.docView.domAfterPos(this.state.selection.from);
                    n.nodeType == 1 && lb(this, n.getBoundingClientRect(), e)
                } else
                    lb(this, this.coordsAtPos(this.state.selection.head, 1), e)
        }
    }
    destroyPluginViews() {
        let e;
        for (; e = this.pluginViews.pop(); )
            e.destroy && e.destroy()
    }
    updatePluginViews(e) {
        if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins,
            this.destroyPluginViews();
            for (let n = 0; n < this.directPlugins.length; n++) {
                let r = this.directPlugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
            for (let n = 0; n < this.state.plugins.length; n++) {
                let r = this.state.plugins[n];
                r.spec.view && this.pluginViews.push(r.spec.view(this))
            }
        } else
            for (let n = 0; n < this.pluginViews.length; n++) {
                let r = this.pluginViews[n];
                r.update && r.update(this, e)
            }
    }
    updateDraggedNode(e, n) {
        let r = e.node
          , o = -1;
        if (this.state.doc.nodeAt(r.from) == r.node)
            o = r.from;
        else {
            let l = r.from + (this.state.doc.content.size - n.doc.content.size);
            (l > 0 && this.state.doc.nodeAt(l)) == r.node && (o = l)
        }
        this.dragging = new qx(e.slice,e.move,o < 0 ? void 0 : le.create(this.state.doc, o))
    }
    someProp(e, n) {
        let r = this._props && this._props[e], o;
        if (r != null && (o = n ? n(r) : r))
            return o;
        for (let a = 0; a < this.directPlugins.length; a++) {
            let u = this.directPlugins[a].props[e];
            if (u != null && (o = n ? n(u) : u))
                return o
        }
        let l = this.state.plugins;
        if (l)
            for (let a = 0; a < l.length; a++) {
                let u = l[a].props[e];
                if (u != null && (o = n ? n(u) : u))
                    return o
            }
    }
    hasFocus() {
        if (Wt) {
            let e = this.root.activeElement;
            if (e == this.dom)
                return !0;
            if (!e || !this.dom.contains(e))
                return !1;
            for (; e && this.dom != e && this.dom.contains(e); ) {
                if (e.contentEditable == "false")
                    return !1;
                e = e.parentElement
            }
            return !0
        }
        return this.root.activeElement == this.dom
    }
    focus() {
        this.domObserver.stop(),
        this.editable && O6(this.dom),
        Nr(this),
        this.domObserver.start()
    }
    get root() {
        let e = this._root;
        if (e == null) {
            for (let n = this.dom.parentNode; n; n = n.parentNode)
                if (n.nodeType == 9 || n.nodeType == 11 && n.host)
                    return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()),
                    this._root = n
        }
        return e || document
    }
    updateRoot() {
        this._root = null
    }
    posAtCoords(e) {
        return B6(this, e)
    }
    coordsAtPos(e, n=1) {
        return Sx(this, e, n)
    }
    domAtPos(e, n=0) {
        return this.docView.domFromPos(e, n)
    }
    nodeDOM(e) {
        let n = this.docView.descAt(e);
        return n ? n.nodeDOM : null
    }
    posAtDOM(e, n, r=-1) {
        let o = this.docView.posFromDOM(e, n, r);
        if (o == null)
            throw new RangeError("DOM position not inside the editor");
        return o
    }
    endOfTextblock(e, n) {
        return U6(this, n || this.state, e)
    }
    pasteHTML(e, n) {
        return ha(this, "", e, !1, n || new ClipboardEvent("paste"))
    }
    pasteText(e, n) {
        return ha(this, e, null, !0, n || new ClipboardEvent("paste"))
    }
    serializeForClipboard(e) {
        return A1(this, e)
    }
    destroy() {
        this.docView && (gT(this),
        this.destroyPluginViews(),
        this.mounted ? (this.docView.update(this.state.doc, [], _p(this), this),
        this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom),
        this.docView.destroy(),
        this.docView = null,
        b6())
    }
    get isDestroyed() {
        return this.docView == null
    }
    dispatchEvent(e) {
        return vT(this, e)
    }
    domSelectionRange() {
        let e = this.domSelection();
        return e ? Dt && this.root.nodeType === 11 && E6(this.dom.ownerDocument) == this.dom && qT(this, e) || e : {
            focusNode: null,
            focusOffset: 0,
            anchorNode: null,
            anchorOffset: 0
        }
    }
    domSelection() {
        return this.root.getSelection()
    }
}
Yx.prototype.dispatch = function(t) {
    let e = this._props.dispatchTransaction;
    e ? e.call(this, t) : this.updateState(this.state.apply(t))
}
;
function Db(t) {
    let e = Object.create(null);
    return e.class = "ProseMirror",
    e.contenteditable = String(t.editable),
    t.someProp("attributes", n => {
        if (typeof n == "function" && (n = n(t.state)),
        n)
            for (let r in n)
                r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]))
    }
    ),
    e.translate || (e.translate = "no"),
    [yt.node(0, t.state.doc.content.size, e)]
}
function Lb(t) {
    if (t.markCursor) {
        let e = document.createElement("img");
        e.className = "ProseMirror-separator",
        e.setAttribute("mark-placeholder", "true"),
        e.setAttribute("alt", ""),
        t.cursorWrapper = {
            dom: e,
            deco: yt.widget(t.state.selection.from, e, {
                raw: !0,
                marks: t.markCursor
            })
        }
    } else
        t.cursorWrapper = null
}
function zb(t) {
    return !t.someProp("editable", e => e(t.state) === !1)
}
function QT(t, e) {
    let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
    return t.$anchor.start(n) != e.$anchor.start(n)
}
function _b(t) {
    let e = Object.create(null);
    function n(r) {
        for (let o in r)
            Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o])
    }
    return t.someProp("nodeViews", n),
    t.someProp("markViews", n),
    e
}
function ek(t, e) {
    let n = 0
      , r = 0;
    for (let o in t) {
        if (t[o] != e[o])
            return !0;
        n++
    }
    for (let o in e)
        r++;
    return n != r
}
function Bb(t) {
    if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component")
}
var Ai = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
}
  , Hu = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
}
  , tk = typeof navigator < "u" && /Mac/.test(navigator.platform)
  , nk = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Mt = 0; Mt < 10; Mt++)
    Ai[48 + Mt] = Ai[96 + Mt] = String(Mt);
for (var Mt = 1; Mt <= 24; Mt++)
    Ai[Mt + 111] = "F" + Mt;
for (var Mt = 65; Mt <= 90; Mt++)
    Ai[Mt] = String.fromCharCode(Mt + 32),
    Hu[Mt] = String.fromCharCode(Mt);
for (var jp in Ai)
    Hu.hasOwnProperty(jp) || (Hu[jp] = Ai[jp]);
function rk(t) {
    var e = tk && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || nk && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified"
      , n = !e && t.key || (t.shiftKey ? Hu : Ai)[t.keyCode] || t.key || "Unidentified";
    return n == "Esc" && (n = "Escape"),
    n == "Del" && (n = "Delete"),
    n == "Left" && (n = "ArrowLeft"),
    n == "Up" && (n = "ArrowUp"),
    n == "Right" && (n = "ArrowRight"),
    n == "Down" && (n = "ArrowDown"),
    n
}
const ik = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform)
  , ok = typeof navigator < "u" && /Win/.test(navigator.platform);
function lk(t) {
    let e = t.split(/-(?!$)/)
      , n = e[e.length - 1];
    n == "Space" && (n = " ");
    let r, o, l, a;
    for (let u = 0; u < e.length - 1; u++) {
        let f = e[u];
        if (/^(cmd|meta|m)$/i.test(f))
            a = !0;
        else if (/^a(lt)?$/i.test(f))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(f))
            o = !0;
        else if (/^s(hift)?$/i.test(f))
            l = !0;
        else if (/^mod$/i.test(f))
            ik ? a = !0 : o = !0;
        else
            throw new Error("Unrecognized modifier name: " + f)
    }
    return r && (n = "Alt-" + n),
    o && (n = "Ctrl-" + n),
    a && (n = "Meta-" + n),
    l && (n = "Shift-" + n),
    n
}
function sk(t) {
    let e = Object.create(null);
    for (let n in t)
        e[lk(n)] = t[n];
    return e
}
function Hp(t, e, n=!0) {
    return e.altKey && (t = "Alt-" + t),
    e.ctrlKey && (t = "Ctrl-" + t),
    e.metaKey && (t = "Meta-" + t),
    n && e.shiftKey && (t = "Shift-" + t),
    t
}
function ak(t) {
    return new Ye({
        props: {
            handleKeyDown: z1(t)
        }
    })
}
function z1(t) {
    let e = sk(t);
    return function(n, r) {
        let o = rk(r), l, a = e[Hp(o, r)];
        if (a && a(n.state, n.dispatch, n))
            return !0;
        if (o.length == 1 && o != " ") {
            if (r.shiftKey) {
                let u = e[Hp(o, r, !1)];
                if (u && u(n.state, n.dispatch, n))
                    return !0
            }
            if ((r.altKey || r.metaKey || r.ctrlKey) && !(ok && r.ctrlKey && r.altKey) && (l = Ai[r.keyCode]) && l != o) {
                let u = e[Hp(l, r)];
                if (u && u(n.state, n.dispatch, n))
                    return !0
            }
        }
        return !1
    }
}
var ck = Object.defineProperty
  , _1 = (t, e) => {
    for (var n in e)
        ck(t, n, {
            get: e[n],
            enumerable: !0
        })
}
;
function _f(t) {
    const {state: e, transaction: n} = t;
    let {selection: r} = n
      , {doc: o} = n
      , {storedMarks: l} = n;
    return {
        ...e,
        apply: e.apply.bind(e),
        applyTransaction: e.applyTransaction.bind(e),
        plugins: e.plugins,
        schema: e.schema,
        reconfigure: e.reconfigure.bind(e),
        toJSON: e.toJSON.bind(e),
        get storedMarks() {
            return l
        },
        get selection() {
            return r
        },
        get doc() {
            return o
        },
        get tr() {
            return r = n.selection,
            o = n.doc,
            l = n.storedMarks,
            n
        }
    }
}
var Bf = class {
    constructor(t) {
        this.editor = t.editor,
        this.rawCommands = this.editor.extensionManager.commands,
        this.customState = t.state
    }
    get hasCustomState() {
        return !!this.customState
    }
    get state() {
        return this.customState || this.editor.state
    }
    get commands() {
        const {rawCommands: t, editor: e, state: n} = this
          , {view: r} = e
          , {tr: o} = n
          , l = this.buildProps(o);
        return Object.fromEntries(Object.entries(t).map( ([a,u]) => [a, (...h) => {
            const p = u(...h)(l);
            return !o.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(o),
            p
        }
        ]))
    }
    get chain() {
        return () => this.createChain()
    }
    get can() {
        return () => this.createCan()
    }
    createChain(t, e=!0) {
        const {rawCommands: n, editor: r, state: o} = this
          , {view: l} = r
          , a = []
          , u = !!t
          , f = t || o.tr
          , h = () => (!u && e && !f.getMeta("preventDispatch") && !this.hasCustomState && l.dispatch(f),
        a.every(m => m === !0))
          , p = {
            ...Object.fromEntries(Object.entries(n).map( ([m,y]) => [m, (...C) => {
                const S = this.buildProps(f, e)
                  , w = y(...C)(S);
                return a.push(w),
                p
            }
            ])),
            run: h
        };
        return p
    }
    createCan(t) {
        const {rawCommands: e, state: n} = this
          , r = !1
          , o = t || n.tr
          , l = this.buildProps(o, r);
        return {
            ...Object.fromEntries(Object.entries(e).map( ([u,f]) => [u, (...h) => f(...h)({
                ...l,
                dispatch: void 0
            })])),
            chain: () => this.createChain(o, r)
        }
    }
    buildProps(t, e=!0) {
        const {rawCommands: n, editor: r, state: o} = this
          , {view: l} = r
          , a = {
            tr: t,
            editor: r,
            view: l,
            state: _f({
                state: o,
                transaction: t
            }),
            dispatch: e ? () => {}
            : void 0,
            chain: () => this.createChain(t, e),
            can: () => this.createCan(t),
            get commands() {
                return Object.fromEntries(Object.entries(n).map( ([u,f]) => [u, (...h) => f(...h)(a)]))
            }
        };
        return a
    }
}
  , Zx = {};
_1(Zx, {
    blur: () => uk,
    clearContent: () => fk,
    clearNodes: () => dk,
    command: () => hk,
    createParagraphNear: () => pk,
    cut: () => mk,
    deleteCurrentNode: () => gk,
    deleteNode: () => yk,
    deleteRange: () => vk,
    deleteSelection: () => bk,
    enter: () => Ck,
    exitCode: () => Sk,
    extendMarkRange: () => xk,
    first: () => wk,
    focus: () => Tk,
    forEach: () => kk,
    insertContent: () => Mk,
    insertContentAt: () => Rk,
    joinBackward: () => Lk,
    joinDown: () => Dk,
    joinForward: () => zk,
    joinItemBackward: () => _k,
    joinItemForward: () => Bk,
    joinTextblockBackward: () => jk,
    joinTextblockForward: () => Hk,
    joinUp: () => Ok,
    keyboardShortcut: () => Vk,
    lift: () => Uk,
    liftEmptyBlock: () => Pk,
    liftListItem: () => qk,
    newlineInCode: () => $k,
    resetAttributes: () => Fk,
    scrollIntoView: () => Kk,
    selectAll: () => Gk,
    selectNodeBackward: () => Yk,
    selectNodeForward: () => Zk,
    selectParentNode: () => Wk,
    selectTextblockEnd: () => Xk,
    selectTextblockStart: () => Jk,
    setContent: () => Qk,
    setMark: () => vM,
    setMeta: () => bM,
    setNode: () => CM,
    setNodeSelection: () => SM,
    setTextDirection: () => xM,
    setTextSelection: () => wM,
    sinkListItem: () => EM,
    splitBlock: () => TM,
    splitListItem: () => kM,
    toggleList: () => MM,
    toggleMark: () => AM,
    toggleNode: () => NM,
    toggleWrap: () => RM,
    undoInputRule: () => OM,
    unsetAllMarks: () => DM,
    unsetMark: () => LM,
    unsetTextDirection: () => zM,
    updateAttributes: () => _M,
    wrapIn: () => BM,
    wrapInList: () => jM
});
var uk = () => ({editor: t, view: e}) => (requestAnimationFrame( () => {
    var n;
    t.isDestroyed || (e.dom.blur(),
    (n = window?.getSelection()) == null || n.removeAllRanges())
}
),
!0)
  , fk = (t=!0) => ({commands: e}) => e.setContent("", {
    emitUpdate: t
})
  , dk = () => ({state: t, tr: e, dispatch: n}) => {
    const {selection: r} = e
      , {ranges: o} = r;
    return n && o.forEach( ({$from: l, $to: a}) => {
        t.doc.nodesBetween(l.pos, a.pos, (u, f) => {
            if (u.type.isText)
                return;
            const {doc: h, mapping: p} = e
              , m = h.resolve(p.map(f))
              , y = h.resolve(p.map(f + u.nodeSize))
              , b = m.blockRange(y);
            if (!b)
                return;
            const C = Ul(b);
            if (u.type.isTextblock) {
                const {defaultType: S} = m.parent.contentMatchAt(m.index());
                e.setNodeMarkup(b.start, S)
            }
            (C || C === 0) && e.lift(b, C)
        }
        )
    }
    ),
    !0
}
  , hk = t => e => t(e)
  , pk = () => ({state: t, dispatch: e}) => ux(t, e)
  , mk = (t, e) => ({editor: n, tr: r}) => {
    const {state: o} = n
      , l = o.doc.slice(t.from, t.to);
    r.deleteRange(t.from, t.to);
    const a = r.mapping.map(e);
    return r.insert(a, l.content),
    r.setSelection(new se(r.doc.resolve(Math.max(a - 1, 0)))),
    !0
}
  , gk = () => ({tr: t, dispatch: e}) => {
    const {selection: n} = t
      , r = n.$anchor.node();
    if (r.content.size > 0)
        return !1;
    const o = t.selection.$anchor;
    for (let l = o.depth; l > 0; l -= 1)
        if (o.node(l).type === r.type) {
            if (e) {
                const u = o.before(l)
                  , f = o.after(l);
                t.delete(u, f).scrollIntoView()
            }
            return !0
        }
    return !1
}
;
function dt(t, e) {
    if (typeof t == "string") {
        if (!e.nodes[t])
            throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
        return e.nodes[t]
    }
    return t
}
var yk = t => ({tr: e, state: n, dispatch: r}) => {
    const o = dt(t, n.schema)
      , l = e.selection.$anchor;
    for (let a = l.depth; a > 0; a -= 1)
        if (l.node(a).type === o) {
            if (r) {
                const f = l.before(a)
                  , h = l.after(a);
                e.delete(f, h).scrollIntoView()
            }
            return !0
        }
    return !1
}
  , vk = t => ({tr: e, dispatch: n}) => {
    const {from: r, to: o} = t;
    return n && e.delete(r, o),
    !0
}
  , bk = () => ({state: t, dispatch: e}) => C1(t, e)
  , Ck = () => ({commands: t}) => t.keyboardShortcut("Enter")
  , Sk = () => ({state: t, dispatch: e}) => i6(t, e);
function B1(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
function Iu(t, e, n={
    strict: !0
}) {
    const r = Object.keys(e);
    return r.length ? r.every(o => n.strict ? e[o] === t[o] : B1(e[o]) ? e[o].test(t[o]) : e[o] === t[o]) : !0
}
function Wx(t, e, n={}) {
    return t.find(r => r.type === e && Iu(Object.fromEntries(Object.keys(n).map(o => [o, r.attrs[o]])), n))
}
function jb(t, e, n={}) {
    return !!Wx(t, e, n)
}
function j1(t, e, n) {
    var r;
    if (!t || !e)
        return;
    let o = t.parent.childAfter(t.parentOffset);
    if ((!o.node || !o.node.marks.some(p => p.type === e)) && (o = t.parent.childBefore(t.parentOffset)),
    !o.node || !o.node.marks.some(p => p.type === e) || (n = n || ((r = o.node.marks[0]) == null ? void 0 : r.attrs),
    !Wx([...o.node.marks], e, n)))
        return;
    let a = o.index
      , u = t.start() + o.offset
      , f = a + 1
      , h = u + o.node.nodeSize;
    for (; a > 0 && jb([...t.parent.child(a - 1).marks], e, n); )
        a -= 1,
        u -= t.parent.child(a).nodeSize;
    for (; f < t.parent.childCount && jb([...t.parent.child(f).marks], e, n); )
        h += t.parent.child(f).nodeSize,
        f += 1;
    return {
        from: u,
        to: h
    }
}
function zr(t, e) {
    if (typeof t == "string") {
        if (!e.marks[t])
            throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
        return e.marks[t]
    }
    return t
}
var xk = (t, e={}) => ({tr: n, state: r, dispatch: o}) => {
    const l = zr(t, r.schema)
      , {doc: a, selection: u} = n
      , {$from: f, from: h, to: p} = u;
    if (o) {
        const m = j1(f, l, e);
        if (m && m.from <= h && m.to >= p) {
            const y = se.create(a, m.from, m.to);
            n.setSelection(y)
        }
    }
    return !0
}
  , wk = t => e => {
    const n = typeof t == "function" ? t(e) : t;
    for (let r = 0; r < n.length; r += 1)
        if (n[r](e))
            return !0;
    return !1
}
;
function Xx(t) {
    return t instanceof se
}
function uo(t=0, e=0, n=0) {
    return Math.min(Math.max(t, e), n)
}
function Jx(t, e=null) {
    if (!e)
        return null;
    const n = ye.atStart(t)
      , r = ye.atEnd(t);
    if (e === "start" || e === !0)
        return n;
    if (e === "end")
        return r;
    const o = n.from
      , l = r.to;
    return e === "all" ? se.create(t, uo(0, o, l), uo(t.content.size, o, l)) : se.create(t, uo(e, o, l), uo(e, o, l))
}
function Hb() {
    return navigator.platform === "Android" || /android/i.test(navigator.userAgent)
}
function Vu() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend"in document
}
function Ek() {
    return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1
}
var Tk = (t=null, e={}) => ({editor: n, view: r, tr: o, dispatch: l}) => {
    e = {
        scrollIntoView: !0,
        ...e
    };
    const a = () => {
        (Vu() || Hb()) && r.dom.focus(),
        Ek() && !Vu() && !Hb() && r.dom.focus({
            preventScroll: !0
        }),
        requestAnimationFrame( () => {
            n.isDestroyed || (r.focus(),
            e?.scrollIntoView && n.commands.scrollIntoView())
        }
        )
    }
    ;
    try {
        if (r.hasFocus() && t === null || t === !1)
            return !0
    } catch {
        return !1
    }
    if (l && t === null && !Xx(n.state.selection))
        return a(),
        !0;
    const u = Jx(o.doc, t) || n.state.selection
      , f = n.state.selection.eq(u);
    return l && (f || o.setSelection(u),
    f && o.storedMarks && o.setStoredMarks(o.storedMarks),
    a()),
    !0
}
  , kk = (t, e) => n => t.every( (r, o) => e(r, {
    ...n,
    index: o
}))
  , Mk = (t, e) => ({tr: n, commands: r}) => r.insertContentAt({
    from: n.selection.from,
    to: n.selection.to
}, t, e)
  , Qx = t => {
    const e = t.childNodes;
    for (let n = e.length - 1; n >= 0; n -= 1) {
        const r = e[n];
        r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && Qx(r)
    }
    return t
}
;
function Wc(t) {
    if (typeof window > "u")
        throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
    const e = `<body>${t}</body>`
      , n = new window.DOMParser().parseFromString(e, "text/html").body;
    return Qx(n)
}
function ma(t, e, n) {
    if (t instanceof Ci || t instanceof Z)
        return t;
    n = {
        slice: !0,
        parseOptions: {},
        ...n
    };
    const r = typeof t == "object" && t !== null
      , o = typeof t == "string";
    if (r)
        try {
            if (Array.isArray(t) && t.length > 0)
                return Z.fromArray(t.map(u => e.nodeFromJSON(u)));
            const a = e.nodeFromJSON(t);
            return n.errorOnInvalidContent && a.check(),
            a
        } catch (l) {
            if (n.errorOnInvalidContent)
                throw new Error("[tiptap error]: Invalid JSON content",{
                    cause: l
                });
            return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", l),
            ma("", e, n)
        }
    if (o) {
        if (n.errorOnInvalidContent) {
            let a = !1
              , u = "";
            const f = new jS({
                topNode: e.spec.topNode,
                marks: e.spec.marks,
                nodes: e.spec.nodes.append({
                    __tiptap__private__unknown__catch__all__node: {
                        content: "inline*",
                        group: "block",
                        parseDOM: [{
                            tag: "*",
                            getAttrs: h => (a = !0,
                            u = typeof h == "string" ? h : h.outerHTML,
                            null)
                        }]
                    }
                })
            });
            if (n.slice ? Si.fromSchema(f).parseSlice(Wc(t), n.parseOptions) : Si.fromSchema(f).parse(Wc(t), n.parseOptions),
            n.errorOnInvalidContent && a)
                throw new Error("[tiptap error]: Invalid HTML content",{
                    cause: new Error(`Invalid element found: ${u}`)
                })
        }
        const l = Si.fromSchema(e);
        return n.slice ? l.parseSlice(Wc(t), n.parseOptions).content : l.parse(Wc(t), n.parseOptions)
    }
    return ma("", e, n)
}
function Ak(t, e, n) {
    const r = t.steps.length - 1;
    if (r < e)
        return;
    const o = t.steps[r];
    if (!(o instanceof gt || o instanceof vt))
        return;
    const l = t.mapping.maps[r];
    let a = 0;
    l.forEach( (u, f, h, p) => {
        a === 0 && (a = p)
    }
    ),
    t.setSelection(ye.near(t.doc.resolve(a), n))
}
var Nk = t => !("type"in t)
  , Rk = (t, e, n) => ({tr: r, dispatch: o, editor: l}) => {
    var a;
    if (o) {
        n = {
            parseOptions: l.options.parseOptions,
            updateSelection: !0,
            applyInputRules: !1,
            applyPasteRules: !1,
            ...n
        };
        let u;
        const f = w => {
            l.emit("contentError", {
                editor: l,
                error: w,
                disableCollaboration: () => {
                    "collaboration"in l.storage && typeof l.storage.collaboration == "object" && l.storage.collaboration && (l.storage.collaboration.isDisabled = !0)
                }
            })
        }
          , h = {
            preserveWhitespace: "full",
            ...n.parseOptions
        };
        if (!n.errorOnInvalidContent && !l.options.enableContentCheck && l.options.emitContentError)
            try {
                ma(e, l.schema, {
                    parseOptions: h,
                    errorOnInvalidContent: !0
                })
            } catch (w) {
                f(w)
            }
        try {
            u = ma(e, l.schema, {
                parseOptions: h,
                errorOnInvalidContent: (a = n.errorOnInvalidContent) != null ? a : l.options.enableContentCheck
            })
        } catch (w) {
            return f(w),
            !1
        }
        let {from: p, to: m} = typeof t == "number" ? {
            from: t,
            to: t
        } : {
            from: t.from,
            to: t.to
        }
          , y = !0
          , b = !0;
        if ((Nk(u) ? u : [u]).forEach(w => {
            w.check(),
            y = y ? w.isText && w.marks.length === 0 : !1,
            b = b ? w.isBlock : !1
        }
        ),
        p === m && b) {
            const {parent: w} = r.doc.resolve(p);
            w.isTextblock && !w.type.spec.code && !w.childCount && (p -= 1,
            m += 1)
        }
        let S;
        if (y) {
            if (Array.isArray(e))
                S = e.map(w => w.text || "").join("");
            else if (e instanceof Z) {
                let w = "";
                e.forEach(k => {
                    k.text && (w += k.text)
                }
                ),
                S = w
            } else
                typeof e == "object" && e && e.text ? S = e.text : S = e;
            r.insertText(S, p, m)
        } else {
            S = u;
            const w = r.doc.resolve(p)
              , k = w.node()
              , A = w.parentOffset === 0
              , O = k.isText || k.isTextblock
              , B = k.content.size > 0;
            A && O && B && (p = Math.max(0, p - 1)),
            r.replaceWith(p, m, S)
        }
        n.updateSelection && Ak(r, r.steps.length - 1, -1),
        n.applyInputRules && r.setMeta("applyInputRules", {
            from: p,
            text: S
        }),
        n.applyPasteRules && r.setMeta("applyPasteRules", {
            from: p,
            text: S
        })
    }
    return !0
}
  , Ok = () => ({state: t, dispatch: e}) => t6(t, e)
  , Dk = () => ({state: t, dispatch: e}) => n6(t, e)
  , Lk = () => ({state: t, dispatch: e}) => rx(t, e)
  , zk = () => ({state: t, dispatch: e}) => sx(t, e)
  , _k = () => ({state: t, dispatch: e, tr: n}) => {
    try {
        const r = Nf(t.doc, t.selection.$from.pos, -1);
        return r == null ? !1 : (n.join(r, 2),
        e && e(n),
        !0)
    } catch {
        return !1
    }
}
  , Bk = () => ({state: t, dispatch: e, tr: n}) => {
    try {
        const r = Nf(t.doc, t.selection.$from.pos, 1);
        return r == null ? !1 : (n.join(r, 2),
        e && e(n),
        !0)
    } catch {
        return !1
    }
}
  , jk = () => ({state: t, dispatch: e}) => QE(t, e)
  , Hk = () => ({state: t, dispatch: e}) => e6(t, e);
function e3() {
    return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1
}
function Ik(t) {
    const e = t.split(/-(?!$)/);
    let n = e[e.length - 1];
    n === "Space" && (n = " ");
    let r, o, l, a;
    for (let u = 0; u < e.length - 1; u += 1) {
        const f = e[u];
        if (/^(cmd|meta|m)$/i.test(f))
            a = !0;
        else if (/^a(lt)?$/i.test(f))
            r = !0;
        else if (/^(c|ctrl|control)$/i.test(f))
            o = !0;
        else if (/^s(hift)?$/i.test(f))
            l = !0;
        else if (/^mod$/i.test(f))
            Vu() || e3() ? a = !0 : o = !0;
        else
            throw new Error(`Unrecognized modifier name: ${f}`)
    }
    return r && (n = `Alt-${n}`),
    o && (n = `Ctrl-${n}`),
    a && (n = `Meta-${n}`),
    l && (n = `Shift-${n}`),
    n
}
var Vk = t => ({editor: e, view: n, tr: r, dispatch: o}) => {
    const l = Ik(t).split(/-(?!$)/)
      , a = l.find(h => !["Alt", "Ctrl", "Meta", "Shift"].includes(h))
      , u = new KeyboardEvent("keydown",{
        key: a === "Space" ? " " : a,
        altKey: l.includes("Alt"),
        ctrlKey: l.includes("Ctrl"),
        metaKey: l.includes("Meta"),
        shiftKey: l.includes("Shift"),
        bubbles: !0,
        cancelable: !0
    })
      , f = e.captureTransaction( () => {
        n.someProp("handleKeyDown", h => h(n, u))
    }
    );
    return f?.steps.forEach(h => {
        const p = h.map(r.mapping);
        p && o && r.maybeStep(p)
    }
    ),
    !0
}
;
function Ni(t, e, n={}) {
    const {from: r, to: o, empty: l} = t.selection
      , a = e ? dt(e, t.schema) : null
      , u = [];
    t.doc.nodesBetween(r, o, (m, y) => {
        if (m.isText)
            return;
        const b = Math.max(r, y)
          , C = Math.min(o, y + m.nodeSize);
        u.push({
            node: m,
            from: b,
            to: C
        })
    }
    );
    const f = o - r
      , h = u.filter(m => a ? a.name === m.node.type.name : !0).filter(m => Iu(m.node.attrs, n, {
        strict: !1
    }));
    return l ? !!h.length : h.reduce( (m, y) => m + y.to - y.from, 0) >= f
}
var Uk = (t, e={}) => ({state: n, dispatch: r}) => {
    const o = dt(t, n.schema);
    return Ni(n, o, e) ? r6(n, r) : !1
}
  , Pk = () => ({state: t, dispatch: e}) => fx(t, e)
  , qk = t => ({state: e, dispatch: n}) => {
    const r = dt(t, e.schema);
    return m6(r)(e, n)
}
  , $k = () => ({state: t, dispatch: e}) => cx(t, e);
function jf(t, e) {
    return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null
}
function Ib(t, e) {
    const n = typeof e == "string" ? [e] : e;
    return Object.keys(t).reduce( (r, o) => (n.includes(o) || (r[o] = t[o]),
    r), {})
}
var Fk = (t, e) => ({tr: n, state: r, dispatch: o}) => {
    let l = null
      , a = null;
    const u = jf(typeof t == "string" ? t : t.name, r.schema);
    if (!u)
        return !1;
    u === "node" && (l = dt(t, r.schema)),
    u === "mark" && (a = zr(t, r.schema));
    let f = !1;
    return n.selection.ranges.forEach(h => {
        r.doc.nodesBetween(h.$from.pos, h.$to.pos, (p, m) => {
            l && l === p.type && (f = !0,
            o && n.setNodeMarkup(m, void 0, Ib(p.attrs, e))),
            a && p.marks.length && p.marks.forEach(y => {
                a === y.type && (f = !0,
                o && n.addMark(m, m + p.nodeSize, a.create(Ib(y.attrs, e))))
            }
            )
        }
        )
    }
    ),
    f
}
  , Kk = () => ({tr: t, dispatch: e}) => (e && t.scrollIntoView(),
!0)
  , Gk = () => ({tr: t, dispatch: e}) => {
    if (e) {
        const n = new Zt(t.doc);
        t.setSelection(n)
    }
    return !0
}
  , Yk = () => ({state: t, dispatch: e}) => ox(t, e)
  , Zk = () => ({state: t, dispatch: e}) => ax(t, e)
  , Wk = () => ({state: t, dispatch: e}) => s6(t, e)
  , Xk = () => ({state: t, dispatch: e}) => u6(t, e)
  , Jk = () => ({state: t, dispatch: e}) => c6(t, e);
function Dm(t, e, n={}, r={}) {
    return ma(t, e, {
        slice: !1,
        parseOptions: n,
        errorOnInvalidContent: r.errorOnInvalidContent
    })
}
var Qk = (t, {errorOnInvalidContent: e, emitUpdate: n=!0, parseOptions: r={}}={}) => ({editor: o, tr: l, dispatch: a, commands: u}) => {
    const {doc: f} = l;
    if (r.preserveWhitespace !== "full") {
        const h = Dm(t, o.schema, r, {
            errorOnInvalidContent: e ?? o.options.enableContentCheck
        });
        return a && l.replaceWith(0, f.content.size, h).setMeta("preventUpdate", !n),
        !0
    }
    return a && l.setMeta("preventUpdate", !n),
    u.insertContentAt({
        from: 0,
        to: f.content.size
    }, t, {
        parseOptions: r,
        errorOnInvalidContent: e ?? o.options.enableContentCheck
    })
}
;
function t3(t, e) {
    const n = zr(e, t.schema)
      , {from: r, to: o, empty: l} = t.selection
      , a = [];
    l ? (t.storedMarks && a.push(...t.storedMarks),
    a.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, o, f => {
        a.push(...f.marks)
    }
    );
    const u = a.find(f => f.type.name === n.name);
    return u ? {
        ...u.attrs
    } : {}
}
function n3(t, e) {
    const n = new v1(t);
    return e.forEach(r => {
        r.steps.forEach(o => {
            n.step(o)
        }
        )
    }
    ),
    n
}
function eM(t) {
    for (let e = 0; e < t.edgeCount; e += 1) {
        const {type: n} = t.edge(e);
        if (n.isTextblock && !n.hasRequiredAttrs())
            return n
    }
    return null
}
function tM(t, e, n) {
    const r = [];
    return t.nodesBetween(e.from, e.to, (o, l) => {
        n(o) && r.push({
            node: o,
            pos: l
        })
    }
    ),
    r
}
function r3(t, e) {
    for (let n = t.depth; n > 0; n -= 1) {
        const r = t.node(n);
        if (e(r))
            return {
                pos: n > 0 ? t.before(n) : 0,
                start: t.start(n),
                depth: n,
                node: r
            }
    }
}
function Hf(t) {
    return e => r3(e.$from, t)
}
function fe(t, e, n) {
    return t.config[e] === void 0 && t.parent ? fe(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
        ...n,
        parent: t.parent ? fe(t.parent, e, n) : null
    }) : t.config[e]
}
function H1(t) {
    return t.map(e => {
        const n = {
            name: e.name,
            options: e.options,
            storage: e.storage
        }
          , r = fe(e, "addExtensions", n);
        return r ? [e, ...H1(r())] : e
    }
    ).flat(10)
}
function I1(t, e) {
    const n = ko.fromSchema(e).serializeFragment(t)
      , o = document.implementation.createHTMLDocument().createElement("div");
    return o.appendChild(n),
    o.innerHTML
}
function i3(t) {
    return typeof t == "function"
}
function Le(t, e=void 0, ...n) {
    return i3(t) ? e ? t.bind(e)(...n) : t(...n) : t
}
function nM(t={}) {
    return Object.keys(t).length === 0 && t.constructor === Object
}
function _l(t) {
    const e = t.filter(o => o.type === "extension")
      , n = t.filter(o => o.type === "node")
      , r = t.filter(o => o.type === "mark");
    return {
        baseExtensions: e,
        nodeExtensions: n,
        markExtensions: r
    }
}
function o3(t) {
    const e = []
      , {nodeExtensions: n, markExtensions: r} = _l(t)
      , o = [...n, ...r]
      , l = {
        default: null,
        validate: void 0,
        rendered: !0,
        renderHTML: null,
        parseHTML: null,
        keepOnSplit: !0,
        isRequired: !1
    };
    return t.forEach(a => {
        const u = {
            name: a.name,
            options: a.options,
            storage: a.storage,
            extensions: o
        }
          , f = fe(a, "addGlobalAttributes", u);
        if (!f)
            return;
        f().forEach(p => {
            p.types.forEach(m => {
                Object.entries(p.attributes).forEach( ([y,b]) => {
                    e.push({
                        type: m,
                        name: y,
                        attribute: {
                            ...l,
                            ...b
                        }
                    })
                }
                )
            }
            )
        }
        )
    }
    ),
    o.forEach(a => {
        const u = {
            name: a.name,
            options: a.options,
            storage: a.storage
        }
          , f = fe(a, "addAttributes", u);
        if (!f)
            return;
        const h = f();
        Object.entries(h).forEach( ([p,m]) => {
            const y = {
                ...l,
                ...m
            };
            typeof y?.default == "function" && (y.default = y.default()),
            y?.isRequired && y?.default === void 0 && delete y.default,
            e.push({
                type: a.name,
                name: p,
                attribute: y
            })
        }
        )
    }
    ),
    e
}
function We(...t) {
    return t.filter(e => !!e).reduce( (e, n) => {
        const r = {
            ...e
        };
        return Object.entries(n).forEach( ([o,l]) => {
            if (!r[o]) {
                r[o] = l;
                return
            }
            if (o === "class") {
                const u = l ? String(l).split(" ") : []
                  , f = r[o] ? r[o].split(" ") : []
                  , h = u.filter(p => !f.includes(p));
                r[o] = [...f, ...h].join(" ")
            } else if (o === "style") {
                const u = l ? l.split(";").map(p => p.trim()).filter(Boolean) : []
                  , f = r[o] ? r[o].split(";").map(p => p.trim()).filter(Boolean) : []
                  , h = new Map;
                f.forEach(p => {
                    const [m,y] = p.split(":").map(b => b.trim());
                    h.set(m, y)
                }
                ),
                u.forEach(p => {
                    const [m,y] = p.split(":").map(b => b.trim());
                    h.set(m, y)
                }
                ),
                r[o] = Array.from(h.entries()).map( ([p,m]) => `${p}: ${m}`).join("; ")
            } else
                r[o] = l
        }
        ),
        r
    }
    , {})
}
function ga(t, e) {
    return e.filter(n => n.type === t.type.name).filter(n => n.attribute.rendered).map(n => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
        [n.name]: t.attrs[n.name]
    }).reduce( (n, r) => We(n, r), {})
}
function rM(t) {
    return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t
}
function Vb(t, e) {
    return "style"in t ? t : {
        ...t,
        getAttrs: n => {
            const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
            if (r === !1)
                return !1;
            const o = e.reduce( (l, a) => {
                const u = a.attribute.parseHTML ? a.attribute.parseHTML(n) : rM(n.getAttribute(a.name));
                return u == null ? l : {
                    ...l,
                    [a.name]: u
                }
            }
            , {});
            return {
                ...r,
                ...o
            }
        }
    }
}
function Ub(t) {
    return Object.fromEntries(Object.entries(t).filter( ([e,n]) => e === "attrs" && nM(n) ? !1 : n != null))
}
function Pb(t) {
    var e, n;
    const r = {};
    return !((e = t?.attribute) != null && e.isRequired) && "default"in (t?.attribute || {}) && (r.default = t.attribute.default),
    ((n = t?.attribute) == null ? void 0 : n.validate) !== void 0 && (r.validate = t.attribute.validate),
    [t.name, r]
}
function iM(t, e) {
    var n;
    const r = o3(t)
      , {nodeExtensions: o, markExtensions: l} = _l(t)
      , a = (n = o.find(h => fe(h, "topNode"))) == null ? void 0 : n.name
      , u = Object.fromEntries(o.map(h => {
        const p = r.filter(k => k.type === h.name)
          , m = {
            name: h.name,
            options: h.options,
            storage: h.storage,
            editor: e
        }
          , y = t.reduce( (k, A) => {
            const O = fe(A, "extendNodeSchema", m);
            return {
                ...k,
                ...O ? O(h) : {}
            }
        }
        , {})
          , b = Ub({
            ...y,
            content: Le(fe(h, "content", m)),
            marks: Le(fe(h, "marks", m)),
            group: Le(fe(h, "group", m)),
            inline: Le(fe(h, "inline", m)),
            atom: Le(fe(h, "atom", m)),
            selectable: Le(fe(h, "selectable", m)),
            draggable: Le(fe(h, "draggable", m)),
            code: Le(fe(h, "code", m)),
            whitespace: Le(fe(h, "whitespace", m)),
            linebreakReplacement: Le(fe(h, "linebreakReplacement", m)),
            defining: Le(fe(h, "defining", m)),
            isolating: Le(fe(h, "isolating", m)),
            attrs: Object.fromEntries(p.map(Pb))
        })
          , C = Le(fe(h, "parseHTML", m));
        C && (b.parseDOM = C.map(k => Vb(k, p)));
        const S = fe(h, "renderHTML", m);
        S && (b.toDOM = k => S({
            node: k,
            HTMLAttributes: ga(k, p)
        }));
        const w = fe(h, "renderText", m);
        return w && (b.toText = w),
        [h.name, b]
    }
    ))
      , f = Object.fromEntries(l.map(h => {
        const p = r.filter(w => w.type === h.name)
          , m = {
            name: h.name,
            options: h.options,
            storage: h.storage,
            editor: e
        }
          , y = t.reduce( (w, k) => {
            const A = fe(k, "extendMarkSchema", m);
            return {
                ...w,
                ...A ? A(h) : {}
            }
        }
        , {})
          , b = Ub({
            ...y,
            inclusive: Le(fe(h, "inclusive", m)),
            excludes: Le(fe(h, "excludes", m)),
            group: Le(fe(h, "group", m)),
            spanning: Le(fe(h, "spanning", m)),
            code: Le(fe(h, "code", m)),
            attrs: Object.fromEntries(p.map(Pb))
        })
          , C = Le(fe(h, "parseHTML", m));
        C && (b.parseDOM = C.map(w => Vb(w, p)));
        const S = fe(h, "renderHTML", m);
        return S && (b.toDOM = w => S({
            mark: w,
            HTMLAttributes: ga(w, p)
        })),
        [h.name, b]
    }
    ));
    return new jS({
        topNode: a,
        nodes: u,
        marks: f
    })
}
function oM(t) {
    const e = t.filter( (n, r) => t.indexOf(n) !== r);
    return Array.from(new Set(e))
}
function Uu(t) {
    return t.sort( (n, r) => {
        const o = fe(n, "priority") || 100
          , l = fe(r, "priority") || 100;
        return o > l ? -1 : o < l ? 1 : 0
    }
    )
}
function l3(t) {
    const e = Uu(H1(t))
      , n = oM(e.map(r => r.name));
    return n.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map(r => `'${r}'`).join(", ")}]. This can lead to issues.`),
    e
}
function s3(t, e, n) {
    const {from: r, to: o} = e
      , {blockSeparator: l=`

`, textSerializers: a={}} = n || {};
    let u = "";
    return t.nodesBetween(r, o, (f, h, p, m) => {
        var y;
        f.isBlock && h > r && (u += l);
        const b = a?.[f.type.name];
        if (b)
            return p && (u += b({
                node: f,
                pos: h,
                parent: p,
                index: m,
                range: e
            })),
            !1;
        f.isText && (u += (y = f?.text) == null ? void 0 : y.slice(Math.max(r, h) - h, o - h))
    }
    ),
    u
}
function lM(t, e) {
    const n = {
        from: 0,
        to: t.content.size
    };
    return s3(t, n, e)
}
function a3(t) {
    return Object.fromEntries(Object.entries(t.nodes).filter( ([,e]) => e.spec.toText).map( ([e,n]) => [e, n.spec.toText]))
}
function sM(t, e) {
    const n = dt(e, t.schema)
      , {from: r, to: o} = t.selection
      , l = [];
    t.doc.nodesBetween(r, o, u => {
        l.push(u)
    }
    );
    const a = l.reverse().find(u => u.type.name === n.name);
    return a ? {
        ...a.attrs
    } : {}
}
function c3(t, e) {
    const n = jf(typeof e == "string" ? e : e.name, t.schema);
    return n === "node" ? sM(t, e) : n === "mark" ? t3(t, e) : {}
}
function aM(t, e=JSON.stringify) {
    const n = {};
    return t.filter(r => {
        const o = e(r);
        return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0
    }
    )
}
function cM(t) {
    const e = aM(t);
    return e.length === 1 ? e : e.filter( (n, r) => !e.filter( (l, a) => a !== r).some(l => n.oldRange.from >= l.oldRange.from && n.oldRange.to <= l.oldRange.to && n.newRange.from >= l.newRange.from && n.newRange.to <= l.newRange.to))
}
function u3(t) {
    const {mapping: e, steps: n} = t
      , r = [];
    return e.maps.forEach( (o, l) => {
        const a = [];
        if (o.ranges.length)
            o.forEach( (u, f) => {
                a.push({
                    from: u,
                    to: f
                })
            }
            );
        else {
            const {from: u, to: f} = n[l];
            if (u === void 0 || f === void 0)
                return;
            a.push({
                from: u,
                to: f
            })
        }
        a.forEach( ({from: u, to: f}) => {
            const h = e.slice(l).map(u, -1)
              , p = e.slice(l).map(f)
              , m = e.invert().map(h, -1)
              , y = e.invert().map(p);
            r.push({
                oldRange: {
                    from: m,
                    to: y
                },
                newRange: {
                    from: h,
                    to: p
                }
            })
        }
        )
    }
    ),
    cM(r)
}
function V1(t, e, n) {
    const r = [];
    return t === e ? n.resolve(t).marks().forEach(o => {
        const l = n.resolve(t)
          , a = j1(l, o.type);
        a && r.push({
            mark: o,
            ...a
        })
    }
    ) : n.nodesBetween(t, e, (o, l) => {
        !o || o?.nodeSize === void 0 || r.push(...o.marks.map(a => ({
            from: l,
            to: l + o.nodeSize,
            mark: a
        })))
    }
    ),
    r
}
var uM = (t, e, n, r=20) => {
    const o = t.doc.resolve(n);
    let l = r
      , a = null;
    for (; l > 0 && a === null; ) {
        const u = o.node(l);
        u?.type.name === e ? a = u : l -= 1
    }
    return [a, l]
}
;
function Xc(t, e) {
    return e.nodes[t] || e.marks[t] || null
}
function bu(t, e, n) {
    return Object.fromEntries(Object.entries(n).filter( ([r]) => {
        const o = t.find(l => l.type === e && l.name === r);
        return o ? o.attribute.keepOnSplit : !1
    }
    ))
}
var fM = (t, e=500) => {
    let n = "";
    const r = t.parentOffset;
    return t.parent.nodesBetween(Math.max(0, r - e), r, (o, l, a, u) => {
        var f, h;
        const p = ((h = (f = o.type.spec).toText) == null ? void 0 : h.call(f, {
            node: o,
            pos: l,
            parent: a,
            index: u
        })) || o.textContent || "%leaf%";
        n += o.isAtom && !o.isText ? p : p.slice(0, Math.max(0, r - l))
    }
    ),
    n
}
;
function Lm(t, e, n={}) {
    const {empty: r, ranges: o} = t.selection
      , l = e ? zr(e, t.schema) : null;
    if (r)
        return !!(t.storedMarks || t.selection.$from.marks()).filter(m => l ? l.name === m.type.name : !0).find(m => Iu(m.attrs, n, {
            strict: !1
        }));
    let a = 0;
    const u = [];
    if (o.forEach( ({$from: m, $to: y}) => {
        const b = m.pos
          , C = y.pos;
        t.doc.nodesBetween(b, C, (S, w) => {
            if (!S.isText && !S.marks.length)
                return;
            const k = Math.max(b, w)
              , A = Math.min(C, w + S.nodeSize)
              , O = A - k;
            a += O,
            u.push(...S.marks.map(B => ({
                mark: B,
                from: k,
                to: A
            })))
        }
        )
    }
    ),
    a === 0)
        return !1;
    const f = u.filter(m => l ? l.name === m.mark.type.name : !0).filter(m => Iu(m.mark.attrs, n, {
        strict: !1
    })).reduce( (m, y) => m + y.to - y.from, 0)
      , h = u.filter(m => l ? m.mark.type !== l && m.mark.type.excludes(l) : !0).reduce( (m, y) => m + y.to - y.from, 0);
    return (f > 0 ? f + h : f) >= a
}
function dM(t, e, n={}) {
    if (!e)
        return Ni(t, null, n) || Lm(t, null, n);
    const r = jf(e, t.schema);
    return r === "node" ? Ni(t, e, n) : r === "mark" ? Lm(t, e, n) : !1
}
var hM = (t, e) => {
    const {$from: n, $to: r, $anchor: o} = t.selection;
    if (e) {
        const l = Hf(u => u.type.name === e)(t.selection);
        if (!l)
            return !1;
        const a = t.doc.resolve(l.pos + 1);
        return o.pos + 1 === a.end()
    }
    return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos)
}
  , pM = t => {
    const {$from: e, $to: n} = t.selection;
    return !(e.parentOffset > 0 || e.pos !== n.pos)
}
;
function qb(t, e) {
    return Array.isArray(e) ? e.some(n => (typeof n == "string" ? n : n.name) === t.name) : e
}
function $b(t, e) {
    const {nodeExtensions: n} = _l(e)
      , r = n.find(a => a.name === t);
    if (!r)
        return !1;
    const o = {
        name: r.name,
        options: r.options,
        storage: r.storage
    }
      , l = Le(fe(r, "group", o));
    return typeof l != "string" ? !1 : l.split(" ").includes("list")
}
function If(t, {checkChildren: e=!0, ignoreWhitespace: n=!1}={}) {
    var r;
    if (n) {
        if (t.type.name === "hardBreak")
            return !0;
        if (t.isText)
            return /^\s*$/m.test((r = t.text) != null ? r : "")
    }
    if (t.isText)
        return !t.text;
    if (t.isAtom || t.isLeaf)
        return !1;
    if (t.content.childCount === 0)
        return !0;
    if (e) {
        let o = !0;
        return t.content.forEach(l => {
            o !== !1 && (If(l, {
                ignoreWhitespace: n,
                checkChildren: e
            }) || (o = !1))
        }
        ),
        o
    }
    return !1
}
function f3(t) {
    return t instanceof le
}
var d3 = class h3 {
    constructor(e) {
        this.position = e
    }
    static fromJSON(e) {
        return new h3(e.position)
    }
    toJSON() {
        return {
            position: this.position
        }
    }
}
;
function mM(t, e) {
    const n = e.mapping.mapResult(t.position);
    return {
        position: new d3(n.pos),
        mapResult: n
    }
}
function gM(t) {
    return new d3(t)
}
function yM(t, e, n) {
    var r;
    const {selection: o} = e;
    let l = null;
    if (Xx(o) && (l = o.$cursor),
    l) {
        const u = (r = t.storedMarks) != null ? r : l.marks();
        return l.parent.type.allowsMarkType(n) && (!!n.isInSet(u) || !u.some(h => h.type.excludes(n)))
    }
    const {ranges: a} = o;
    return a.some( ({$from: u, $to: f}) => {
        let h = u.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
        return t.doc.nodesBetween(u.pos, f.pos, (p, m, y) => {
            if (h)
                return !1;
            if (p.isInline) {
                const b = !y || y.type.allowsMarkType(n)
                  , C = !!n.isInSet(p.marks) || !p.marks.some(S => S.type.excludes(n));
                h = b && C
            }
            return !h
        }
        ),
        h
    }
    )
}
var vM = (t, e={}) => ({tr: n, state: r, dispatch: o}) => {
    const {selection: l} = n
      , {empty: a, ranges: u} = l
      , f = zr(t, r.schema);
    if (o)
        if (a) {
            const h = t3(r, f);
            n.addStoredMark(f.create({
                ...h,
                ...e
            }))
        } else
            u.forEach(h => {
                const p = h.$from.pos
                  , m = h.$to.pos;
                r.doc.nodesBetween(p, m, (y, b) => {
                    const C = Math.max(b, p)
                      , S = Math.min(b + y.nodeSize, m);
                    y.marks.find(k => k.type === f) ? y.marks.forEach(k => {
                        f === k.type && n.addMark(C, S, f.create({
                            ...k.attrs,
                            ...e
                        }))
                    }
                    ) : n.addMark(C, S, f.create(e))
                }
                )
            }
            );
    return yM(r, n, f)
}
  , bM = (t, e) => ({tr: n}) => (n.setMeta(t, e),
!0)
  , CM = (t, e={}) => ({state: n, dispatch: r, chain: o}) => {
    const l = dt(t, n.schema);
    let a;
    return n.selection.$anchor.sameParent(n.selection.$head) && (a = n.selection.$anchor.parent.attrs),
    l.isTextblock ? o().command( ({commands: u}) => rb(l, {
        ...a,
        ...e
    })(n) ? !0 : u.clearNodes()).command( ({state: u}) => rb(l, {
        ...a,
        ...e
    })(u, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'),
    !1)
}
  , SM = t => ({tr: e, dispatch: n}) => {
    if (n) {
        const {doc: r} = e
          , o = uo(t, 0, r.content.size)
          , l = le.create(r, o);
        e.setSelection(l)
    }
    return !0
}
  , xM = (t, e) => ({tr: n, state: r, dispatch: o}) => {
    const {selection: l} = r;
    let a, u;
    return typeof e == "number" ? (a = e,
    u = e) : e && "from"in e && "to"in e ? (a = e.from,
    u = e.to) : (a = l.from,
    u = l.to),
    o && n.doc.nodesBetween(a, u, (f, h) => {
        f.isText || n.setNodeMarkup(h, void 0, {
            ...f.attrs,
            dir: t
        })
    }
    ),
    !0
}
  , wM = t => ({tr: e, dispatch: n}) => {
    if (n) {
        const {doc: r} = e
          , {from: o, to: l} = typeof t == "number" ? {
            from: t,
            to: t
        } : t
          , a = se.atStart(r).from
          , u = se.atEnd(r).to
          , f = uo(o, a, u)
          , h = uo(l, a, u)
          , p = se.create(r, f, h);
        e.setSelection(p)
    }
    return !0
}
  , EM = t => ({state: e, dispatch: n}) => {
    const r = dt(t, e.schema);
    return v6(r)(e, n)
}
;
function Fb(t, e) {
    const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
    if (n) {
        const r = n.filter(o => e?.includes(o.type.name));
        t.tr.ensureMarks(r)
    }
}
var TM = ({keepMarks: t=!0}={}) => ({tr: e, state: n, dispatch: r, editor: o}) => {
    const {selection: l, doc: a} = e
      , {$from: u, $to: f} = l
      , h = o.extensionManager.attributes
      , p = bu(h, u.node().type.name, u.node().attrs);
    if (l instanceof le && l.node.isBlock)
        return !u.parentOffset || !Ar(a, u.pos) ? !1 : (r && (t && Fb(n, o.extensionManager.splittableMarks),
        e.split(u.pos).scrollIntoView()),
        !0);
    if (!u.parent.isBlock)
        return !1;
    const m = f.parentOffset === f.parent.content.size
      , y = u.depth === 0 ? void 0 : eM(u.node(-1).contentMatchAt(u.indexAfter(-1)));
    let b = m && y ? [{
        type: y,
        attrs: p
    }] : void 0
      , C = Ar(e.doc, e.mapping.map(u.pos), 1, b);
    if (!b && !C && Ar(e.doc, e.mapping.map(u.pos), 1, y ? [{
        type: y
    }] : void 0) && (C = !0,
    b = y ? [{
        type: y,
        attrs: p
    }] : void 0),
    r) {
        if (C && (l instanceof se && e.deleteSelection(),
        e.split(e.mapping.map(u.pos), 1, b),
        y && !m && !u.parentOffset && u.parent.type !== y)) {
            const S = e.mapping.map(u.before())
              , w = e.doc.resolve(S);
            u.node(-1).canReplaceWith(w.index(), w.index() + 1, y) && e.setNodeMarkup(e.mapping.map(u.before()), y)
        }
        t && Fb(n, o.extensionManager.splittableMarks),
        e.scrollIntoView()
    }
    return C
}
  , kM = (t, e={}) => ({tr: n, state: r, dispatch: o, editor: l}) => {
    var a;
    const u = dt(t, r.schema)
      , {$from: f, $to: h} = r.selection
      , p = r.selection.node;
    if (p && p.isBlock || f.depth < 2 || !f.sameParent(h))
        return !1;
    const m = f.node(-1);
    if (m.type !== u)
        return !1;
    const y = l.extensionManager.attributes;
    if (f.parent.content.size === 0 && f.node(-1).childCount === f.indexAfter(-1)) {
        if (f.depth === 2 || f.node(-3).type !== u || f.index(-2) !== f.node(-2).childCount - 1)
            return !1;
        if (o) {
            let k = Z.empty;
            const A = f.index(-1) ? 1 : f.index(-2) ? 2 : 3;
            for (let W = f.depth - A; W >= f.depth - 3; W -= 1)
                k = Z.from(f.node(W).copy(k));
            const O = f.indexAfter(-1) < f.node(-2).childCount ? 1 : f.indexAfter(-2) < f.node(-3).childCount ? 2 : 3
              , B = {
                ...bu(y, f.node().type.name, f.node().attrs),
                ...e
            }
              , z = ((a = u.contentMatch.defaultType) == null ? void 0 : a.createAndFill(B)) || void 0;
            k = k.append(Z.from(u.createAndFill(null, z) || void 0));
            const $ = f.before(f.depth - (A - 1));
            n.replace($, f.after(-O), new te(k,4 - A,0));
            let _ = -1;
            n.doc.nodesBetween($, n.doc.content.size, (W, ne) => {
                if (_ > -1)
                    return !1;
                W.isTextblock && W.content.size === 0 && (_ = ne + 1)
            }
            ),
            _ > -1 && n.setSelection(se.near(n.doc.resolve(_))),
            n.scrollIntoView()
        }
        return !0
    }
    const b = h.pos === f.end() ? m.contentMatchAt(0).defaultType : null
      , C = {
        ...bu(y, m.type.name, m.attrs),
        ...e
    }
      , S = {
        ...bu(y, f.node().type.name, f.node().attrs),
        ...e
    };
    n.delete(f.pos, h.pos);
    const w = b ? [{
        type: u,
        attrs: C
    }, {
        type: b,
        attrs: S
    }] : [{
        type: u,
        attrs: C
    }];
    if (!Ar(n.doc, f.pos, 2))
        return !1;
    if (o) {
        const {selection: k, storedMarks: A} = r
          , {splittableMarks: O} = l.extensionManager
          , B = A || k.$to.parentOffset && k.$from.marks();
        if (n.split(f.pos, 2, w).scrollIntoView(),
        !B || !o)
            return !0;
        const z = B.filter($ => O.includes($.type.name));
        n.ensureMarks(z)
    }
    return !0
}
  , Ip = (t, e) => {
    const n = Hf(a => a.type === e)(t.selection);
    if (!n)
        return !0;
    const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
    if (r === void 0)
        return !0;
    const o = t.doc.nodeAt(r);
    return n.node.type === o?.type && Di(t.doc, n.pos) && t.join(n.pos),
    !0
}
  , Vp = (t, e) => {
    const n = Hf(a => a.type === e)(t.selection);
    if (!n)
        return !0;
    const r = t.doc.resolve(n.start).after(n.depth);
    if (r === void 0)
        return !0;
    const o = t.doc.nodeAt(r);
    return n.node.type === o?.type && Di(t.doc, r) && t.join(r),
    !0
}
  , MM = (t, e, n, r={}) => ({editor: o, tr: l, state: a, dispatch: u, chain: f, commands: h, can: p}) => {
    const {extensions: m, splittableMarks: y} = o.extensionManager
      , b = dt(t, a.schema)
      , C = dt(e, a.schema)
      , {selection: S, storedMarks: w} = a
      , {$from: k, $to: A} = S
      , O = k.blockRange(A)
      , B = w || S.$to.parentOffset && S.$from.marks();
    if (!O)
        return !1;
    const z = Hf($ => $b($.type.name, m))(S);
    if (O.depth >= 1 && z && O.depth - z.depth <= 1) {
        if (z.node.type === b)
            return h.liftListItem(C);
        if ($b(z.node.type.name, m) && b.validContent(z.node.content) && u)
            return f().command( () => (l.setNodeMarkup(z.pos, b),
            !0)).command( () => Ip(l, b)).command( () => Vp(l, b)).run()
    }
    return !n || !B || !u ? f().command( () => p().wrapInList(b, r) ? !0 : h.clearNodes()).wrapInList(b, r).command( () => Ip(l, b)).command( () => Vp(l, b)).run() : f().command( () => {
        const $ = p().wrapInList(b, r)
          , _ = B.filter(W => y.includes(W.type.name));
        return l.ensureMarks(_),
        $ ? !0 : h.clearNodes()
    }
    ).wrapInList(b, r).command( () => Ip(l, b)).command( () => Vp(l, b)).run()
}
  , AM = (t, e={}, n={}) => ({state: r, commands: o}) => {
    const {extendEmptyMarkRange: l=!1} = n
      , a = zr(t, r.schema);
    return Lm(r, a, e) ? o.unsetMark(a, {
        extendEmptyMarkRange: l
    }) : o.setMark(a, e)
}
  , NM = (t, e, n={}) => ({state: r, commands: o}) => {
    const l = dt(t, r.schema)
      , a = dt(e, r.schema)
      , u = Ni(r, l, n);
    let f;
    return r.selection.$anchor.sameParent(r.selection.$head) && (f = r.selection.$anchor.parent.attrs),
    u ? o.setNode(a, f) : o.setNode(l, {
        ...f,
        ...n
    })
}
  , RM = (t, e={}) => ({state: n, commands: r}) => {
    const o = dt(t, n.schema);
    return Ni(n, o, e) ? r.lift(o) : r.wrapIn(o, e)
}
  , OM = () => ({state: t, dispatch: e}) => {
    const n = t.plugins;
    for (let r = 0; r < n.length; r += 1) {
        const o = n[r];
        let l;
        if (o.spec.isInputRules && (l = o.getState(t))) {
            if (e) {
                const a = t.tr
                  , u = l.transform;
                for (let f = u.steps.length - 1; f >= 0; f -= 1)
                    a.step(u.steps[f].invert(u.docs[f]));
                if (l.text) {
                    const f = a.doc.resolve(l.from).marks();
                    a.replaceWith(l.from, l.to, t.schema.text(l.text, f))
                } else
                    a.delete(l.from, l.to)
            }
            return !0
        }
    }
    return !1
}
  , DM = () => ({tr: t, dispatch: e}) => {
    const {selection: n} = t
      , {empty: r, ranges: o} = n;
    return r || e && o.forEach(l => {
        t.removeMark(l.$from.pos, l.$to.pos)
    }
    ),
    !0
}
  , LM = (t, e={}) => ({tr: n, state: r, dispatch: o}) => {
    var l;
    const {extendEmptyMarkRange: a=!1} = e
      , {selection: u} = n
      , f = zr(t, r.schema)
      , {$from: h, empty: p, ranges: m} = u;
    if (!o)
        return !0;
    if (p && a) {
        let {from: y, to: b} = u;
        const C = (l = h.marks().find(w => w.type === f)) == null ? void 0 : l.attrs
          , S = j1(h, f, C);
        S && (y = S.from,
        b = S.to),
        n.removeMark(y, b, f)
    } else
        m.forEach(y => {
            n.removeMark(y.$from.pos, y.$to.pos, f)
        }
        );
    return n.removeStoredMark(f),
    !0
}
  , zM = t => ({tr: e, state: n, dispatch: r}) => {
    const {selection: o} = n;
    let l, a;
    return typeof t == "number" ? (l = t,
    a = t) : t && "from"in t && "to"in t ? (l = t.from,
    a = t.to) : (l = o.from,
    a = o.to),
    r && e.doc.nodesBetween(l, a, (u, f) => {
        if (u.isText)
            return;
        const h = {
            ...u.attrs
        };
        delete h.dir,
        e.setNodeMarkup(f, void 0, h)
    }
    ),
    !0
}
  , _M = (t, e={}) => ({tr: n, state: r, dispatch: o}) => {
    let l = null
      , a = null;
    const u = jf(typeof t == "string" ? t : t.name, r.schema);
    if (!u)
        return !1;
    u === "node" && (l = dt(t, r.schema)),
    u === "mark" && (a = zr(t, r.schema));
    let f = !1;
    return n.selection.ranges.forEach(h => {
        const p = h.$from.pos
          , m = h.$to.pos;
        let y, b, C, S;
        n.selection.empty ? r.doc.nodesBetween(p, m, (w, k) => {
            l && l === w.type && (f = !0,
            C = Math.max(k, p),
            S = Math.min(k + w.nodeSize, m),
            y = k,
            b = w)
        }
        ) : r.doc.nodesBetween(p, m, (w, k) => {
            k < p && l && l === w.type && (f = !0,
            C = Math.max(k, p),
            S = Math.min(k + w.nodeSize, m),
            y = k,
            b = w),
            k >= p && k <= m && (l && l === w.type && (f = !0,
            o && n.setNodeMarkup(k, void 0, {
                ...w.attrs,
                ...e
            })),
            a && w.marks.length && w.marks.forEach(A => {
                if (a === A.type && (f = !0,
                o)) {
                    const O = Math.max(k, p)
                      , B = Math.min(k + w.nodeSize, m);
                    n.addMark(O, B, a.create({
                        ...A.attrs,
                        ...e
                    }))
                }
            }
            ))
        }
        ),
        b && (y !== void 0 && o && n.setNodeMarkup(y, void 0, {
            ...b.attrs,
            ...e
        }),
        a && b.marks.length && b.marks.forEach(w => {
            a === w.type && o && n.addMark(C, S, a.create({
                ...w.attrs,
                ...e
            }))
        }
        ))
    }
    ),
    f
}
  , BM = (t, e={}) => ({state: n, dispatch: r}) => {
    const o = dt(t, n.schema);
    return f6(o, e)(n, r)
}
  , jM = (t, e={}) => ({state: n, dispatch: r}) => {
    const o = dt(t, n.schema);
    return d6(o, e)(n, r)
}
  , HM = class {
    constructor() {
        this.callbacks = {}
    }
    on(t, e) {
        return this.callbacks[t] || (this.callbacks[t] = []),
        this.callbacks[t].push(e),
        this
    }
    emit(t, ...e) {
        const n = this.callbacks[t];
        return n && n.forEach(r => r.apply(this, e)),
        this
    }
    off(t, e) {
        const n = this.callbacks[t];
        return n && (e ? this.callbacks[t] = n.filter(r => r !== e) : delete this.callbacks[t]),
        this
    }
    once(t, e) {
        const n = (...r) => {
            this.off(t, n),
            e.apply(this, r)
        }
        ;
        return this.on(t, n)
    }
    removeAllListeners() {
        this.callbacks = {}
    }
}
  , Vf = class {
    constructor(t) {
        var e;
        this.find = t.find,
        this.handler = t.handler,
        this.undoable = (e = t.undoable) != null ? e : !0
    }
}
  , IM = (t, e) => {
    if (B1(e))
        return e.exec(t);
    const n = e(t);
    if (!n)
        return null;
    const r = [n.text];
    return r.index = n.index,
    r.input = t,
    r.data = n.data,
    n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'),
    r.push(n.replaceWith)),
    r
}
;
function Jc(t) {
    var e;
    const {editor: n, from: r, to: o, text: l, rules: a, plugin: u} = t
      , {view: f} = n;
    if (f.composing)
        return !1;
    const h = f.state.doc.resolve(r);
    if (h.parent.type.spec.code || (e = h.nodeBefore || h.nodeAfter) != null && e.marks.find(y => y.type.spec.code))
        return !1;
    let p = !1;
    const m = fM(h) + l;
    return a.forEach(y => {
        if (p)
            return;
        const b = IM(m, y.find);
        if (!b)
            return;
        const C = f.state.tr
          , S = _f({
            state: f.state,
            transaction: C
        })
          , w = {
            from: r - (b[0].length - l.length),
            to: o
        }
          , {commands: k, chain: A, can: O} = new Bf({
            editor: n,
            state: S
        });
        y.handler({
            state: S,
            range: w,
            match: b,
            commands: k,
            chain: A,
            can: O
        }) === null || !C.steps.length || (y.undoable && C.setMeta(u, {
            transform: C,
            from: r,
            to: o,
            text: l
        }),
        f.dispatch(C),
        p = !0)
    }
    ),
    p
}
function VM(t) {
    const {editor: e, rules: n} = t
      , r = new Ye({
        state: {
            init() {
                return null
            },
            apply(o, l, a) {
                const u = o.getMeta(r);
                if (u)
                    return u;
                const f = o.getMeta("applyInputRules");
                return f && setTimeout( () => {
                    let {text: p} = f;
                    typeof p == "string" ? p = p : p = I1(Z.from(p), a.schema);
                    const {from: m} = f
                      , y = m + p.length;
                    Jc({
                        editor: e,
                        from: m,
                        to: y,
                        text: p,
                        rules: n,
                        plugin: r
                    })
                }
                ),
                o.selectionSet || o.docChanged ? null : l
            }
        },
        props: {
            handleTextInput(o, l, a, u) {
                return Jc({
                    editor: e,
                    from: l,
                    to: a,
                    text: u,
                    rules: n,
                    plugin: r
                })
            },
            handleDOMEvents: {
                compositionend: o => (setTimeout( () => {
                    const {$cursor: l} = o.state.selection;
                    l && Jc({
                        editor: e,
                        from: l.pos,
                        to: l.pos,
                        text: "",
                        rules: n,
                        plugin: r
                    })
                }
                ),
                !1)
            },
            handleKeyDown(o, l) {
                if (l.key !== "Enter")
                    return !1;
                const {$cursor: a} = o.state.selection;
                return a ? Jc({
                    editor: e,
                    from: a.pos,
                    to: a.pos,
                    text: `
`,
                    rules: n,
                    plugin: r
                }) : !1
            }
        },
        isInputRules: !0
    });
    return r
}
function UM(t) {
    return Object.prototype.toString.call(t).slice(8, -1)
}
function Qc(t) {
    return UM(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype
}
function p3(t, e) {
    const n = {
        ...t
    };
    return Qc(t) && Qc(e) && Object.keys(e).forEach(r => {
        Qc(e[r]) && Qc(t[r]) ? n[r] = p3(t[r], e[r]) : n[r] = e[r]
    }
    ),
    n
}
var U1 = class {
    constructor(t={}) {
        this.type = "extendable",
        this.parent = null,
        this.child = null,
        this.name = "",
        this.config = {
            name: this.name
        },
        this.config = {
            ...this.config,
            ...t
        },
        this.name = this.config.name
    }
    get options() {
        return {
            ...Le(fe(this, "addOptions", {
                name: this.name
            })) || {}
        }
    }
    get storage() {
        return {
            ...Le(fe(this, "addStorage", {
                name: this.name,
                options: this.options
            })) || {}
        }
    }
    configure(t={}) {
        const e = this.extend({
            ...this.config,
            addOptions: () => p3(this.options, t)
        });
        return e.name = this.name,
        e.parent = this.parent,
        e
    }
    extend(t={}) {
        const e = new this.constructor({
            ...this.config,
            ...t
        });
        return e.parent = this,
        this.child = e,
        e.name = "name"in t ? t.name : e.parent.name,
        e
    }
}
  , Mo = class m3 extends U1 {
    constructor() {
        super(...arguments),
        this.type = "mark"
    }
    static create(e={}) {
        const n = typeof e == "function" ? e() : e;
        return new m3(n)
    }
    static handleExit({editor: e, mark: n}) {
        const {tr: r} = e.state
          , o = e.state.selection.$from;
        if (o.pos === o.end()) {
            const a = o.marks();
            if (!!!a.find(h => h?.type.name === n.name))
                return !1;
            const f = a.find(h => h?.type.name === n.name);
            return f && r.removeStoredMark(f),
            r.insertText(" ", o.pos),
            e.view.dispatch(r),
            !0
        }
        return !1
    }
    configure(e) {
        return super.configure(e)
    }
    extend(e) {
        const n = typeof e == "function" ? e() : e;
        return super.extend(n)
    }
}
;
function PM(t) {
    return typeof t == "number"
}
var qM = class {
    constructor(t) {
        this.find = t.find,
        this.handler = t.handler
    }
}
  , $M = (t, e, n) => {
    if (B1(e))
        return [...t.matchAll(e)];
    const r = e(t, n);
    return r ? r.map(o => {
        const l = [o.text];
        return l.index = o.index,
        l.input = t,
        l.data = o.data,
        o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'),
        l.push(o.replaceWith)),
        l
    }
    ) : []
}
;
function FM(t) {
    const {editor: e, state: n, from: r, to: o, rule: l, pasteEvent: a, dropEvent: u} = t
      , {commands: f, chain: h, can: p} = new Bf({
        editor: e,
        state: n
    })
      , m = [];
    return n.doc.nodesBetween(r, o, (b, C) => {
        var S, w, k, A, O;
        if ((w = (S = b.type) == null ? void 0 : S.spec) != null && w.code || !(b.isText || b.isTextblock || b.isInline))
            return;
        const B = (O = (A = (k = b.content) == null ? void 0 : k.size) != null ? A : b.nodeSize) != null ? O : 0
          , z = Math.max(r, C)
          , $ = Math.min(o, C + B);
        if (z >= $)
            return;
        const _ = b.isText ? b.text || "" : b.textBetween(z - C, $ - C, void 0, "");
        $M(_, l.find, a).forEach(ne => {
            if (ne.index === void 0)
                return;
            const de = z + ne.index + 1
              , ve = de + ne[0].length
              , pe = {
                from: n.tr.mapping.map(de),
                to: n.tr.mapping.map(ve)
            }
              , be = l.handler({
                state: n,
                range: pe,
                match: ne,
                commands: f,
                chain: h,
                can: p,
                pasteEvent: a,
                dropEvent: u
            });
            m.push(be)
        }
        )
    }
    ),
    m.every(b => b !== null)
}
var eu = null
  , KM = t => {
    var e;
    const n = new ClipboardEvent("paste",{
        clipboardData: new DataTransfer
    });
    return (e = n.clipboardData) == null || e.setData("text/html", t),
    n
}
;
function GM(t) {
    const {editor: e, rules: n} = t;
    let r = null, o = !1, l = !1, a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, u;
    try {
        u = typeof DragEvent < "u" ? new DragEvent("drop") : null
    } catch {
        u = null
    }
    const f = ({state: p, from: m, to: y, rule: b, pasteEvt: C}) => {
        const S = p.tr
          , w = _f({
            state: p,
            transaction: S
        });
        if (!(!FM({
            editor: e,
            state: w,
            from: Math.max(m - 1, 0),
            to: y.b - 1,
            rule: b,
            pasteEvent: C,
            dropEvent: u
        }) || !S.steps.length)) {
            try {
                u = typeof DragEvent < "u" ? new DragEvent("drop") : null
            } catch {
                u = null
            }
            return a = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null,
            S
        }
    }
    ;
    return n.map(p => new Ye({
        view(m) {
            const y = C => {
                var S;
                r = (S = m.dom.parentElement) != null && S.contains(C.target) ? m.dom.parentElement : null,
                r && (eu = e)
            }
              , b = () => {
                eu && (eu = null)
            }
            ;
            return window.addEventListener("dragstart", y),
            window.addEventListener("dragend", b),
            {
                destroy() {
                    window.removeEventListener("dragstart", y),
                    window.removeEventListener("dragend", b)
                }
            }
        },
        props: {
            handleDOMEvents: {
                drop: (m, y) => {
                    if (l = r === m.dom.parentElement,
                    u = y,
                    !l) {
                        const b = eu;
                        b?.isEditable && setTimeout( () => {
                            const C = b.state.selection;
                            C && b.commands.deleteRange({
                                from: C.from,
                                to: C.to
                            })
                        }
                        , 10)
                    }
                    return !1
                }
                ,
                paste: (m, y) => {
                    var b;
                    const C = (b = y.clipboardData) == null ? void 0 : b.getData("text/html");
                    return a = y,
                    o = !!C?.includes("data-pm-slice"),
                    !1
                }
            }
        },
        appendTransaction: (m, y, b) => {
            const C = m[0]
              , S = C.getMeta("uiEvent") === "paste" && !o
              , w = C.getMeta("uiEvent") === "drop" && !l
              , k = C.getMeta("applyPasteRules")
              , A = !!k;
            if (!S && !w && !A)
                return;
            if (A) {
                let {text: z} = k;
                typeof z == "string" ? z = z : z = I1(Z.from(z), b.schema);
                const {from: $} = k
                  , _ = $ + z.length
                  , W = KM(z);
                return f({
                    rule: p,
                    state: b,
                    from: $,
                    to: {
                        b: _
                    },
                    pasteEvt: W
                })
            }
            const O = y.doc.content.findDiffStart(b.doc.content)
              , B = y.doc.content.findDiffEnd(b.doc.content);
            if (!(!PM(O) || !B || O === B.b))
                return f({
                    rule: p,
                    state: b,
                    from: O,
                    to: B,
                    pasteEvt: a
                })
        }
    }))
}
var Uf = class {
    constructor(t, e) {
        this.splittableMarks = [],
        this.editor = e,
        this.baseExtensions = t,
        this.extensions = l3(t),
        this.schema = iM(this.extensions, e),
        this.setupExtensions()
    }
    get commands() {
        return this.extensions.reduce( (t, e) => {
            const n = {
                name: e.name,
                options: e.options,
                storage: this.editor.extensionStorage[e.name],
                editor: this.editor,
                type: Xc(e.name, this.schema)
            }
              , r = fe(e, "addCommands", n);
            return r ? {
                ...t,
                ...r()
            } : t
        }
        , {})
    }
    get plugins() {
        const {editor: t} = this;
        return Uu([...this.extensions].reverse()).flatMap(r => {
            const o = {
                name: r.name,
                options: r.options,
                storage: this.editor.extensionStorage[r.name],
                editor: t,
                type: Xc(r.name, this.schema)
            }
              , l = []
              , a = fe(r, "addKeyboardShortcuts", o);
            let u = {};
            if (r.type === "mark" && fe(r, "exitable", o) && (u.ArrowRight = () => Mo.handleExit({
                editor: t,
                mark: r
            })),
            a) {
                const y = Object.fromEntries(Object.entries(a()).map( ([b,C]) => [b, () => C({
                    editor: t
                })]));
                u = {
                    ...u,
                    ...y
                }
            }
            const f = ak(u);
            l.push(f);
            const h = fe(r, "addInputRules", o);
            if (qb(r, t.options.enableInputRules) && h) {
                const y = h();
                if (y && y.length) {
                    const b = VM({
                        editor: t,
                        rules: y
                    })
                      , C = Array.isArray(b) ? b : [b];
                    l.push(...C)
                }
            }
            const p = fe(r, "addPasteRules", o);
            if (qb(r, t.options.enablePasteRules) && p) {
                const y = p();
                if (y && y.length) {
                    const b = GM({
                        editor: t,
                        rules: y
                    });
                    l.push(...b)
                }
            }
            const m = fe(r, "addProseMirrorPlugins", o);
            if (m) {
                const y = m();
                l.push(...y)
            }
            return l
        }
        )
    }
    get attributes() {
        return o3(this.extensions)
    }
    get nodeViews() {
        const {editor: t} = this
          , {nodeExtensions: e} = _l(this.extensions);
        return Object.fromEntries(e.filter(n => !!fe(n, "addNodeView")).map(n => {
            const r = this.attributes.filter(f => f.type === n.name)
              , o = {
                name: n.name,
                options: n.options,
                storage: this.editor.extensionStorage[n.name],
                editor: t,
                type: dt(n.name, this.schema)
            }
              , l = fe(n, "addNodeView", o);
            if (!l)
                return [];
            const a = l();
            if (!a)
                return [];
            const u = (f, h, p, m, y) => {
                const b = ga(f, r);
                return a({
                    node: f,
                    view: h,
                    getPos: p,
                    decorations: m,
                    innerDecorations: y,
                    editor: t,
                    extension: n,
                    HTMLAttributes: b
                })
            }
            ;
            return [n.name, u]
        }
        ))
    }
    dispatchTransaction(t) {
        const {editor: e} = this;
        return Uu([...this.extensions].reverse()).reduceRight( (r, o) => {
            const l = {
                name: o.name,
                options: o.options,
                storage: this.editor.extensionStorage[o.name],
                editor: e,
                type: Xc(o.name, this.schema)
            }
              , a = fe(o, "dispatchTransaction", l);
            return a ? u => {
                a.call(l, {
                    transaction: u,
                    next: r
                })
            }
            : r
        }
        , t)
    }
    get markViews() {
        const {editor: t} = this
          , {markExtensions: e} = _l(this.extensions);
        return Object.fromEntries(e.filter(n => !!fe(n, "addMarkView")).map(n => {
            const r = this.attributes.filter(u => u.type === n.name)
              , o = {
                name: n.name,
                options: n.options,
                storage: this.editor.extensionStorage[n.name],
                editor: t,
                type: zr(n.name, this.schema)
            }
              , l = fe(n, "addMarkView", o);
            if (!l)
                return [];
            const a = (u, f, h) => {
                const p = ga(u, r);
                return l()({
                    mark: u,
                    view: f,
                    inline: h,
                    editor: t,
                    extension: n,
                    HTMLAttributes: p,
                    updateAttributes: m => {
                        sA(u, t, m)
                    }
                })
            }
            ;
            return [n.name, a]
        }
        ))
    }
    setupExtensions() {
        const t = this.extensions;
        this.editor.extensionStorage = Object.fromEntries(t.map(e => [e.name, e.storage])),
        t.forEach(e => {
            var n;
            const r = {
                name: e.name,
                options: e.options,
                storage: this.editor.extensionStorage[e.name],
                editor: this.editor,
                type: Xc(e.name, this.schema)
            };
            e.type === "mark" && ((n = Le(fe(e, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(e.name);
            const o = fe(e, "onBeforeCreate", r)
              , l = fe(e, "onCreate", r)
              , a = fe(e, "onUpdate", r)
              , u = fe(e, "onSelectionUpdate", r)
              , f = fe(e, "onTransaction", r)
              , h = fe(e, "onFocus", r)
              , p = fe(e, "onBlur", r)
              , m = fe(e, "onDestroy", r);
            o && this.editor.on("beforeCreate", o),
            l && this.editor.on("create", l),
            a && this.editor.on("update", a),
            u && this.editor.on("selectionUpdate", u),
            f && this.editor.on("transaction", f),
            h && this.editor.on("focus", h),
            p && this.editor.on("blur", p),
            m && this.editor.on("destroy", m)
        }
        )
    }
}
;
Uf.resolve = l3;
Uf.sort = Uu;
Uf.flatten = H1;
var YM = {};
_1(YM, {
    ClipboardTextSerializer: () => y3,
    Commands: () => v3,
    Delete: () => b3,
    Drop: () => C3,
    Editable: () => S3,
    FocusEvents: () => w3,
    Keymap: () => E3,
    Paste: () => T3,
    Tabindex: () => k3,
    TextDirection: () => M3,
    focusEventsPluginKey: () => x3
});
var rt = class g3 extends U1 {
    constructor() {
        super(...arguments),
        this.type = "extension"
    }
    static create(e={}) {
        const n = typeof e == "function" ? e() : e;
        return new g3(n)
    }
    configure(e) {
        return super.configure(e)
    }
    extend(e) {
        const n = typeof e == "function" ? e() : e;
        return super.extend(n)
    }
}
  , y3 = rt.create({
    name: "clipboardTextSerializer",
    addOptions() {
        return {
            blockSeparator: void 0
        }
    },
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("clipboardTextSerializer"),
            props: {
                clipboardTextSerializer: () => {
                    const {editor: t} = this
                      , {state: e, schema: n} = t
                      , {doc: r, selection: o} = e
                      , {ranges: l} = o
                      , a = Math.min(...l.map(p => p.$from.pos))
                      , u = Math.max(...l.map(p => p.$to.pos))
                      , f = a3(n);
                    return s3(r, {
                        from: a,
                        to: u
                    }, {
                        ...this.options.blockSeparator !== void 0 ? {
                            blockSeparator: this.options.blockSeparator
                        } : {},
                        textSerializers: f
                    })
                }
            }
        })]
    }
})
  , v3 = rt.create({
    name: "commands",
    addCommands() {
        return {
            ...Zx
        }
    }
})
  , b3 = rt.create({
    name: "delete",
    onUpdate({transaction: t, appendedTransactions: e}) {
        var n, r, o;
        const l = () => {
            var a, u, f, h;
            if ((h = (f = (u = (a = this.editor.options.coreExtensionOptions) == null ? void 0 : a.delete) == null ? void 0 : u.filterTransaction) == null ? void 0 : f.call(u, t)) != null ? h : t.getMeta("y-sync$"))
                return;
            const p = n3(t.before, [t, ...e]);
            u3(p).forEach(b => {
                p.mapping.mapResult(b.oldRange.from).deletedAfter && p.mapping.mapResult(b.oldRange.to).deletedBefore && p.before.nodesBetween(b.oldRange.from, b.oldRange.to, (C, S) => {
                    const w = S + C.nodeSize - 2
                      , k = b.oldRange.from <= S && w <= b.oldRange.to;
                    this.editor.emit("delete", {
                        type: "node",
                        node: C,
                        from: S,
                        to: w,
                        newFrom: p.mapping.map(S),
                        newTo: p.mapping.map(w),
                        deletedRange: b.oldRange,
                        newRange: b.newRange,
                        partial: !k,
                        editor: this.editor,
                        transaction: t,
                        combinedTransform: p
                    })
                }
                )
            }
            );
            const y = p.mapping;
            p.steps.forEach( (b, C) => {
                var S, w;
                if (b instanceof _n) {
                    const k = y.slice(C).map(b.from, -1)
                      , A = y.slice(C).map(b.to)
                      , O = y.invert().map(k, -1)
                      , B = y.invert().map(A)
                      , z = (S = p.doc.nodeAt(k - 1)) == null ? void 0 : S.marks.some(_ => _.eq(b.mark))
                      , $ = (w = p.doc.nodeAt(A)) == null ? void 0 : w.marks.some(_ => _.eq(b.mark));
                    this.editor.emit("delete", {
                        type: "mark",
                        mark: b.mark,
                        from: b.from,
                        to: b.to,
                        deletedRange: {
                            from: O,
                            to: B
                        },
                        newRange: {
                            from: k,
                            to: A
                        },
                        partial: !!($ || z),
                        editor: this.editor,
                        transaction: t,
                        combinedTransform: p
                    })
                }
            }
            )
        }
        ;
        (o = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || o ? setTimeout(l, 0) : l()
    }
})
  , C3 = rt.create({
    name: "drop",
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("tiptapDrop"),
            props: {
                handleDrop: (t, e, n, r) => {
                    this.editor.emit("drop", {
                        editor: this.editor,
                        event: e,
                        slice: n,
                        moved: r
                    })
                }
            }
        })]
    }
})
  , S3 = rt.create({
    name: "editable",
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("editable"),
            props: {
                editable: () => this.editor.options.editable
            }
        })]
    }
})
  , x3 = new nt("focusEvents")
  , w3 = rt.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
        const {editor: t} = this;
        return [new Ye({
            key: x3,
            props: {
                handleDOMEvents: {
                    focus: (e, n) => {
                        t.isFocused = !0;
                        const r = t.state.tr.setMeta("focus", {
                            event: n
                        }).setMeta("addToHistory", !1);
                        return e.dispatch(r),
                        !1
                    }
                    ,
                    blur: (e, n) => {
                        t.isFocused = !1;
                        const r = t.state.tr.setMeta("blur", {
                            event: n
                        }).setMeta("addToHistory", !1);
                        return e.dispatch(r),
                        !1
                    }
                }
            }
        })]
    }
})
  , E3 = rt.create({
    name: "keymap",
    addKeyboardShortcuts() {
        const t = () => this.editor.commands.first( ({commands: a}) => [ () => a.undoInputRule(), () => a.command( ({tr: u}) => {
            const {selection: f, doc: h} = u
              , {empty: p, $anchor: m} = f
              , {pos: y, parent: b} = m
              , C = m.parent.isTextblock && y > 0 ? u.doc.resolve(y - 1) : m
              , S = C.parent.type.spec.isolating
              , w = m.pos - m.parentOffset
              , k = S && C.parent.childCount === 1 ? w === m.pos : ye.atStart(h).from === y;
            return !p || !b.type.isTextblock || b.textContent.length || !k || k && m.parent.type.name === "paragraph" ? !1 : a.clearNodes()
        }
        ), () => a.deleteSelection(), () => a.joinBackward(), () => a.selectNodeBackward()])
          , e = () => this.editor.commands.first( ({commands: a}) => [ () => a.deleteSelection(), () => a.deleteCurrentNode(), () => a.joinForward(), () => a.selectNodeForward()])
          , r = {
            Enter: () => this.editor.commands.first( ({commands: a}) => [ () => a.newlineInCode(), () => a.createParagraphNear(), () => a.liftEmptyBlock(), () => a.splitBlock()]),
            "Mod-Enter": () => this.editor.commands.exitCode(),
            Backspace: t,
            "Mod-Backspace": t,
            "Shift-Backspace": t,
            Delete: e,
            "Mod-Delete": e,
            "Mod-a": () => this.editor.commands.selectAll()
        }
          , o = {
            ...r
        }
          , l = {
            ...r,
            "Ctrl-h": t,
            "Alt-Backspace": t,
            "Ctrl-d": e,
            "Ctrl-Alt-Backspace": e,
            "Alt-Delete": e,
            "Alt-d": e,
            "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
            "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
        };
        return Vu() || e3() ? l : o
    },
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("clearDocument"),
            appendTransaction: (t, e, n) => {
                if (t.some(S => S.getMeta("composition")))
                    return;
                const r = t.some(S => S.docChanged) && !e.doc.eq(n.doc)
                  , o = t.some(S => S.getMeta("preventClearDocument"));
                if (!r || o)
                    return;
                const {empty: l, from: a, to: u} = e.selection
                  , f = ye.atStart(e.doc).from
                  , h = ye.atEnd(e.doc).to;
                if (l || !(a === f && u === h) || !If(n.doc))
                    return;
                const y = n.tr
                  , b = _f({
                    state: n,
                    transaction: y
                })
                  , {commands: C} = new Bf({
                    editor: this.editor,
                    state: b
                });
                if (C.clearNodes(),
                !!y.steps.length)
                    return y
            }
        })]
    }
})
  , T3 = rt.create({
    name: "paste",
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("tiptapPaste"),
            props: {
                handlePaste: (t, e, n) => {
                    this.editor.emit("paste", {
                        editor: this.editor,
                        event: e,
                        slice: n
                    })
                }
            }
        })]
    }
})
  , k3 = rt.create({
    name: "tabindex",
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("tabindex"),
            props: {
                attributes: () => this.editor.isEditable ? {
                    tabindex: "0"
                } : {}
            }
        })]
    }
})
  , M3 = rt.create({
    name: "textDirection",
    addOptions() {
        return {
            direction: void 0
        }
    },
    addGlobalAttributes() {
        if (!this.options.direction)
            return [];
        const {nodeExtensions: t} = _l(this.extensions);
        return [{
            types: t.filter(e => e.name !== "text").map(e => e.name),
            attributes: {
                dir: {
                    default: this.options.direction,
                    parseHTML: e => {
                        const n = e.getAttribute("dir");
                        return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction
                    }
                    ,
                    renderHTML: e => e.dir ? {
                        dir: e.dir
                    } : {}
                }
            }
        }]
    },
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("textDirection"),
            props: {
                attributes: () => {
                    const t = this.options.direction;
                    return t ? {
                        dir: t
                    } : {}
                }
            }
        })]
    }
})
  , ZM = class Gs {
    constructor(e, n, r=!1, o=null) {
        this.currentNode = null,
        this.actualDepth = null,
        this.isBlock = r,
        this.resolvedPos = e,
        this.editor = n,
        this.currentNode = o
    }
    get name() {
        return this.node.type.name
    }
    get node() {
        return this.currentNode || this.resolvedPos.node()
    }
    get element() {
        return this.editor.view.domAtPos(this.pos).node
    }
    get depth() {
        var e;
        return (e = this.actualDepth) != null ? e : this.resolvedPos.depth
    }
    get pos() {
        return this.resolvedPos.pos
    }
    get content() {
        return this.node.content
    }
    set content(e) {
        let n = this.from
          , r = this.to;
        if (this.isBlock) {
            if (this.content.size === 0) {
                console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
                return
            }
            n = this.from + 1,
            r = this.to - 1
        }
        this.editor.commands.insertContentAt({
            from: n,
            to: r
        }, e)
    }
    get attributes() {
        return this.node.attrs
    }
    get textContent() {
        return this.node.textContent
    }
    get size() {
        return this.node.nodeSize
    }
    get from() {
        return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth)
    }
    get range() {
        return {
            from: this.from,
            to: this.to
        }
    }
    get to() {
        return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)
    }
    get parent() {
        if (this.depth === 0)
            return null;
        const e = this.resolvedPos.start(this.resolvedPos.depth - 1)
          , n = this.resolvedPos.doc.resolve(e);
        return new Gs(n,this.editor)
    }
    get before() {
        let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)),
        new Gs(e,this.editor)
    }
    get after() {
        let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
        return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)),
        new Gs(e,this.editor)
    }
    get children() {
        const e = [];
        return this.node.content.forEach( (n, r) => {
            const o = n.isBlock && !n.isTextblock
              , l = n.isAtom && !n.isText
              , a = n.isInline
              , u = this.pos + r + (l ? 0 : 1);
            if (u < 0 || u > this.resolvedPos.doc.nodeSize - 2)
                return;
            const f = this.resolvedPos.doc.resolve(u);
            if (!o && !a && f.depth <= this.depth)
                return;
            const h = new Gs(f,this.editor,o,o || a ? n : null);
            o && (h.actualDepth = this.depth + 1),
            e.push(h)
        }
        ),
        e
    }
    get firstChild() {
        return this.children[0] || null
    }
    get lastChild() {
        const e = this.children;
        return e[e.length - 1] || null
    }
    closest(e, n={}) {
        let r = null
          , o = this.parent;
        for (; o && !r; ) {
            if (o.node.type.name === e)
                if (Object.keys(n).length > 0) {
                    const l = o.node.attrs
                      , a = Object.keys(n);
                    for (let u = 0; u < a.length; u += 1) {
                        const f = a[u];
                        if (l[f] !== n[f])
                            break
                    }
                } else
                    r = o;
            o = o.parent
        }
        return r
    }
    querySelector(e, n={}) {
        return this.querySelectorAll(e, n, !0)[0] || null
    }
    querySelectorAll(e, n={}, r=!1) {
        let o = [];
        if (!this.children || this.children.length === 0)
            return o;
        const l = Object.keys(n);
        return this.children.forEach(a => {
            r && o.length > 0 || (a.node.type.name === e && l.every(f => n[f] === a.node.attrs[f]) && o.push(a),
            !(r && o.length > 0) && (o = o.concat(a.querySelectorAll(e, n, r))))
        }
        ),
        o
    }
    setAttribute(e) {
        const {tr: n} = this.editor.state;
        n.setNodeMarkup(this.from, void 0, {
            ...this.node.attrs,
            ...e
        }),
        this.editor.view.dispatch(n)
    }
}
  , WM = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function XM(t, e, n) {
    const r = document.querySelector("style[data-tiptap-style]");
    if (r !== null)
        return r;
    const o = document.createElement("style");
    return e && o.setAttribute("nonce", e),
    o.setAttribute("data-tiptap-style", ""),
    o.innerHTML = t,
    document.getElementsByTagName("head")[0].appendChild(o),
    o
}
var JM = class extends HM {
    constructor(e={}) {
        super(),
        this.css = null,
        this.className = "tiptap",
        this.editorView = null,
        this.isFocused = !1,
        this.isInitialized = !1,
        this.extensionStorage = {},
        this.instanceId = Math.random().toString(36).slice(2, 9),
        this.options = {
            element: typeof document < "u" ? document.createElement("div") : null,
            content: "",
            injectCSS: !0,
            injectNonce: void 0,
            extensions: [],
            autofocus: !1,
            editable: !0,
            textDirection: void 0,
            editorProps: {},
            parseOptions: {},
            coreExtensionOptions: {},
            enableInputRules: !0,
            enablePasteRules: !0,
            enableCoreExtensions: !0,
            enableContentCheck: !1,
            emitContentError: !1,
            onBeforeCreate: () => null,
            onCreate: () => null,
            onMount: () => null,
            onUnmount: () => null,
            onUpdate: () => null,
            onSelectionUpdate: () => null,
            onTransaction: () => null,
            onFocus: () => null,
            onBlur: () => null,
            onDestroy: () => null,
            onContentError: ({error: o}) => {
                throw o
            }
            ,
            onPaste: () => null,
            onDrop: () => null,
            onDelete: () => null,
            enableExtensionDispatchTransaction: !0
        },
        this.isCapturingTransaction = !1,
        this.capturedTransaction = null,
        this.utils = {
            getUpdatedPosition: mM,
            createMappablePosition: gM
        },
        this.setOptions(e),
        this.createExtensionManager(),
        this.createCommandManager(),
        this.createSchema(),
        this.on("beforeCreate", this.options.onBeforeCreate),
        this.emit("beforeCreate", {
            editor: this
        }),
        this.on("mount", this.options.onMount),
        this.on("unmount", this.options.onUnmount),
        this.on("contentError", this.options.onContentError),
        this.on("create", this.options.onCreate),
        this.on("update", this.options.onUpdate),
        this.on("selectionUpdate", this.options.onSelectionUpdate),
        this.on("transaction", this.options.onTransaction),
        this.on("focus", this.options.onFocus),
        this.on("blur", this.options.onBlur),
        this.on("destroy", this.options.onDestroy),
        this.on("drop", ({event: o, slice: l, moved: a}) => this.options.onDrop(o, l, a)),
        this.on("paste", ({event: o, slice: l}) => this.options.onPaste(o, l)),
        this.on("delete", this.options.onDelete);
        const n = this.createDoc()
          , r = Jx(n, this.options.autofocus);
        this.editorState = kl.create({
            doc: n,
            schema: this.schema,
            selection: r || void 0
        }),
        this.options.element && this.mount(this.options.element)
    }
    mount(e) {
        if (typeof document > "u")
            throw new Error("[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.");
        this.createView(e),
        this.emit("mount", {
            editor: this
        }),
        this.css && !document.head.contains(this.css) && document.head.appendChild(this.css),
        window.setTimeout( () => {
            this.isDestroyed || (this.options.autofocus !== !1 && this.options.autofocus !== null && this.commands.focus(this.options.autofocus),
            this.emit("create", {
                editor: this
            }),
            this.isInitialized = !0)
        }
        , 0)
    }
    unmount() {
        if (this.editorView) {
            const e = this.editorView.dom;
            e?.editor && delete e.editor,
            this.editorView.destroy()
        }
        if (this.editorView = null,
        this.isInitialized = !1,
        this.css && !document.querySelectorAll(`.${this.className}`).length)
            try {
                typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css)
            } catch (e) {
                console.warn("Failed to remove CSS element:", e)
            }
        this.css = null,
        this.emit("unmount", {
            editor: this
        })
    }
    get storage() {
        return this.extensionStorage
    }
    get commands() {
        return this.commandManager.commands
    }
    chain() {
        return this.commandManager.chain()
    }
    can() {
        return this.commandManager.can()
    }
    injectCSS() {
        this.options.injectCSS && typeof document < "u" && (this.css = XM(WM, this.options.injectNonce))
    }
    setOptions(e={}) {
        this.options = {
            ...this.options,
            ...e
        },
        !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps),
        this.view.updateState(this.state))
    }
    setEditable(e, n=!0) {
        this.setOptions({
            editable: e
        }),
        n && this.emit("update", {
            editor: this,
            transaction: this.state.tr,
            appendedTransactions: []
        })
    }
    get isEditable() {
        return this.options.editable && this.view && this.view.editable
    }
    get view() {
        return this.editorView ? this.editorView : new Proxy({
            state: this.editorState,
            updateState: e => {
                this.editorState = e
            }
            ,
            dispatch: e => {
                this.dispatchTransaction(e)
            }
            ,
            composing: !1,
            dragging: null,
            editable: !0,
            isDestroyed: !1
        },{
            get: (e, n) => {
                if (this.editorView)
                    return this.editorView[n];
                if (n === "state")
                    return this.editorState;
                if (n in e)
                    return Reflect.get(e, n);
                throw new Error(`[tiptap error]: The editor view is not available. Cannot access view['${n}']. The editor may not be mounted yet.`)
            }
        })
    }
    get state() {
        return this.editorView && (this.editorState = this.view.state),
        this.editorState
    }
    registerPlugin(e, n) {
        const r = i3(n) ? n(e, [...this.state.plugins]) : [...this.state.plugins, e]
          , o = this.state.reconfigure({
            plugins: r
        });
        return this.view.updateState(o),
        o
    }
    unregisterPlugin(e) {
        if (this.isDestroyed)
            return;
        const n = this.state.plugins;
        let r = n;
        if ([].concat(e).forEach(l => {
            const a = typeof l == "string" ? `${l}$` : l.key;
            r = r.filter(u => !u.key.startsWith(a))
        }
        ),
        n.length === r.length)
            return;
        const o = this.state.reconfigure({
            plugins: r
        });
        return this.view.updateState(o),
        o
    }
    createExtensionManager() {
        var e, n;
        const o = [...this.options.enableCoreExtensions ? [S3, y3.configure({
            blockSeparator: (n = (e = this.options.coreExtensionOptions) == null ? void 0 : e.clipboardTextSerializer) == null ? void 0 : n.blockSeparator
        }), v3, w3, E3, k3, C3, T3, b3, M3.configure({
            direction: this.options.textDirection
        })].filter(l => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[l.name] !== !1 : !0) : [], ...this.options.extensions].filter(l => ["extension", "node", "mark"].includes(l?.type));
        this.extensionManager = new Uf(o,this)
    }
    createCommandManager() {
        this.commandManager = new Bf({
            editor: this
        })
    }
    createSchema() {
        this.schema = this.extensionManager.schema
    }
    createDoc() {
        let e;
        try {
            e = Dm(this.options.content, this.schema, this.options.parseOptions, {
                errorOnInvalidContent: this.options.enableContentCheck
            })
        } catch (n) {
            if (!(n instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(n.message))
                throw n;
            this.emit("contentError", {
                editor: this,
                error: n,
                disableCollaboration: () => {
                    "collaboration"in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0),
                    this.options.extensions = this.options.extensions.filter(r => r.name !== "collaboration"),
                    this.createExtensionManager()
                }
            }),
            e = Dm(this.options.content, this.schema, this.options.parseOptions, {
                errorOnInvalidContent: !1
            })
        }
        return e
    }
    createView(e) {
        const {editorProps: n, enableExtensionDispatchTransaction: r} = this.options
          , o = n.dispatchTransaction || this.dispatchTransaction.bind(this)
          , l = r ? this.extensionManager.dispatchTransaction(o) : o;
        this.editorView = new Yx(e,{
            ...n,
            attributes: {
                role: "textbox",
                ...n?.attributes
            },
            dispatchTransaction: l,
            state: this.editorState,
            markViews: this.extensionManager.markViews,
            nodeViews: this.extensionManager.nodeViews
        });
        const a = this.state.reconfigure({
            plugins: this.extensionManager.plugins
        });
        this.view.updateState(a),
        this.prependClass(),
        this.injectCSS();
        const u = this.view.dom;
        u.editor = this
    }
    createNodeViews() {
        this.view.isDestroyed || this.view.setProps({
            markViews: this.extensionManager.markViews,
            nodeViews: this.extensionManager.nodeViews
        })
    }
    prependClass() {
        this.view.dom.className = `${this.className} ${this.view.dom.className}`
    }
    captureTransaction(e) {
        this.isCapturingTransaction = !0,
        e(),
        this.isCapturingTransaction = !1;
        const n = this.capturedTransaction;
        return this.capturedTransaction = null,
        n
    }
    dispatchTransaction(e) {
        if (this.view.isDestroyed)
            return;
        if (this.isCapturingTransaction) {
            if (!this.capturedTransaction) {
                this.capturedTransaction = e;
                return
            }
            e.steps.forEach(p => {
                var m;
                return (m = this.capturedTransaction) == null ? void 0 : m.step(p)
            }
            );
            return
        }
        const {state: n, transactions: r} = this.state.applyTransaction(e)
          , o = !this.state.selection.eq(n.selection)
          , l = r.includes(e)
          , a = this.state;
        if (this.emit("beforeTransaction", {
            editor: this,
            transaction: e,
            nextState: n
        }),
        !l)
            return;
        this.view.updateState(n),
        this.emit("transaction", {
            editor: this,
            transaction: e,
            appendedTransactions: r.slice(1)
        }),
        o && this.emit("selectionUpdate", {
            editor: this,
            transaction: e
        });
        const u = r.findLast(p => p.getMeta("focus") || p.getMeta("blur"))
          , f = u?.getMeta("focus")
          , h = u?.getMeta("blur");
        f && this.emit("focus", {
            editor: this,
            event: f.event,
            transaction: u
        }),
        h && this.emit("blur", {
            editor: this,
            event: h.event,
            transaction: u
        }),
        !(e.getMeta("preventUpdate") || !r.some(p => p.docChanged) || a.doc.eq(n.doc)) && this.emit("update", {
            editor: this,
            transaction: e,
            appendedTransactions: r.slice(1)
        })
    }
    getAttributes(e) {
        return c3(this.state, e)
    }
    isActive(e, n) {
        const r = typeof e == "string" ? e : null
          , o = typeof e == "string" ? n : e;
        return dM(this.state, r, o)
    }
    getJSON() {
        return this.state.doc.toJSON()
    }
    getHTML() {
        return I1(this.state.doc.content, this.schema)
    }
    getText(e) {
        const {blockSeparator: n=`

`, textSerializers: r={}} = e || {};
        return lM(this.state.doc, {
            blockSeparator: n,
            textSerializers: {
                ...a3(this.schema),
                ...r
            }
        })
    }
    get isEmpty() {
        return If(this.state.doc)
    }
    destroy() {
        this.emit("destroy"),
        this.unmount(),
        this.removeAllListeners()
    }
    get isDestroyed() {
        var e, n;
        return (n = (e = this.editorView) == null ? void 0 : e.isDestroyed) != null ? n : !0
    }
    $node(e, n) {
        var r;
        return ((r = this.$doc) == null ? void 0 : r.querySelector(e, n)) || null
    }
    $nodes(e, n) {
        var r;
        return ((r = this.$doc) == null ? void 0 : r.querySelectorAll(e, n)) || null
    }
    $pos(e) {
        const n = this.state.doc.resolve(e);
        return new ZM(n,this)
    }
    get $doc() {
        return this.$pos(0)
    }
}
;
function Bl(t) {
    return new Vf({
        find: t.find,
        handler: ({state: e, range: n, match: r}) => {
            const o = Le(t.getAttributes, void 0, r);
            if (o === !1 || o === null)
                return null;
            const {tr: l} = e
              , a = r[r.length - 1]
              , u = r[0];
            if (a) {
                const f = u.search(/\S/)
                  , h = n.from + u.indexOf(a)
                  , p = h + a.length;
                if (V1(n.from, n.to, e.doc).filter(b => b.mark.type.excluded.find(S => S === t.type && S !== b.mark.type)).filter(b => b.to > h).length)
                    return null;
                p < n.to && l.delete(p, n.to),
                h > n.from && l.delete(n.from + f, h);
                const y = n.from + f + a.length;
                l.addMark(n.from + f, y, t.type.create(o || {})),
                l.removeStoredMark(t.type)
            }
        }
        ,
        undoable: t.undoable
    })
}
function QM(t) {
    return new Vf({
        find: t.find,
        handler: ({state: e, range: n, match: r}) => {
            const o = Le(t.getAttributes, void 0, r) || {}
              , {tr: l} = e
              , a = n.from;
            let u = n.to;
            const f = t.type.create(o);
            if (r[1]) {
                const h = r[0].lastIndexOf(r[1]);
                let p = a + h;
                p > u ? p = u : u = p + r[1].length;
                const m = r[0][r[0].length - 1];
                l.insertText(m, a + r[0].length - 1),
                l.replaceWith(p, u, f)
            } else if (r[0]) {
                const h = t.type.isInline ? a : a - 1;
                l.insert(h, t.type.create(o)).delete(l.mapping.map(a), l.mapping.map(u))
            }
            l.scrollIntoView()
        }
        ,
        undoable: t.undoable
    })
}
function zm(t) {
    return new Vf({
        find: t.find,
        handler: ({state: e, range: n, match: r}) => {
            const o = e.doc.resolve(n.from)
              , l = Le(t.getAttributes, void 0, r) || {};
            if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
                return null;
            e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, l)
        }
        ,
        undoable: t.undoable
    })
}
function jl(t) {
    return new Vf({
        find: t.find,
        handler: ({state: e, range: n, match: r, chain: o}) => {
            const l = Le(t.getAttributes, void 0, r) || {}
              , a = e.tr.delete(n.from, n.to)
              , f = a.doc.resolve(n.from).blockRange()
              , h = f && y1(f, t.type, l);
            if (!h)
                return null;
            if (a.wrap(f, h),
            t.keepMarks && t.editor) {
                const {selection: m, storedMarks: y} = e
                  , {splittableMarks: b} = t.editor.extensionManager
                  , C = y || m.$to.parentOffset && m.$from.marks();
                if (C) {
                    const S = C.filter(w => b.includes(w.type.name));
                    a.ensureMarks(S)
                }
            }
            if (t.keepAttributes) {
                const m = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
                o().updateAttributes(m, l).run()
            }
            const p = a.doc.resolve(n.from - 1).nodeBefore;
            p && p.type === t.type && Di(a.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, p)) && a.join(n.from - 1)
        }
        ,
        undoable: t.undoable
    })
}
function eA(t, e) {
    const {selection: n} = t
      , {$from: r} = n;
    if (n instanceof le) {
        const l = r.index();
        return r.parent.canReplaceWith(l, l + 1, e)
    }
    let o = r.depth;
    for (; o >= 0; ) {
        const l = r.index(o);
        if (r.node(o).contentMatchAt(l).matchType(e))
            return !0;
        o -= 1
    }
    return !1
}
var tA = {};
_1(tA, {
    createAtomBlockMarkdownSpec: () => nA,
    createBlockMarkdownSpec: () => rA,
    createInlineMarkdownSpec: () => lA,
    parseAttributes: () => P1,
    parseIndentedBlocks: () => _m,
    renderNestedMarkdownContent: () => $1,
    serializeAttributes: () => q1
});
function P1(t) {
    if (!t?.trim())
        return {};
    const e = {}
      , n = []
      , r = t.replace(/["']([^"']*)["']/g, h => (n.push(h),
    `__QUOTED_${n.length - 1}__`))
      , o = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
    if (o) {
        const h = o.map(p => p.trim().slice(1));
        e.class = h.join(" ")
    }
    const l = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
    l && (e.id = l[1]);
    const a = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
    Array.from(r.matchAll(a)).forEach( ([,h,p]) => {
        var m;
        const y = parseInt(((m = p.match(/__QUOTED_(\d+)__/)) == null ? void 0 : m[1]) || "0", 10)
          , b = n[y];
        b && (e[h] = b.slice(1, -1))
    }
    );
    const f = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
    return f && f.split(/\s+/).filter(Boolean).forEach(p => {
        p.match(/^[a-zA-Z][\w-]*$/) && (e[p] = !0)
    }
    ),
    e
}
function q1(t) {
    if (!t || Object.keys(t).length === 0)
        return "";
    const e = [];
    return t.class && String(t.class).split(/\s+/).filter(Boolean).forEach(r => e.push(`.${r}`)),
    t.id && e.push(`#${t.id}`),
    Object.entries(t).forEach( ([n,r]) => {
        n === "class" || n === "id" || (r === !0 ? e.push(n) : r !== !1 && r != null && e.push(`${n}="${String(r)}"`))
    }
    ),
    e.join(" ")
}
function nA(t) {
    const {nodeName: e, name: n, parseAttributes: r=P1, serializeAttributes: o=q1, defaultAttributes: l={}, requiredAttributes: a=[], allowedAttributes: u} = t
      , f = n || e
      , h = p => {
        if (!u)
            return p;
        const m = {};
        return u.forEach(y => {
            y in p && (m[y] = p[y])
        }
        ),
        m
    }
    ;
    return {
        parseMarkdown: (p, m) => {
            const y = {
                ...l,
                ...p.attributes
            };
            return m.createNode(e, y, [])
        }
        ,
        markdownTokenizer: {
            name: e,
            level: "block",
            start(p) {
                var m;
                const y = new RegExp(`^:::${f}(?:\\s|$)`,"m")
                  , b = (m = p.match(y)) == null ? void 0 : m.index;
                return b !== void 0 ? b : -1
            },
            tokenize(p, m, y) {
                const b = new RegExp(`^:::${f}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`)
                  , C = p.match(b);
                if (!C)
                    return;
                const S = C[1] || ""
                  , w = r(S);
                if (!a.find(A => !(A in w)))
                    return {
                        type: e,
                        raw: C[0],
                        attributes: w
                    }
            }
        },
        renderMarkdown: p => {
            const m = h(p.attrs || {})
              , y = o(m)
              , b = y ? ` {${y}}` : "";
            return `:::${f}${b} :::`
        }
    }
}
function rA(t) {
    const {nodeName: e, name: n, getContent: r, parseAttributes: o=P1, serializeAttributes: l=q1, defaultAttributes: a={}, content: u="block", allowedAttributes: f} = t
      , h = n || e
      , p = m => {
        if (!f)
            return m;
        const y = {};
        return f.forEach(b => {
            b in m && (y[b] = m[b])
        }
        ),
        y
    }
    ;
    return {
        parseMarkdown: (m, y) => {
            let b;
            if (r) {
                const S = r(m);
                b = typeof S == "string" ? [{
                    type: "text",
                    text: S
                }] : S
            } else
                u === "block" ? b = y.parseChildren(m.tokens || []) : b = y.parseInline(m.tokens || []);
            const C = {
                ...a,
                ...m.attributes
            };
            return y.createNode(e, C, b)
        }
        ,
        markdownTokenizer: {
            name: e,
            level: "block",
            start(m) {
                var y;
                const b = new RegExp(`^:::${h}`,"m")
                  , C = (y = m.match(b)) == null ? void 0 : y.index;
                return C !== void 0 ? C : -1
            },
            tokenize(m, y, b) {
                var C;
                const S = new RegExp(`^:::${h}(?:\\s+\\{([^}]*)\\})?\\s*\\n`)
                  , w = m.match(S);
                if (!w)
                    return;
                const [k,A=""] = w
                  , O = o(A);
                let B = 1;
                const z = k.length;
                let $ = "";
                const _ = /^:::([\w-]*)(\s.*)?/gm
                  , W = m.slice(z);
                for (_.lastIndex = 0; ; ) {
                    const ne = _.exec(W);
                    if (ne === null)
                        break;
                    const de = ne.index
                      , ve = ne[1];
                    if (!((C = ne[2]) != null && C.endsWith(":::"))) {
                        if (ve)
                            B += 1;
                        else if (B -= 1,
                        B === 0) {
                            const pe = W.slice(0, de);
                            $ = pe.trim();
                            const be = m.slice(0, z + de + ne[0].length);
                            let Q = [];
                            if ($)
                                if (u === "block")
                                    for (Q = b.blockTokens(pe),
                                    Q.forEach(ae => {
                                        ae.text && (!ae.tokens || ae.tokens.length === 0) && (ae.tokens = b.inlineTokens(ae.text))
                                    }
                                    ); Q.length > 0; ) {
                                        const ae = Q[Q.length - 1];
                                        if (ae.type === "paragraph" && (!ae.text || ae.text.trim() === ""))
                                            Q.pop();
                                        else
                                            break
                                    }
                                else
                                    Q = b.inlineTokens($);
                            return {
                                type: e,
                                raw: be,
                                attributes: O,
                                content: $,
                                tokens: Q
                            }
                        }
                    }
                }
            }
        },
        renderMarkdown: (m, y) => {
            const b = p(m.attrs || {})
              , C = l(b)
              , S = C ? ` {${C}}` : ""
              , w = y.renderChildren(m.content || [], `

`);
            return `:::${h}${S}

${w}

:::`
        }
    }
}
function iA(t) {
    if (!t.trim())
        return {};
    const e = {}
      , n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
    let r = n.exec(t);
    for (; r !== null; ) {
        const [,o,l,a] = r;
        e[o] = l || a,
        r = n.exec(t)
    }
    return e
}
function oA(t) {
    return Object.entries(t).filter( ([,e]) => e != null).map( ([e,n]) => `${e}="${n}"`).join(" ")
}
function lA(t) {
    const {nodeName: e, name: n, getContent: r, parseAttributes: o=iA, serializeAttributes: l=oA, defaultAttributes: a={}, selfClosing: u=!1, allowedAttributes: f} = t
      , h = n || e
      , p = y => {
        if (!f)
            return y;
        const b = {};
        return f.forEach(C => {
            const S = typeof C == "string" ? C : C.name
              , w = typeof C == "string" ? void 0 : C.skipIfDefault;
            if (S in y) {
                const k = y[S];
                if (w !== void 0 && k === w)
                    return;
                b[S] = k
            }
        }
        ),
        b
    }
      , m = h.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    return {
        parseMarkdown: (y, b) => {
            const C = {
                ...a,
                ...y.attributes
            };
            if (u)
                return b.createNode(e, C);
            const S = r ? r(y) : y.content || "";
            return S ? b.createNode(e, C, [b.createTextNode(S)]) : b.createNode(e, C, [])
        }
        ,
        markdownTokenizer: {
            name: e,
            level: "inline",
            start(y) {
                const b = u ? new RegExp(`\\[${m}\\s*[^\\]]*\\]`) : new RegExp(`\\[${m}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${m}\\]`)
                  , C = y.match(b)
                  , S = C?.index;
                return S !== void 0 ? S : -1
            },
            tokenize(y, b, C) {
                const S = u ? new RegExp(`^\\[${m}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${m}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${m}\\]`)
                  , w = y.match(S);
                if (!w)
                    return;
                let k = ""
                  , A = "";
                if (u) {
                    const [,B] = w;
                    A = B
                } else {
                    const [,B,z] = w;
                    A = B,
                    k = z || ""
                }
                const O = o(A.trim());
                return {
                    type: e,
                    raw: w[0],
                    content: k.trim(),
                    attributes: O
                }
            }
        },
        renderMarkdown: y => {
            let b = "";
            r ? b = r(y) : y.content && y.content.length > 0 && (b = y.content.filter(k => k.type === "text").map(k => k.text).join(""));
            const C = p(y.attrs || {})
              , S = l(C)
              , w = S ? ` ${S}` : "";
            return u ? `[${h}${w}]` : `[${h}${w}]${b}[/${h}]`
        }
    }
}
function _m(t, e, n) {
    var r, o, l, a;
    const u = t.split(`
`)
      , f = [];
    let h = ""
      , p = 0;
    const m = e.baseIndentSize || 2;
    for (; p < u.length; ) {
        const y = u[p]
          , b = y.match(e.itemPattern);
        if (!b) {
            if (f.length > 0)
                break;
            if (y.trim() === "") {
                p += 1,
                h = `${h}${y}
`;
                continue
            } else
                return
        }
        const C = e.extractItemData(b)
          , {indentLevel: S, mainContent: w} = C;
        h = `${h}${y}
`;
        const k = [w];
        for (p += 1; p < u.length; ) {
            const z = u[p];
            if (z.trim() === "") {
                const _ = u.slice(p + 1).findIndex(de => de.trim() !== "");
                if (_ === -1)
                    break;
                if ((((o = (r = u[p + 1 + _].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : o.length) || 0) > S) {
                    k.push(z),
                    h = `${h}${z}
`,
                    p += 1;
                    continue
                } else
                    break
            }
            if ((((a = (l = z.match(/^(\s*)/)) == null ? void 0 : l[1]) == null ? void 0 : a.length) || 0) > S)
                k.push(z),
                h = `${h}${z}
`,
                p += 1;
            else
                break
        }
        let A;
        const O = k.slice(1);
        if (O.length > 0) {
            const z = O.map($ => $.slice(S + m)).join(`
`);
            z.trim() && (e.customNestedParser ? A = e.customNestedParser(z) : A = n.blockTokens(z))
        }
        const B = e.createToken(C, A);
        f.push(B)
    }
    if (f.length !== 0)
        return {
            items: f,
            raw: h
        }
}
function $1(t, e, n, r) {
    if (!t || !Array.isArray(t.content))
        return "";
    const o = typeof n == "function" ? n(r) : n
      , [l,...a] = t.content
      , u = e.renderChildren([l])
      , f = [`${o}${u}`];
    return a && a.length > 0 && a.forEach(h => {
        const p = e.renderChildren([h]);
        if (p) {
            const m = p.split(`
`).map(y => y ? e.indent(y) : "").join(`
`);
            f.push(m)
        }
    }
    ),
    f.join(`
`)
}
function sA(t, e, n={}) {
    const {state: r} = e
      , {doc: o, tr: l} = r
      , a = t;
    o.descendants( (u, f) => {
        const h = l.mapping.map(f)
          , p = l.mapping.map(f) + u.nodeSize;
        let m = null;
        if (u.marks.forEach(b => {
            if (b !== a)
                return !1;
            m = b
        }
        ),
        !m)
            return;
        let y = !1;
        if (Object.keys(n).forEach(b => {
            n[b] !== m.attrs[b] && (y = !0)
        }
        ),
        y) {
            const b = t.type.create({
                ...t.attrs,
                ...n
            });
            l.removeMark(h, p, t.type),
            l.addMark(h, p, b)
        }
    }
    ),
    l.docChanged && e.view.dispatch(l)
}
var Nt = class A3 extends U1 {
    constructor() {
        super(...arguments),
        this.type = "node"
    }
    static create(e={}) {
        const n = typeof e == "function" ? e() : e;
        return new A3(n)
    }
    configure(e) {
        return super.configure(e)
    }
    extend(e) {
        const n = typeof e == "function" ? e() : e;
        return super.extend(n)
    }
}
;
function xo(t) {
    return new qM({
        find: t.find,
        handler: ({state: e, range: n, match: r, pasteEvent: o}) => {
            const l = Le(t.getAttributes, void 0, r, o);
            if (l === !1 || l === null)
                return null;
            const {tr: a} = e
              , u = r[r.length - 1]
              , f = r[0];
            let h = n.to;
            if (u) {
                const p = f.search(/\S/)
                  , m = n.from + f.indexOf(u)
                  , y = m + u.length;
                if (V1(n.from, n.to, e.doc).filter(C => C.mark.type.excluded.find(w => w === t.type && w !== C.mark.type)).filter(C => C.to > m).length)
                    return null;
                y < n.to && a.delete(y, n.to),
                m > n.from && a.delete(n.from + p, m),
                h = n.from + p + u.length,
                a.addMark(n.from + p, h, t.type.create(l || {})),
                a.removeStoredMark(t.type)
            }
        }
    })
}
const {getOwnPropertyNames: aA, getOwnPropertySymbols: cA} = Object
  , {hasOwnProperty: uA} = Object.prototype;
function Up(t, e) {
    return function(r, o, l) {
        return t(r, o, l) && e(r, o, l)
    }
}
function tu(t) {
    return function(n, r, o) {
        if (!n || !r || typeof n != "object" || typeof r != "object")
            return t(n, r, o);
        const {cache: l} = o
          , a = l.get(n)
          , u = l.get(r);
        if (a && u)
            return a === r && u === n;
        l.set(n, r),
        l.set(r, n);
        const f = t(n, r, o);
        return l.delete(n),
        l.delete(r),
        f
    }
}
function fA(t) {
    return t?.[Symbol.toStringTag]
}
function Kb(t) {
    return aA(t).concat(cA(t))
}
const dA = Object.hasOwn || ( (t, e) => uA.call(t, e));
function Ao(t, e) {
    return t === e || !t && !e && t !== t && e !== e
}
const hA = "__v"
  , pA = "__o"
  , mA = "_owner"
  , {getOwnPropertyDescriptor: Gb, keys: Yb} = Object;
function gA(t, e) {
    return t.byteLength === e.byteLength && Pu(new Uint8Array(t), new Uint8Array(e))
}
function yA(t, e, n) {
    let r = t.length;
    if (e.length !== r)
        return !1;
    for (; r-- > 0; )
        if (!n.equals(t[r], e[r], r, r, t, e, n))
            return !1;
    return !0
}
function vA(t, e) {
    return t.byteLength === e.byteLength && Pu(new Uint8Array(t.buffer,t.byteOffset,t.byteLength), new Uint8Array(e.buffer,e.byteOffset,e.byteLength))
}
function bA(t, e) {
    return Ao(t.getTime(), e.getTime())
}
function CA(t, e) {
    return t.name === e.name && t.message === e.message && t.cause === e.cause && t.stack === e.stack
}
function SA(t, e) {
    return t === e
}
function Zb(t, e, n) {
    const r = t.size;
    if (r !== e.size)
        return !1;
    if (!r)
        return !0;
    const o = new Array(r)
      , l = t.entries();
    let a, u, f = 0;
    for (; (a = l.next()) && !a.done; ) {
        const h = e.entries();
        let p = !1
          , m = 0;
        for (; (u = h.next()) && !u.done; ) {
            if (o[m]) {
                m++;
                continue
            }
            const y = a.value
              , b = u.value;
            if (n.equals(y[0], b[0], f, m, t, e, n) && n.equals(y[1], b[1], y[0], b[0], t, e, n)) {
                p = o[m] = !0;
                break
            }
            m++
        }
        if (!p)
            return !1;
        f++
    }
    return !0
}
const xA = Ao;
function wA(t, e, n) {
    const r = Yb(t);
    let o = r.length;
    if (Yb(e).length !== o)
        return !1;
    for (; o-- > 0; )
        if (!N3(t, e, n, r[o]))
            return !1;
    return !0
}
function Vs(t, e, n) {
    const r = Kb(t);
    let o = r.length;
    if (Kb(e).length !== o)
        return !1;
    let l, a, u;
    for (; o-- > 0; )
        if (l = r[o],
        !N3(t, e, n, l) || (a = Gb(t, l),
        u = Gb(e, l),
        (a || u) && (!a || !u || a.configurable !== u.configurable || a.enumerable !== u.enumerable || a.writable !== u.writable)))
            return !1;
    return !0
}
function EA(t, e) {
    return Ao(t.valueOf(), e.valueOf())
}
function TA(t, e) {
    return t.source === e.source && t.flags === e.flags
}
function Wb(t, e, n) {
    const r = t.size;
    if (r !== e.size)
        return !1;
    if (!r)
        return !0;
    const o = new Array(r)
      , l = t.values();
    let a, u;
    for (; (a = l.next()) && !a.done; ) {
        const f = e.values();
        let h = !1
          , p = 0;
        for (; (u = f.next()) && !u.done; ) {
            if (!o[p] && n.equals(a.value, u.value, a.value, u.value, t, e, n)) {
                h = o[p] = !0;
                break
            }
            p++
        }
        if (!h)
            return !1
    }
    return !0
}
function Pu(t, e) {
    let n = t.byteLength;
    if (e.byteLength !== n || t.byteOffset !== e.byteOffset)
        return !1;
    for (; n-- > 0; )
        if (t[n] !== e[n])
            return !1;
    return !0
}
function kA(t, e) {
    return t.hostname === e.hostname && t.pathname === e.pathname && t.protocol === e.protocol && t.port === e.port && t.hash === e.hash && t.username === e.username && t.password === e.password
}
function N3(t, e, n, r) {
    return (r === mA || r === pA || r === hA) && (t.$$typeof || e.$$typeof) ? !0 : dA(e, r) && n.equals(t[r], e[r], r, r, t, e, n)
}
const MA = "[object ArrayBuffer]"
  , AA = "[object Arguments]"
  , NA = "[object Boolean]"
  , RA = "[object DataView]"
  , OA = "[object Date]"
  , DA = "[object Error]"
  , LA = "[object Map]"
  , zA = "[object Number]"
  , _A = "[object Object]"
  , BA = "[object RegExp]"
  , jA = "[object Set]"
  , HA = "[object String]"
  , IA = {
    "[object Int8Array]": !0,
    "[object Uint8Array]": !0,
    "[object Uint8ClampedArray]": !0,
    "[object Int16Array]": !0,
    "[object Uint16Array]": !0,
    "[object Int32Array]": !0,
    "[object Uint32Array]": !0,
    "[object Float16Array]": !0,
    "[object Float32Array]": !0,
    "[object Float64Array]": !0,
    "[object BigInt64Array]": !0,
    "[object BigUint64Array]": !0
}
  , VA = "[object URL]"
  , UA = Object.prototype.toString;
function PA({areArrayBuffersEqual: t, areArraysEqual: e, areDataViewsEqual: n, areDatesEqual: r, areErrorsEqual: o, areFunctionsEqual: l, areMapsEqual: a, areNumbersEqual: u, areObjectsEqual: f, arePrimitiveWrappersEqual: h, areRegExpsEqual: p, areSetsEqual: m, areTypedArraysEqual: y, areUrlsEqual: b, unknownTagComparators: C}) {
    return function(w, k, A) {
        if (w === k)
            return !0;
        if (w == null || k == null)
            return !1;
        const O = typeof w;
        if (O !== typeof k)
            return !1;
        if (O !== "object")
            return O === "number" ? u(w, k, A) : O === "function" ? l(w, k, A) : !1;
        const B = w.constructor;
        if (B !== k.constructor)
            return !1;
        if (B === Object)
            return f(w, k, A);
        if (Array.isArray(w))
            return e(w, k, A);
        if (B === Date)
            return r(w, k, A);
        if (B === RegExp)
            return p(w, k, A);
        if (B === Map)
            return a(w, k, A);
        if (B === Set)
            return m(w, k, A);
        const z = UA.call(w);
        if (z === OA)
            return r(w, k, A);
        if (z === BA)
            return p(w, k, A);
        if (z === LA)
            return a(w, k, A);
        if (z === jA)
            return m(w, k, A);
        if (z === _A)
            return typeof w.then != "function" && typeof k.then != "function" && f(w, k, A);
        if (z === VA)
            return b(w, k, A);
        if (z === DA)
            return o(w, k, A);
        if (z === AA)
            return f(w, k, A);
        if (IA[z])
            return y(w, k, A);
        if (z === MA)
            return t(w, k, A);
        if (z === RA)
            return n(w, k, A);
        if (z === NA || z === zA || z === HA)
            return h(w, k, A);
        if (C) {
            let $ = C[z];
            if (!$) {
                const _ = fA(w);
                _ && ($ = C[_])
            }
            if ($)
                return $(w, k, A)
        }
        return !1
    }
}
function qA({circular: t, createCustomConfig: e, strict: n}) {
    let r = {
        areArrayBuffersEqual: gA,
        areArraysEqual: n ? Vs : yA,
        areDataViewsEqual: vA,
        areDatesEqual: bA,
        areErrorsEqual: CA,
        areFunctionsEqual: SA,
        areMapsEqual: n ? Up(Zb, Vs) : Zb,
        areNumbersEqual: xA,
        areObjectsEqual: n ? Vs : wA,
        arePrimitiveWrappersEqual: EA,
        areRegExpsEqual: TA,
        areSetsEqual: n ? Up(Wb, Vs) : Wb,
        areTypedArraysEqual: n ? Up(Pu, Vs) : Pu,
        areUrlsEqual: kA,
        unknownTagComparators: void 0
    };
    if (e && (r = Object.assign({}, r, e(r))),
    t) {
        const o = tu(r.areArraysEqual)
          , l = tu(r.areMapsEqual)
          , a = tu(r.areObjectsEqual)
          , u = tu(r.areSetsEqual);
        r = Object.assign({}, r, {
            areArraysEqual: o,
            areMapsEqual: l,
            areObjectsEqual: a,
            areSetsEqual: u
        })
    }
    return r
}
function $A(t) {
    return function(e, n, r, o, l, a, u) {
        return t(e, n, u)
    }
}
function FA({circular: t, comparator: e, createState: n, equals: r, strict: o}) {
    if (n)
        return function(u, f) {
            const {cache: h=t ? new WeakMap : void 0, meta: p} = n();
            return e(u, f, {
                cache: h,
                equals: r,
                meta: p,
                strict: o
            })
        }
        ;
    if (t)
        return function(u, f) {
            return e(u, f, {
                cache: new WeakMap,
                equals: r,
                meta: void 0,
                strict: o
            })
        }
        ;
    const l = {
        cache: void 0,
        equals: r,
        meta: void 0,
        strict: o
    };
    return function(u, f) {
        return e(u, f, l)
    }
}
const KA = zi();
zi({
    strict: !0
});
zi({
    circular: !0
});
zi({
    circular: !0,
    strict: !0
});
zi({
    createInternalComparator: () => Ao
});
zi({
    strict: !0,
    createInternalComparator: () => Ao
});
zi({
    circular: !0,
    createInternalComparator: () => Ao
});
zi({
    circular: !0,
    createInternalComparator: () => Ao,
    strict: !0
});
function zi(t={}) {
    const {circular: e=!1, createInternalComparator: n, createState: r, strict: o=!1} = t
      , l = qA(t)
      , a = PA(l)
      , u = n ? n(a) : $A(a);
    return FA({
        circular: e,
        comparator: a,
        createState: r,
        equals: u,
        strict: o
    })
}
var Pp = {
    exports: {}
}
  , qp = {};
var Xb;
function GA() {
    if (Xb)
        return qp;
    Xb = 1;
    var t = Sa()
      , e = CS();
    function n(h, p) {
        return h === p && (h !== 0 || 1 / h === 1 / p) || h !== h && p !== p
    }
    var r = typeof Object.is == "function" ? Object.is : n
      , o = e.useSyncExternalStore
      , l = t.useRef
      , a = t.useEffect
      , u = t.useMemo
      , f = t.useDebugValue;
    return qp.useSyncExternalStoreWithSelector = function(h, p, m, y, b) {
        var C = l(null);
        if (C.current === null) {
            var S = {
                hasValue: !1,
                value: null
            };
            C.current = S
        } else
            S = C.current;
        C = u(function() {
            function k($) {
                if (!A) {
                    if (A = !0,
                    O = $,
                    $ = y($),
                    b !== void 0 && S.hasValue) {
                        var _ = S.value;
                        if (b(_, $))
                            return B = _
                    }
                    return B = $
                }
                if (_ = B,
                r(O, $))
                    return _;
                var W = y($);
                return b !== void 0 && b(_, W) ? (O = $,
                _) : (O = $,
                B = W)
            }
            var A = !1, O, B, z = m === void 0 ? null : m;
            return [function() {
                return k(p())
            }
            , z === null ? void 0 : function() {
                return k(z())
            }
            ]
        }, [p, m, y, b]);
        var w = o(h, C[0], C[1]);
        return a(function() {
            S.hasValue = !0,
            S.value = w
        }, [w]),
        f(w),
        w
    }
    ,
    qp
}
var Jb;
function YA() {
    return Jb || (Jb = 1,
    Pp.exports = GA()),
    Pp.exports
}
var ZA = YA()
  , WA = (...t) => e => {
    t.forEach(n => {
        typeof n == "function" ? n(e) : n && (n.current = e)
    }
    )
}
  , XA = ({contentComponent: t}) => {
    const e = SS.useSyncExternalStore(t.subscribe, t.getSnapshot, t.getServerSnapshot);
    return E.jsx(E.Fragment, {
        children: Object.values(e)
    })
}
;
function JA() {
    const t = new Set;
    let e = {};
    return {
        subscribe(n) {
            return t.add(n),
            () => {
                t.delete(n)
            }
        },
        getSnapshot() {
            return e
        },
        getServerSnapshot() {
            return e
        },
        setRenderer(n, r) {
            e = {
                ...e,
                [n]: bS.createPortal(r.reactElement, r.element, n)
            },
            t.forEach(o => o())
        },
        removeRenderer(n) {
            const r = {
                ...e
            };
            delete r[n],
            e = r,
            t.forEach(o => o())
        }
    }
}
var QA = class extends Mi.Component {
    constructor(t) {
        var e;
        super(t),
        this.editorContentRef = Mi.createRef(),
        this.initialized = !1,
        this.state = {
            hasContentComponentInitialized: !!((e = t.editor) != null && e.contentComponent)
        }
    }
    componentDidMount() {
        this.init()
    }
    componentDidUpdate() {
        this.init()
    }
    init() {
        var t;
        const e = this.props.editor;
        if (e && !e.isDestroyed && ((t = e.view.dom) != null && t.parentNode)) {
            if (e.contentComponent)
                return;
            const n = this.editorContentRef.current;
            n.append(...e.view.dom.parentNode.childNodes),
            e.setOptions({
                element: n
            }),
            e.contentComponent = JA(),
            this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = e.contentComponent.subscribe( () => {
                this.setState(r => r.hasContentComponentInitialized ? r : {
                    hasContentComponentInitialized: !0
                }),
                this.unsubscribeToContentComponent && this.unsubscribeToContentComponent()
            }
            )),
            e.createNodeViews(),
            this.initialized = !0
        }
    }
    componentWillUnmount() {
        var t;
        const e = this.props.editor;
        if (e) {
            this.initialized = !1,
            e.isDestroyed || e.view.setProps({
                nodeViews: {}
            }),
            this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(),
            e.contentComponent = null;
            try {
                if (!((t = e.view.dom) != null && t.parentNode))
                    return;
                const n = document.createElement("div");
                n.append(...e.view.dom.parentNode.childNodes),
                e.setOptions({
                    element: n
                })
            } catch {}
        }
    }
    render() {
        const {editor: t, innerRef: e, ...n} = this.props;
        return E.jsxs(E.Fragment, {
            children: [E.jsx("div", {
                ref: WA(e, this.editorContentRef),
                ...n
            }), t?.contentComponent && E.jsx(XA, {
                contentComponent: t.contentComponent
            })]
        })
    }
}
  , e8 = T.forwardRef( (t, e) => {
    const n = Mi.useMemo( () => Math.floor(Math.random() * 4294967295).toString(), [t.editor]);
    return Mi.createElement(QA, {
        key: n,
        innerRef: e,
        ...t
    })
}
)
  , R3 = Mi.memo(e8)
  , t8 = typeof window < "u" ? T.useLayoutEffect : T.useEffect
  , n8 = class {
    constructor(t) {
        this.transactionNumber = 0,
        this.lastTransactionNumber = 0,
        this.subscribers = new Set,
        this.editor = t,
        this.lastSnapshot = {
            editor: t,
            transactionNumber: 0
        },
        this.getSnapshot = this.getSnapshot.bind(this),
        this.getServerSnapshot = this.getServerSnapshot.bind(this),
        this.watch = this.watch.bind(this),
        this.subscribe = this.subscribe.bind(this)
    }
    getSnapshot() {
        return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber,
        this.lastSnapshot = {
            editor: this.editor,
            transactionNumber: this.transactionNumber
        },
        this.lastSnapshot)
    }
    getServerSnapshot() {
        return {
            editor: null,
            transactionNumber: 0
        }
    }
    subscribe(t) {
        return this.subscribers.add(t),
        () => {
            this.subscribers.delete(t)
        }
    }
    watch(t) {
        if (this.editor = t,
        this.editor) {
            const e = () => {
                this.transactionNumber += 1,
                this.subscribers.forEach(r => r())
            }
              , n = this.editor;
            return n.on("transaction", e),
            () => {
                n.off("transaction", e)
            }
        }
    }
}
;
function O3(t) {
    var e;
    const [n] = T.useState( () => new n8(t.editor))
      , r = ZA.useSyncExternalStoreWithSelector(n.subscribe, n.getSnapshot, n.getServerSnapshot, t.selector, (e = t.equalityFn) != null ? e : KA);
    return t8( () => n.watch(t.editor), [t.editor, n]),
    T.useDebugValue(r),
    r
}
var r8 = !1
  , Bm = typeof window > "u"
  , i8 = Bm || !!(typeof window < "u" && window.next)
  , o8 = class D3 {
    constructor(e) {
        this.editor = null,
        this.subscriptions = new Set,
        this.isComponentMounted = !1,
        this.previousDeps = null,
        this.instanceId = "",
        this.options = e,
        this.subscriptions = new Set,
        this.setEditor(this.getInitialEditor()),
        this.scheduleDestroy(),
        this.getEditor = this.getEditor.bind(this),
        this.getServerSnapshot = this.getServerSnapshot.bind(this),
        this.subscribe = this.subscribe.bind(this),
        this.refreshEditorInstance = this.refreshEditorInstance.bind(this),
        this.scheduleDestroy = this.scheduleDestroy.bind(this),
        this.onRender = this.onRender.bind(this),
        this.createEditor = this.createEditor.bind(this)
    }
    setEditor(e) {
        this.editor = e,
        this.instanceId = Math.random().toString(36).slice(2, 9),
        this.subscriptions.forEach(n => n())
    }
    getInitialEditor() {
        return this.options.current.immediatelyRender === void 0 ? Bm || i8 ? null : this.createEditor() : (this.options.current.immediatelyRender,
        this.options.current.immediatelyRender ? this.createEditor() : null)
    }
    createEditor() {
        const e = {
            ...this.options.current,
            onBeforeCreate: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onBeforeCreate) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onBlur: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onBlur) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onCreate: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onCreate) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onDestroy: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onDestroy) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onFocus: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onFocus) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onSelectionUpdate: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onSelectionUpdate) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onTransaction: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onTransaction) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onUpdate: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onUpdate) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onContentError: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onContentError) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onDrop: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onDrop) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onPaste: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onPaste) == null ? void 0 : l.call(o, ...r)
            }
            ,
            onDelete: (...r) => {
                var o, l;
                return (l = (o = this.options.current).onDelete) == null ? void 0 : l.call(o, ...r)
            }
        };
        return new JM(e)
    }
    getEditor() {
        return this.editor
    }
    getServerSnapshot() {
        return null
    }
    subscribe(e) {
        return this.subscriptions.add(e),
        () => {
            this.subscriptions.delete(e)
        }
    }
    static compareOptions(e, n) {
        return Object.keys(e).every(r => ["onCreate", "onBeforeCreate", "onDestroy", "onUpdate", "onTransaction", "onFocus", "onBlur", "onSelectionUpdate", "onContentError", "onDrop", "onPaste"].includes(r) ? !0 : r === "extensions" && e.extensions && n.extensions ? e.extensions.length !== n.extensions.length ? !1 : e.extensions.every( (o, l) => {
            var a;
            return o === ((a = n.extensions) == null ? void 0 : a[l])
        }
        ) : e[r] === n[r])
    }
    onRender(e) {
        return () => (this.isComponentMounted = !0,
        clearTimeout(this.scheduledDestructionTimeout),
        this.editor && !this.editor.isDestroyed && e.length === 0 ? D3.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({
            ...this.options.current,
            editable: this.editor.isEditable
        }) : this.refreshEditorInstance(e),
        () => {
            this.isComponentMounted = !1,
            this.scheduleDestroy()
        }
        )
    }
    refreshEditorInstance(e) {
        if (this.editor && !this.editor.isDestroyed) {
            if (this.previousDeps === null) {
                this.previousDeps = e;
                return
            }
            if (this.previousDeps.length === e.length && this.previousDeps.every( (r, o) => r === e[o]))
                return
        }
        this.editor && !this.editor.isDestroyed && this.editor.destroy(),
        this.setEditor(this.createEditor()),
        this.previousDeps = e
    }
    scheduleDestroy() {
        const e = this.instanceId
          , n = this.editor;
        this.scheduledDestructionTimeout = setTimeout( () => {
            if (this.isComponentMounted && this.instanceId === e) {
                n && n.setOptions(this.options.current);
                return
            }
            n && !n.isDestroyed && (n.destroy(),
            this.instanceId === e && this.setEditor(null))
        }
        , 1)
    }
}
;
function l8(t={}, e=[]) {
    const n = T.useRef(t);
    n.current = t;
    const [r] = T.useState( () => new o8(n))
      , o = SS.useSyncExternalStore(r.subscribe, r.getEditor, r.getServerSnapshot);
    return T.useDebugValue(o),
    T.useEffect(r.onRender(e)),
    O3({
        editor: o,
        selector: ({transactionNumber: l}) => t.shouldRerenderOnTransaction === !1 || t.shouldRerenderOnTransaction === void 0 ? null : t.immediatelyRender && l === 0 ? 0 : l + 1
    }),
    o
}
var F1 = T.createContext({
    editor: null
});
F1.Consumer;
var s8 = () => T.useContext(F1)
  , a8 = T.createContext({
    onDragStart: () => {}
    ,
    nodeViewContentChildren: void 0,
    nodeViewContentRef: () => {}
})
  , c8 = () => T.useContext(a8);
Mi.forwardRef( (t, e) => {
    const {onDragStart: n} = c8()
      , r = t.as || "div";
    return E.jsx(r, {
        ...t,
        ref: e,
        "data-node-view-wrapper": "",
        onDragStart: n,
        style: {
            whiteSpace: "normal",
            ...t.style
        }
    })
}
);
Mi.createContext({
    markViewContentRef: () => {}
});
var K1 = T.createContext({
    get editor() {
        throw new Error("useTiptap must be used within a <Tiptap> provider")
    }
});
K1.displayName = "TiptapContext";
var u8 = () => T.useContext(K1);
function L3({editor: t, instance: e, children: n}) {
    const r = t ?? e;
    if (!r)
        throw new Error("Tiptap: An editor instance is required. Pass a non-null `editor` prop.");
    const o = T.useMemo( () => ({
        editor: r
    }), [r])
      , l = T.useMemo( () => ({
        editor: r
    }), [r]);
    return E.jsx(F1.Provider, {
        value: l,
        children: E.jsx(K1.Provider, {
            value: o,
            children: n
        })
    })
}
L3.displayName = "Tiptap";
function z3({...t}) {
    const {editor: e} = u8();
    return E.jsx(R3, {
        editor: e,
        ...t
    })
}
z3.displayName = "Tiptap.Content";
Object.assign(L3, {
    Content: z3
});
var qu = (t, e) => {
    if (t === "slot")
        return 0;
    if (t instanceof Function)
        return t(e);
    const {children: n, ...r} = e ?? {};
    if (t === "svg")
        throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
    return [t, r, n]
}
  , f8 = /^\s*>\s$/
  , d8 = Nt.create({
    name: "blockquote",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "block+",
    group: "block",
    defining: !0,
    parseHTML() {
        return [{
            tag: "blockquote"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return qu("blockquote", {
            ...We(this.options.HTMLAttributes, t),
            children: qu("slot", {})
        })
    },
    parseMarkdown: (t, e) => e.createNode("blockquote", void 0, e.parseChildren(t.tokens || [])),
    renderMarkdown: (t, e) => {
        if (!t.content)
            return "";
        const n = ">"
          , r = [];
        return t.content.forEach(o => {
            const u = e.renderChildren([o]).split(`
`).map(f => f.trim() === "" ? n : `${n} ${f}`);
            r.push(u.join(`
`))
        }
        ),
        r.join(`
${n}
`)
    }
    ,
    addCommands() {
        return {
            setBlockquote: () => ({commands: t}) => t.wrapIn(this.name),
            toggleBlockquote: () => ({commands: t}) => t.toggleWrap(this.name),
            unsetBlockquote: () => ({commands: t}) => t.lift(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
        }
    },
    addInputRules() {
        return [jl({
            find: f8,
            type: this.type
        })]
    }
})
  , h8 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/
  , p8 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g
  , m8 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/
  , g8 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g
  , y8 = Mo.create({
    name: "bold",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "strong"
        }, {
            tag: "b",
            getAttrs: t => t.style.fontWeight !== "normal" && null
        }, {
            style: "font-weight=400",
            clearMark: t => t.type.name === this.name
        }, {
            style: "font-weight",
            getAttrs: t => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return qu("strong", {
            ...We(this.options.HTMLAttributes, t),
            children: qu("slot", {})
        })
    },
    markdownTokenName: "strong",
    parseMarkdown: (t, e) => e.applyMark("bold", e.parseInline(t.tokens || [])),
    renderMarkdown: (t, e) => `**${e.renderChildren(t)}**`,
    addCommands() {
        return {
            setBold: () => ({commands: t}) => t.setMark(this.name),
            toggleBold: () => ({commands: t}) => t.toggleMark(this.name),
            unsetBold: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-b": () => this.editor.commands.toggleBold(),
            "Mod-B": () => this.editor.commands.toggleBold()
        }
    },
    addInputRules() {
        return [Bl({
            find: h8,
            type: this.type
        }), Bl({
            find: m8,
            type: this.type
        })]
    },
    addPasteRules() {
        return [xo({
            find: p8,
            type: this.type
        }), xo({
            find: g8,
            type: this.type
        })]
    }
})
  , v8 = /(^|[^`])`([^`]+)`(?!`)$/
  , b8 = /(^|[^`])`([^`]+)`(?!`)/g
  , C8 = Mo.create({
    name: "code",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    excludes: "_",
    code: !0,
    exitable: !0,
    parseHTML() {
        return [{
            tag: "code"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["code", We(this.options.HTMLAttributes, t), 0]
    },
    markdownTokenName: "codespan",
    parseMarkdown: (t, e) => e.applyMark("code", [{
        type: "text",
        text: t.text || ""
    }]),
    renderMarkdown: (t, e) => t.content ? `\`${e.renderChildren(t.content)}\`` : "",
    addCommands() {
        return {
            setCode: () => ({commands: t}) => t.setMark(this.name),
            toggleCode: () => ({commands: t}) => t.toggleMark(this.name),
            unsetCode: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-e": () => this.editor.commands.toggleCode()
        }
    },
    addInputRules() {
        return [Bl({
            find: v8,
            type: this.type
        })]
    },
    addPasteRules() {
        return [xo({
            find: b8,
            type: this.type
        })]
    }
})
  , $p = 4
  , S8 = /^```([a-z]+)?[\s\n]$/
  , x8 = /^~~~([a-z]+)?[\s\n]$/
  , w8 = Nt.create({
    name: "codeBlock",
    addOptions() {
        return {
            languageClassPrefix: "language-",
            exitOnTripleEnter: !0,
            exitOnArrowDown: !0,
            defaultLanguage: null,
            enableTabIndentation: !1,
            tabSize: $p,
            HTMLAttributes: {}
        }
    },
    content: "text*",
    marks: "",
    group: "block",
    code: !0,
    defining: !0,
    addAttributes() {
        return {
            language: {
                default: this.options.defaultLanguage,
                parseHTML: t => {
                    var e;
                    const {languageClassPrefix: n} = this.options;
                    if (!n)
                        return null;
                    const l = [...((e = t.firstElementChild) == null ? void 0 : e.classList) || []].filter(a => a.startsWith(n)).map(a => a.replace(n, ""))[0];
                    return l || null
                }
                ,
                rendered: !1
            }
        }
    },
    parseHTML() {
        return [{
            tag: "pre",
            preserveWhitespace: "full"
        }]
    },
    renderHTML({node: t, HTMLAttributes: e}) {
        return ["pre", We(this.options.HTMLAttributes, e), ["code", {
            class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        }, 0]]
    },
    markdownTokenName: "code",
    parseMarkdown: (t, e) => {
        var n;
        return ((n = t.raw) == null ? void 0 : n.startsWith("```")) === !1 && t.codeBlockStyle !== "indented" ? [] : e.createNode("codeBlock", {
            language: t.lang || null
        }, t.text ? [e.createTextNode(t.text)] : [])
    }
    ,
    renderMarkdown: (t, e) => {
        var n;
        let r = "";
        const o = ((n = t.attrs) == null ? void 0 : n.language) || "";
        return t.content ? r = [`\`\`\`${o}`, e.renderChildren(t.content), "```"].join(`
`) : r = `\`\`\`${o}

\`\`\``,
        r
    }
    ,
    addCommands() {
        return {
            setCodeBlock: t => ({commands: e}) => e.setNode(this.name, t),
            toggleCodeBlock: t => ({commands: e}) => e.toggleNode(this.name, "paragraph", t)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
            Backspace: () => {
                const {empty: t, $anchor: e} = this.editor.state.selection
                  , n = e.pos === 1;
                return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1
            }
            ,
            Tab: ({editor: t}) => {
                var e;
                if (!this.options.enableTabIndentation)
                    return !1;
                const n = (e = this.options.tabSize) != null ? e : $p
                  , {state: r} = t
                  , {selection: o} = r
                  , {$from: l, empty: a} = o;
                if (l.parent.type !== this.type)
                    return !1;
                const u = " ".repeat(n);
                return a ? t.commands.insertContent(u) : t.commands.command( ({tr: f}) => {
                    const {from: h, to: p} = o
                      , b = r.doc.textBetween(h, p, `
`, `
`).split(`
`).map(C => u + C).join(`
`);
                    return f.replaceWith(h, p, r.schema.text(b)),
                    !0
                }
                )
            }
            ,
            "Shift-Tab": ({editor: t}) => {
                var e;
                if (!this.options.enableTabIndentation)
                    return !1;
                const n = (e = this.options.tabSize) != null ? e : $p
                  , {state: r} = t
                  , {selection: o} = r
                  , {$from: l, empty: a} = o;
                return l.parent.type !== this.type ? !1 : a ? t.commands.command( ({tr: u}) => {
                    var f;
                    const {pos: h} = l
                      , p = l.start()
                      , m = l.end()
                      , b = r.doc.textBetween(p, m, `
`, `
`).split(`
`);
                    let C = 0
                      , S = 0;
                    const w = h - p;
                    for (let $ = 0; $ < b.length; $ += 1) {
                        if (S + b[$].length >= w) {
                            C = $;
                            break
                        }
                        S += b[$].length + 1
                    }
                    const A = ((f = b[C].match(/^ */)) == null ? void 0 : f[0]) || ""
                      , O = Math.min(A.length, n);
                    if (O === 0)
                        return !0;
                    let B = p;
                    for (let $ = 0; $ < C; $ += 1)
                        B += b[$].length + 1;
                    return u.delete(B, B + O),
                    h - B <= O && u.setSelection(se.create(u.doc, B)),
                    !0
                }
                ) : t.commands.command( ({tr: u}) => {
                    const {from: f, to: h} = o
                      , y = r.doc.textBetween(f, h, `
`, `
`).split(`
`).map(b => {
                        var C;
                        const S = ((C = b.match(/^ */)) == null ? void 0 : C[0]) || ""
                          , w = Math.min(S.length, n);
                        return b.slice(w)
                    }
                    ).join(`
`);
                    return u.replaceWith(f, h, r.schema.text(y)),
                    !0
                }
                )
            }
            ,
            Enter: ({editor: t}) => {
                if (!this.options.exitOnTripleEnter)
                    return !1;
                const {state: e} = t
                  , {selection: n} = e
                  , {$from: r, empty: o} = n;
                if (!o || r.parent.type !== this.type)
                    return !1;
                const l = r.parentOffset === r.parent.nodeSize - 2
                  , a = r.parent.textContent.endsWith(`

`);
                return !l || !a ? !1 : t.chain().command( ({tr: u}) => (u.delete(r.pos - 2, r.pos),
                !0)).exitCode().run()
            }
            ,
            ArrowDown: ({editor: t}) => {
                if (!this.options.exitOnArrowDown)
                    return !1;
                const {state: e} = t
                  , {selection: n, doc: r} = e
                  , {$from: o, empty: l} = n;
                if (!l || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
                    return !1;
                const u = o.after();
                return u === void 0 ? !1 : r.nodeAt(u) ? t.commands.command( ({tr: h}) => (h.setSelection(ye.near(r.resolve(u))),
                !0)) : t.commands.exitCode()
            }
        }
    },
    addInputRules() {
        return [zm({
            find: S8,
            type: this.type,
            getAttributes: t => ({
                language: t[1]
            })
        }), zm({
            find: x8,
            type: this.type,
            getAttributes: t => ({
                language: t[1]
            })
        })]
    },
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("codeBlockVSCodeHandler"),
            props: {
                handlePaste: (t, e) => {
                    if (!e.clipboardData || this.editor.isActive(this.type.name))
                        return !1;
                    const n = e.clipboardData.getData("text/plain")
                      , r = e.clipboardData.getData("vscode-editor-data")
                      , o = r ? JSON.parse(r) : void 0
                      , l = o?.mode;
                    if (!n || !l)
                        return !1;
                    const {tr: a, schema: u} = t.state
                      , f = u.text(n.replace(/\r\n?/g, `
`));
                    return a.replaceSelectionWith(this.type.create({
                        language: l
                    }, f)),
                    a.selection.$from.parent.type !== this.type && a.setSelection(se.near(a.doc.resolve(Math.max(0, a.selection.from - 2)))),
                    a.setMeta("paste", !0),
                    t.dispatch(a),
                    !0
                }
            }
        })]
    }
})
  , E8 = Nt.create({
    name: "doc",
    topNode: !0,
    content: "block+",
    renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `

`) : ""
})
  , T8 = Nt.create({
    name: "hardBreak",
    markdownTokenName: "br",
    addOptions() {
        return {
            keepMarks: !0,
            HTMLAttributes: {}
        }
    },
    inline: !0,
    group: "inline",
    selectable: !1,
    linebreakReplacement: !0,
    parseHTML() {
        return [{
            tag: "br"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["br", We(this.options.HTMLAttributes, t)]
    },
    renderText() {
        return `
`
    },
    renderMarkdown: () => `  
`,
    parseMarkdown: () => ({
        type: "hardBreak"
    }),
    addCommands() {
        return {
            setHardBreak: () => ({commands: t, chain: e, state: n, editor: r}) => t.first([ () => t.exitCode(), () => t.command( () => {
                const {selection: o, storedMarks: l} = n;
                if (o.$from.parent.type.spec.isolating)
                    return !1;
                const {keepMarks: a} = this.options
                  , {splittableMarks: u} = r.extensionManager
                  , f = l || o.$to.parentOffset && o.$from.marks();
                return e().insertContent({
                    type: this.name
                }).command( ({tr: h, dispatch: p}) => {
                    if (p && f && a) {
                        const m = f.filter(y => u.includes(y.type.name));
                        h.ensureMarks(m)
                    }
                    return !0
                }
                ).run()
            }
            )])
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Enter": () => this.editor.commands.setHardBreak(),
            "Shift-Enter": () => this.editor.commands.setHardBreak()
        }
    }
})
  , k8 = Nt.create({
    name: "heading",
    addOptions() {
        return {
            levels: [1, 2, 3, 4, 5, 6],
            HTMLAttributes: {}
        }
    },
    content: "inline*",
    group: "block",
    defining: !0,
    addAttributes() {
        return {
            level: {
                default: 1,
                rendered: !1
            }
        }
    },
    parseHTML() {
        return this.options.levels.map(t => ({
            tag: `h${t}`,
            attrs: {
                level: t
            }
        }))
    },
    renderHTML({node: t, HTMLAttributes: e}) {
        return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, We(this.options.HTMLAttributes, e), 0]
    },
    parseMarkdown: (t, e) => e.createNode("heading", {
        level: t.depth || 1
    }, e.parseInline(t.tokens || [])),
    renderMarkdown: (t, e) => {
        var n;
        const r = (n = t.attrs) != null && n.level ? parseInt(t.attrs.level, 10) : 1
          , o = "#".repeat(r);
        return t.content ? `${o} ${e.renderChildren(t.content)}` : ""
    }
    ,
    addCommands() {
        return {
            setHeading: t => ({commands: e}) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
            toggleHeading: t => ({commands: e}) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
        }
    },
    addKeyboardShortcuts() {
        return this.options.levels.reduce( (t, e) => ({
            ...t,
            [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({
                level: e
            })
        }), {})
    },
    addInputRules() {
        return this.options.levels.map(t => zm({
            find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
            type: this.type,
            getAttributes: {
                level: t
            }
        }))
    }
})
  , M8 = Nt.create({
    name: "horizontalRule",
    addOptions() {
        return {
            HTMLAttributes: {},
            nextNodeType: "paragraph"
        }
    },
    group: "block",
    parseHTML() {
        return [{
            tag: "hr"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["hr", We(this.options.HTMLAttributes, t)]
    },
    markdownTokenName: "hr",
    parseMarkdown: (t, e) => e.createNode("horizontalRule"),
    renderMarkdown: () => "---",
    addCommands() {
        return {
            setHorizontalRule: () => ({chain: t, state: e}) => {
                if (!eA(e, e.schema.nodes[this.name]))
                    return !1;
                const {selection: n} = e
                  , {$to: r} = n
                  , o = t();
                return f3(n) ? o.insertContentAt(r.pos, {
                    type: this.name
                }) : o.insertContent({
                    type: this.name
                }),
                o.command( ({state: l, tr: a, dispatch: u}) => {
                    if (u) {
                        const {$to: f} = a.selection
                          , h = f.end();
                        if (f.nodeAfter)
                            f.nodeAfter.isTextblock ? a.setSelection(se.create(a.doc, f.pos + 1)) : f.nodeAfter.isBlock ? a.setSelection(le.create(a.doc, f.pos)) : a.setSelection(se.create(a.doc, f.pos));
                        else {
                            const p = l.schema.nodes[this.options.nextNodeType] || f.parent.type.contentMatch.defaultType
                              , m = p?.create();
                            m && (a.insert(h, m),
                            a.setSelection(se.create(a.doc, h + 1)))
                        }
                        a.scrollIntoView()
                    }
                    return !0
                }
                ).run()
            }
        }
    },
    addInputRules() {
        return [QM({
            find: /^(?:---|-|___\s|\*\*\*\s)$/,
            type: this.type
        })]
    }
})
  , A8 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/
  , N8 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g
  , R8 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/
  , O8 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g
  , D8 = Mo.create({
    name: "italic",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "em"
        }, {
            tag: "i",
            getAttrs: t => t.style.fontStyle !== "normal" && null
        }, {
            style: "font-style=normal",
            clearMark: t => t.type.name === this.name
        }, {
            style: "font-style=italic"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["em", We(this.options.HTMLAttributes, t), 0]
    },
    addCommands() {
        return {
            setItalic: () => ({commands: t}) => t.setMark(this.name),
            toggleItalic: () => ({commands: t}) => t.toggleMark(this.name),
            unsetItalic: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    markdownTokenName: "em",
    parseMarkdown: (t, e) => e.applyMark("italic", e.parseInline(t.tokens || [])),
    renderMarkdown: (t, e) => `*${e.renderChildren(t)}*`,
    addKeyboardShortcuts() {
        return {
            "Mod-i": () => this.editor.commands.toggleItalic(),
            "Mod-I": () => this.editor.commands.toggleItalic()
        }
    },
    addInputRules() {
        return [Bl({
            find: A8,
            type: this.type
        }), Bl({
            find: R8,
            type: this.type
        })]
    },
    addPasteRules() {
        return [xo({
            find: N8,
            type: this.type
        }), xo({
            find: O8,
            type: this.type
        })]
    }
});
const L8 = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2"
  , z8 = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222"
  , jm = "numeric"
  , Hm = "ascii"
  , Im = "alpha"
  , na = "asciinumeric"
  , Ys = "alphanumeric"
  , Vm = "domain"
  , _3 = "emoji"
  , _8 = "scheme"
  , B8 = "slashscheme"
  , Fp = "whitespace";
function j8(t, e) {
    return t in e || (e[t] = []),
    e[t]
}
function fo(t, e, n) {
    e[jm] && (e[na] = !0,
    e[Ys] = !0),
    e[Hm] && (e[na] = !0,
    e[Im] = !0),
    e[na] && (e[Ys] = !0),
    e[Im] && (e[Ys] = !0),
    e[Ys] && (e[Vm] = !0),
    e[_3] && (e[Vm] = !0);
    for (const r in e) {
        const o = j8(r, n);
        o.indexOf(t) < 0 && o.push(t)
    }
}
function H8(t, e) {
    const n = {};
    for (const r in e)
        e[r].indexOf(t) >= 0 && (n[r] = !0);
    return n
}
function Yt(t=null) {
    this.j = {},
    this.jr = [],
    this.jd = null,
    this.t = t
}
Yt.groups = {};
Yt.prototype = {
    accepts() {
        return !!this.t
    },
    go(t) {
        const e = this
          , n = e.j[t];
        if (n)
            return n;
        for (let r = 0; r < e.jr.length; r++) {
            const o = e.jr[r][0]
              , l = e.jr[r][1];
            if (l && o.test(t))
                return l
        }
        return e.jd
    },
    has(t, e=!1) {
        return e ? t in this.j : !!this.go(t)
    },
    ta(t, e, n, r) {
        for (let o = 0; o < t.length; o++)
            this.tt(t[o], e, n, r)
    },
    tr(t, e, n, r) {
        r = r || Yt.groups;
        let o;
        return e && e.j ? o = e : (o = new Yt(e),
        n && r && fo(e, n, r)),
        this.jr.push([t, o]),
        o
    },
    ts(t, e, n, r) {
        let o = this;
        const l = t.length;
        if (!l)
            return o;
        for (let a = 0; a < l - 1; a++)
            o = o.tt(t[a]);
        return o.tt(t[l - 1], e, n, r)
    },
    tt(t, e, n, r) {
        r = r || Yt.groups;
        const o = this;
        if (e && e.j)
            return o.j[t] = e,
            e;
        const l = e;
        let a, u = o.go(t);
        if (u ? (a = new Yt,
        Object.assign(a.j, u.j),
        a.jr.push.apply(a.jr, u.jr),
        a.jd = u.jd,
        a.t = u.t) : a = new Yt,
        l) {
            if (r)
                if (a.t && typeof a.t == "string") {
                    const f = Object.assign(H8(a.t, r), n);
                    fo(l, f, r)
                } else
                    n && fo(l, n, r);
            a.t = l
        }
        return o.j[t] = a,
        a
    }
};
const Ee = (t, e, n, r, o) => t.ta(e, n, r, o)
  , Qe = (t, e, n, r, o) => t.tr(e, n, r, o)
  , Qb = (t, e, n, r, o) => t.ts(e, n, r, o)
  , J = (t, e, n, r, o) => t.tt(e, n, r, o)
  , Er = "WORD"
  , Um = "UWORD"
  , B3 = "ASCIINUMERICAL"
  , j3 = "ALPHANUMERICAL"
  , ya = "LOCALHOST"
  , Pm = "TLD"
  , qm = "UTLD"
  , Cu = "SCHEME"
  , wl = "SLASH_SCHEME"
  , G1 = "NUM"
  , $m = "WS"
  , Y1 = "NL"
  , ra = "OPENBRACE"
  , ia = "CLOSEBRACE"
  , $u = "OPENBRACKET"
  , Fu = "CLOSEBRACKET"
  , Ku = "OPENPAREN"
  , Gu = "CLOSEPAREN"
  , Yu = "OPENANGLEBRACKET"
  , Zu = "CLOSEANGLEBRACKET"
  , Wu = "FULLWIDTHLEFTPAREN"
  , Xu = "FULLWIDTHRIGHTPAREN"
  , Ju = "LEFTCORNERBRACKET"
  , Qu = "RIGHTCORNERBRACKET"
  , ef = "LEFTWHITECORNERBRACKET"
  , tf = "RIGHTWHITECORNERBRACKET"
  , nf = "FULLWIDTHLESSTHAN"
  , rf = "FULLWIDTHGREATERTHAN"
  , of = "AMPERSAND"
  , lf = "APOSTROPHE"
  , sf = "ASTERISK"
  , di = "AT"
  , af = "BACKSLASH"
  , cf = "BACKTICK"
  , uf = "CARET"
  , mi = "COLON"
  , Z1 = "COMMA"
  , ff = "DOLLAR"
  , Pn = "DOT"
  , df = "EQUALS"
  , W1 = "EXCLAMATION"
  , Tn = "HYPHEN"
  , oa = "PERCENT"
  , hf = "PIPE"
  , pf = "PLUS"
  , mf = "POUND"
  , la = "QUERY"
  , X1 = "QUOTE"
  , H3 = "FULLWIDTHMIDDLEDOT"
  , J1 = "SEMI"
  , qn = "SLASH"
  , sa = "TILDE"
  , gf = "UNDERSCORE"
  , I3 = "EMOJI"
  , yf = "SYM";
var V3 = Object.freeze({
    __proto__: null,
    ALPHANUMERICAL: j3,
    AMPERSAND: of,
    APOSTROPHE: lf,
    ASCIINUMERICAL: B3,
    ASTERISK: sf,
    AT: di,
    BACKSLASH: af,
    BACKTICK: cf,
    CARET: uf,
    CLOSEANGLEBRACKET: Zu,
    CLOSEBRACE: ia,
    CLOSEBRACKET: Fu,
    CLOSEPAREN: Gu,
    COLON: mi,
    COMMA: Z1,
    DOLLAR: ff,
    DOT: Pn,
    EMOJI: I3,
    EQUALS: df,
    EXCLAMATION: W1,
    FULLWIDTHGREATERTHAN: rf,
    FULLWIDTHLEFTPAREN: Wu,
    FULLWIDTHLESSTHAN: nf,
    FULLWIDTHMIDDLEDOT: H3,
    FULLWIDTHRIGHTPAREN: Xu,
    HYPHEN: Tn,
    LEFTCORNERBRACKET: Ju,
    LEFTWHITECORNERBRACKET: ef,
    LOCALHOST: ya,
    NL: Y1,
    NUM: G1,
    OPENANGLEBRACKET: Yu,
    OPENBRACE: ra,
    OPENBRACKET: $u,
    OPENPAREN: Ku,
    PERCENT: oa,
    PIPE: hf,
    PLUS: pf,
    POUND: mf,
    QUERY: la,
    QUOTE: X1,
    RIGHTCORNERBRACKET: Qu,
    RIGHTWHITECORNERBRACKET: tf,
    SCHEME: Cu,
    SEMI: J1,
    SLASH: qn,
    SLASH_SCHEME: wl,
    SYM: yf,
    TILDE: sa,
    TLD: Pm,
    UNDERSCORE: gf,
    UTLD: qm,
    UWORD: Um,
    WORD: Er,
    WS: $m
});
const xr = /[a-z]/
  , Us = new RegExp("\\p{L}","u")
  , Kp = new RegExp("\\p{Emoji}","u")
  , wr = /\d/
  , Gp = /\s/
  , eC = "\r"
  , Yp = `
`
  , I8 = ""
  , V8 = ""
  , Zp = "";
let nu = null
  , ru = null;
function U8(t=[]) {
    const e = {};
    Yt.groups = e;
    const n = new Yt;
    nu == null && (nu = tC(L8)),
    ru == null && (ru = tC(z8)),
    J(n, "'", lf),
    J(n, "{", ra),
    J(n, "}", ia),
    J(n, "[", $u),
    J(n, "]", Fu),
    J(n, "(", Ku),
    J(n, ")", Gu),
    J(n, "<", Yu),
    J(n, ">", Zu),
    J(n, "", Wu),
    J(n, "", Xu),
    J(n, "", Ju),
    J(n, "", Qu),
    J(n, "", ef),
    J(n, "", tf),
    J(n, "", nf),
    J(n, "", rf),
    J(n, "&", of),
    J(n, "*", sf),
    J(n, "@", di),
    J(n, "`", cf),
    J(n, "^", uf),
    J(n, ":", mi),
    J(n, ",", Z1),
    J(n, "$", ff),
    J(n, ".", Pn),
    J(n, "=", df),
    J(n, "!", W1),
    J(n, "-", Tn),
    J(n, "%", oa),
    J(n, "|", hf),
    J(n, "+", pf),
    J(n, "#", mf),
    J(n, "?", la),
    J(n, '"', X1),
    J(n, "/", qn),
    J(n, ";", J1),
    J(n, "~", sa),
    J(n, "_", gf),
    J(n, "\\", af),
    J(n, "", H3);
    const r = Qe(n, wr, G1, {
        [jm]: !0
    });
    Qe(r, wr, r);
    const o = Qe(r, xr, B3, {
        [na]: !0
    })
      , l = Qe(r, Us, j3, {
        [Ys]: !0
    })
      , a = Qe(n, xr, Er, {
        [Hm]: !0
    });
    Qe(a, wr, o),
    Qe(a, xr, a),
    Qe(o, wr, o),
    Qe(o, xr, o);
    const u = Qe(n, Us, Um, {
        [Im]: !0
    });
    Qe(u, xr),
    Qe(u, wr, l),
    Qe(u, Us, u),
    Qe(l, wr, l),
    Qe(l, xr),
    Qe(l, Us, l);
    const f = J(n, Yp, Y1, {
        [Fp]: !0
    })
      , h = J(n, eC, $m, {
        [Fp]: !0
    })
      , p = Qe(n, Gp, $m, {
        [Fp]: !0
    });
    J(n, Zp, p),
    J(h, Yp, f),
    J(h, Zp, p),
    Qe(h, Gp, p),
    J(p, eC),
    J(p, Yp),
    Qe(p, Gp, p),
    J(p, Zp, p);
    const m = Qe(n, Kp, I3, {
        [_3]: !0
    });
    J(m, "#"),
    Qe(m, Kp, m),
    J(m, I8, m);
    const y = J(m, V8);
    J(y, "#"),
    Qe(y, Kp, m);
    const b = [[xr, a], [wr, o]]
      , C = [[xr, null], [Us, u], [wr, l]];
    for (let S = 0; S < nu.length; S++)
        ai(n, nu[S], Pm, Er, b);
    for (let S = 0; S < ru.length; S++)
        ai(n, ru[S], qm, Um, C);
    fo(Pm, {
        tld: !0,
        ascii: !0
    }, e),
    fo(qm, {
        utld: !0,
        alpha: !0
    }, e),
    ai(n, "file", Cu, Er, b),
    ai(n, "mailto", Cu, Er, b),
    ai(n, "http", wl, Er, b),
    ai(n, "https", wl, Er, b),
    ai(n, "ftp", wl, Er, b),
    ai(n, "ftps", wl, Er, b),
    fo(Cu, {
        scheme: !0,
        ascii: !0
    }, e),
    fo(wl, {
        slashscheme: !0,
        ascii: !0
    }, e),
    t = t.sort( (S, w) => S[0] > w[0] ? 1 : -1);
    for (let S = 0; S < t.length; S++) {
        const w = t[S][0]
          , A = t[S][1] ? {
            [_8]: !0
        } : {
            [B8]: !0
        };
        w.indexOf("-") >= 0 ? A[Vm] = !0 : xr.test(w) ? wr.test(w) ? A[na] = !0 : A[Hm] = !0 : A[jm] = !0,
        Qb(n, w, w, A)
    }
    return Qb(n, "localhost", ya, {
        ascii: !0
    }),
    n.jd = new Yt(yf),
    {
        start: n,
        tokens: Object.assign({
            groups: e
        }, V3)
    }
}
function U3(t, e) {
    const n = P8(e.replace(/[A-Z]/g, u => u.toLowerCase()))
      , r = n.length
      , o = [];
    let l = 0
      , a = 0;
    for (; a < r; ) {
        let u = t
          , f = null
          , h = 0
          , p = null
          , m = -1
          , y = -1;
        for (; a < r && (f = u.go(n[a])); )
            u = f,
            u.accepts() ? (m = 0,
            y = 0,
            p = u) : m >= 0 && (m += n[a].length,
            y++),
            h += n[a].length,
            l += n[a].length,
            a++;
        l -= m,
        a -= y,
        h -= m,
        o.push({
            t: p.t,
            v: e.slice(l - h, l),
            s: l - h,
            e: l
        })
    }
    return o
}
function P8(t) {
    const e = []
      , n = t.length;
    let r = 0;
    for (; r < n; ) {
        let o = t.charCodeAt(r), l, a = o < 55296 || o > 56319 || r + 1 === n || (l = t.charCodeAt(r + 1)) < 56320 || l > 57343 ? t[r] : t.slice(r, r + 2);
        e.push(a),
        r += a.length
    }
    return e
}
function ai(t, e, n, r, o) {
    let l;
    const a = e.length;
    for (let u = 0; u < a - 1; u++) {
        const f = e[u];
        t.j[f] ? l = t.j[f] : (l = new Yt(r),
        l.jr = o.slice(),
        t.j[f] = l),
        t = l
    }
    return l = new Yt(n),
    l.jr = o.slice(),
    t.j[e[a - 1]] = l,
    l
}
function tC(t) {
    const e = []
      , n = [];
    let r = 0
      , o = "0123456789";
    for (; r < t.length; ) {
        let l = 0;
        for (; o.indexOf(t[r + l]) >= 0; )
            l++;
        if (l > 0) {
            e.push(n.join(""));
            for (let a = parseInt(t.substring(r, r + l), 10); a > 0; a--)
                n.pop();
            r += l
        } else
            n.push(t[r]),
            r++
    }
    return e
}
const va = {
    defaultProtocol: "http",
    events: null,
    format: nC,
    formatHref: nC,
    nl2br: !1,
    tagName: "a",
    target: null,
    rel: null,
    validate: !0,
    truncate: 1 / 0,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null
};
function Q1(t, e=null) {
    let n = Object.assign({}, va);
    t && (n = Object.assign(n, t instanceof Q1 ? t.o : t));
    const r = n.ignoreTags
      , o = [];
    for (let l = 0; l < r.length; l++)
        o.push(r[l].toUpperCase());
    this.o = n,
    e && (this.defaultRender = e),
    this.ignoreTags = o
}
Q1.prototype = {
    o: va,
    ignoreTags: [],
    defaultRender(t) {
        return t
    },
    check(t) {
        return this.get("validate", t.toString(), t)
    },
    get(t, e, n) {
        const r = e != null;
        let o = this.o[t];
        return o && (typeof o == "object" ? (o = n.t in o ? o[n.t] : va[t],
        typeof o == "function" && r && (o = o(e, n))) : typeof o == "function" && r && (o = o(e, n.t, n)),
        o)
    },
    getObj(t, e, n) {
        let r = this.o[t];
        return typeof r == "function" && e != null && (r = r(e, n.t, n)),
        r
    },
    render(t) {
        const e = t.render(this);
        return (this.get("render", null, t) || this.defaultRender)(e, t.t, t)
    }
};
function nC(t) {
    return t
}
function P3(t, e) {
    this.t = "token",
    this.v = t,
    this.tk = e
}
P3.prototype = {
    isLink: !1,
    toString() {
        return this.v
    },
    toHref(t) {
        return this.toString()
    },
    toFormattedString(t) {
        const e = this.toString()
          , n = t.get("truncate", e, this)
          , r = t.get("format", e, this);
        return n && r.length > n ? r.substring(0, n) + "" : r
    },
    toFormattedHref(t) {
        return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this)
    },
    startIndex() {
        return this.tk[0].s
    },
    endIndex() {
        return this.tk[this.tk.length - 1].e
    },
    toObject(t=va.defaultProtocol) {
        return {
            type: this.t,
            value: this.toString(),
            isLink: this.isLink,
            href: this.toHref(t),
            start: this.startIndex(),
            end: this.endIndex()
        }
    },
    toFormattedObject(t) {
        return {
            type: this.t,
            value: this.toFormattedString(t),
            isLink: this.isLink,
            href: this.toFormattedHref(t),
            start: this.startIndex(),
            end: this.endIndex()
        }
    },
    validate(t) {
        return t.get("validate", this.toString(), this)
    },
    render(t) {
        const e = this
          , n = this.toHref(t.get("defaultProtocol"))
          , r = t.get("formatHref", n, this)
          , o = t.get("tagName", n, e)
          , l = this.toFormattedString(t)
          , a = {}
          , u = t.get("className", n, e)
          , f = t.get("target", n, e)
          , h = t.get("rel", n, e)
          , p = t.getObj("attributes", n, e)
          , m = t.getObj("events", n, e);
        return a.href = r,
        u && (a.class = u),
        f && (a.target = f),
        h && (a.rel = h),
        p && Object.assign(a, p),
        {
            tagName: o,
            attributes: a,
            content: l,
            eventListeners: m
        }
    }
};
function Pf(t, e) {
    class n extends P3 {
        constructor(o, l) {
            super(o, l),
            this.t = t
        }
    }
    for (const r in e)
        n.prototype[r] = e[r];
    return n.t = t,
    n
}
const rC = Pf("email", {
    isLink: !0,
    toHref() {
        return "mailto:" + this.toString()
    }
})
  , iC = Pf("text")
  , q8 = Pf("nl")
  , iu = Pf("url", {
    isLink: !0,
    toHref(t=va.defaultProtocol) {
        return this.hasProtocol() ? this.v : `${t}://${this.v}`
    },
    hasProtocol() {
        const t = this.tk;
        return t.length >= 2 && t[0].t !== ya && t[1].t === mi
    }
})
  , wn = t => new Yt(t);
function $8({groups: t}) {
    const e = t.domain.concat([of, sf, di, af, cf, uf, ff, df, Tn, G1, oa, hf, pf, mf, qn, yf, sa, gf])
      , n = [lf, mi, Z1, Pn, W1, oa, la, X1, J1, Yu, Zu, ra, ia, Fu, $u, Ku, Gu, Wu, Xu, Ju, Qu, ef, tf, nf, rf]
      , r = [of, lf, sf, af, cf, uf, ff, df, Tn, ra, ia, oa, hf, pf, mf, la, qn, yf, sa, gf]
      , o = wn()
      , l = J(o, sa);
    Ee(l, r, l),
    Ee(l, t.domain, l);
    const a = wn()
      , u = wn()
      , f = wn();
    Ee(o, t.domain, a),
    Ee(o, t.scheme, u),
    Ee(o, t.slashscheme, f),
    Ee(a, r, l),
    Ee(a, t.domain, a);
    const h = J(a, di);
    J(l, di, h),
    J(u, di, h),
    J(f, di, h);
    const p = J(l, Pn);
    Ee(p, r, l),
    Ee(p, t.domain, l);
    const m = wn();
    Ee(h, t.domain, m),
    Ee(m, t.domain, m);
    const y = J(m, Pn);
    Ee(y, t.domain, m);
    const b = wn(rC);
    Ee(y, t.tld, b),
    Ee(y, t.utld, b),
    J(h, ya, b);
    const C = J(m, Tn);
    J(C, Tn, C),
    Ee(C, t.domain, m),
    Ee(b, t.domain, m),
    J(b, Pn, y),
    J(b, Tn, C);
    const S = J(b, mi);
    Ee(S, t.numeric, rC);
    const w = J(a, Tn)
      , k = J(a, Pn);
    J(w, Tn, w),
    Ee(w, t.domain, a),
    Ee(k, r, l),
    Ee(k, t.domain, a);
    const A = wn(iu);
    Ee(k, t.tld, A),
    Ee(k, t.utld, A),
    Ee(A, t.domain, a),
    Ee(A, r, l),
    J(A, Pn, k),
    J(A, Tn, w),
    J(A, di, h);
    const O = J(A, mi)
      , B = wn(iu);
    Ee(O, t.numeric, B);
    const z = wn(iu)
      , $ = wn();
    Ee(z, e, z),
    Ee(z, n, $),
    Ee($, e, z),
    Ee($, n, $),
    J(A, qn, z),
    J(B, qn, z);
    const _ = J(u, mi)
      , W = J(f, mi)
      , ne = J(W, qn)
      , de = J(ne, qn);
    Ee(u, t.domain, a),
    J(u, Pn, k),
    J(u, Tn, w),
    Ee(f, t.domain, a),
    J(f, Pn, k),
    J(f, Tn, w),
    Ee(_, t.domain, z),
    J(_, qn, z),
    J(_, la, z),
    Ee(de, t.domain, z),
    Ee(de, e, z),
    J(de, qn, z);
    const ve = [[ra, ia], [$u, Fu], [Ku, Gu], [Yu, Zu], [Wu, Xu], [Ju, Qu], [ef, tf], [nf, rf]];
    for (let pe = 0; pe < ve.length; pe++) {
        const [be,Q] = ve[pe]
          , ae = J(z, be);
        J($, be, ae),
        J(ae, Q, z);
        const j = wn(iu);
        Ee(ae, e, j);
        const P = wn();
        Ee(ae, n),
        Ee(j, e, j),
        Ee(j, n, P),
        Ee(P, e, j),
        Ee(P, n, P),
        J(j, Q, z),
        J(P, Q, z)
    }
    return J(o, ya, A),
    J(o, Y1, q8),
    {
        start: o,
        tokens: V3
    }
}
function F8(t, e, n) {
    let r = n.length
      , o = 0
      , l = []
      , a = [];
    for (; o < r; ) {
        let u = t
          , f = null
          , h = null
          , p = 0
          , m = null
          , y = -1;
        for (; o < r && !(f = u.go(n[o].t)); )
            a.push(n[o++]);
        for (; o < r && (h = f || u.go(n[o].t)); )
            f = null,
            u = h,
            u.accepts() ? (y = 0,
            m = u) : y >= 0 && y++,
            o++,
            p++;
        if (y < 0)
            o -= p,
            o < r && (a.push(n[o]),
            o++);
        else {
            a.length > 0 && (l.push(Wp(iC, e, a)),
            a = []),
            o -= y,
            p -= y;
            const b = m.t
              , C = n.slice(o - p, o);
            l.push(Wp(b, e, C))
        }
    }
    return a.length > 0 && l.push(Wp(iC, e, a)),
    l
}
function Wp(t, e, n) {
    const r = n[0].s
      , o = n[n.length - 1].e
      , l = e.slice(r, o);
    return new t(l,n)
}
const K8 = typeof console < "u" && console && console.warn || ( () => {}
)
  , G8 = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time."
  , Ke = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: !1
};
function Y8() {
    return Yt.groups = {},
    Ke.scanner = null,
    Ke.parser = null,
    Ke.tokenQueue = [],
    Ke.pluginQueue = [],
    Ke.customSchemes = [],
    Ke.initialized = !1,
    Ke
}
function oC(t, e=!1) {
    if (Ke.initialized && K8(`linkifyjs: already initialized - will not register custom scheme "${t}" ${G8}`),
    !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
        throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    Ke.customSchemes.push([t, e])
}
function Z8() {
    Ke.scanner = U8(Ke.customSchemes);
    for (let t = 0; t < Ke.tokenQueue.length; t++)
        Ke.tokenQueue[t][1]({
            scanner: Ke.scanner
        });
    Ke.parser = $8(Ke.scanner.tokens);
    for (let t = 0; t < Ke.pluginQueue.length; t++)
        Ke.pluginQueue[t][1]({
            scanner: Ke.scanner,
            parser: Ke.parser
        });
    return Ke.initialized = !0,
    Ke
}
function eg(t) {
    return Ke.initialized || Z8(),
    F8(Ke.parser.start, t, U3(Ke.scanner.start, t))
}
eg.scan = U3;
function q3(t, e=null, n=null) {
    if (e && typeof e == "object") {
        if (n)
            throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
        n = e,
        e = null
    }
    const r = new Q1(n)
      , o = eg(t)
      , l = [];
    for (let a = 0; a < o.length; a++) {
        const u = o[a];
        u.isLink && (!e || u.t === e) && r.check(u) && l.push(u.toFormattedObject(r))
    }
    return l
}
var tg = "[\0- -\u2029]"
  , W8 = new RegExp(tg)
  , X8 = new RegExp(`${tg}$`)
  , J8 = new RegExp(tg,"g");
function Q8(t) {
    return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1
}
function eN(t) {
    return new Ye({
        key: new nt("autolink"),
        appendTransaction: (e, n, r) => {
            const o = e.some(h => h.docChanged) && !n.doc.eq(r.doc)
              , l = e.some(h => h.getMeta("preventAutolink"));
            if (!o || l)
                return;
            const {tr: a} = r
              , u = n3(n.doc, [...e]);
            if (u3(u).forEach( ({newRange: h}) => {
                const p = tM(r.doc, h, b => b.isTextblock);
                let m, y;
                if (p.length > 1)
                    m = p[0],
                    y = r.doc.textBetween(m.pos, m.pos + m.node.nodeSize, void 0, " ");
                else if (p.length) {
                    const b = r.doc.textBetween(h.from, h.to, " ", " ");
                    if (!X8.test(b))
                        return;
                    m = p[0],
                    y = r.doc.textBetween(m.pos, h.to, void 0, " ")
                }
                if (m && y) {
                    const b = y.split(W8).filter(Boolean);
                    if (b.length <= 0)
                        return !1;
                    const C = b[b.length - 1]
                      , S = m.pos + y.lastIndexOf(C);
                    if (!C)
                        return !1;
                    const w = eg(C).map(k => k.toObject(t.defaultProtocol));
                    if (!Q8(w))
                        return !1;
                    w.filter(k => k.isLink).map(k => ({
                        ...k,
                        from: S + k.start + 1,
                        to: S + k.end + 1
                    })).filter(k => r.schema.marks.code ? !r.doc.rangeHasMark(k.from, k.to, r.schema.marks.code) : !0).filter(k => t.validate(k.value)).filter(k => t.shouldAutoLink(k.value)).forEach(k => {
                        V1(k.from, k.to, r.doc).some(A => A.mark.type === t.type) || a.addMark(k.from, k.to, t.type.create({
                            href: k.href
                        }))
                    }
                    )
                }
            }
            ),
            !!a.steps.length)
                return a
        }
    })
}
function tN(t) {
    return new Ye({
        key: new nt("handleClickLink"),
        props: {
            handleClick: (e, n, r) => {
                var o, l;
                if (r.button !== 0 || !e.editable)
                    return !1;
                let a = null;
                if (r.target instanceof HTMLAnchorElement)
                    a = r.target;
                else {
                    const f = r.target;
                    if (!f)
                        return !1;
                    const h = t.editor.view.dom;
                    a = f.closest("a"),
                    a && !h.contains(a) && (a = null)
                }
                if (!a)
                    return !1;
                let u = !1;
                if (t.enableClickSelection && (u = t.editor.commands.extendMarkRange(t.type.name)),
                t.openOnClick) {
                    const f = c3(e.state, t.type.name)
                      , h = (o = a.href) != null ? o : f.href
                      , p = (l = a.target) != null ? l : f.target;
                    h && (window.open(h, p),
                    u = !0)
                }
                return u
            }
        }
    })
}
function nN(t) {
    return new Ye({
        key: new nt("handlePasteLink"),
        props: {
            handlePaste: (e, n, r) => {
                const {shouldAutoLink: o} = t
                  , {state: l} = e
                  , {selection: a} = l
                  , {empty: u} = a;
                if (u)
                    return !1;
                let f = "";
                r.content.forEach(p => {
                    f += p.textContent
                }
                );
                const h = q3(f, {
                    defaultProtocol: t.defaultProtocol
                }).find(p => p.isLink && p.value === f);
                return !f || !h || o !== void 0 && !o(h.value) ? !1 : t.editor.commands.setMark(t.type, {
                    href: h.href
                })
            }
        }
    })
}
function io(t, e) {
    const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
    return e && e.forEach(r => {
        const o = typeof r == "string" ? r : r.scheme;
        o && n.push(o)
    }
    ),
    !t || t.replace(J8, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,"i"))
}
var $3 = Mo.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: !1,
    exitable: !0,
    onCreate() {
        this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate,
        console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")),
        this.options.protocols.forEach(t => {
            if (typeof t == "string") {
                oC(t);
                return
            }
            oC(t.scheme, t.optionalSlashes)
        }
        )
    },
    onDestroy() {
        Y8()
    },
    inclusive() {
        return this.options.autolink
    },
    addOptions() {
        return {
            openOnClick: !0,
            enableClickSelection: !1,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            defaultProtocol: "http",
            HTMLAttributes: {
                target: "_blank",
                rel: "noopener noreferrer nofollow",
                class: null
            },
            isAllowedUri: (t, e) => !!io(t, e.protocols),
            validate: t => !!t,
            shouldAutoLink: t => {
                const e = /^[a-z][a-z0-9+.-]*:\/\//i.test(t)
                  , n = /^[a-z][a-z0-9+.-]*:/i.test(t);
                if (e || n && !t.includes("@"))
                    return !0;
                const o = (t.includes("@") ? t.split("@").pop() : t).split(/[/?#:]/)[0];
                return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(o) || !/\./.test(o))
            }
        }
    },
    addAttributes() {
        return {
            href: {
                default: null,
                parseHTML(t) {
                    return t.getAttribute("href")
                }
            },
            target: {
                default: this.options.HTMLAttributes.target
            },
            rel: {
                default: this.options.HTMLAttributes.rel
            },
            class: {
                default: this.options.HTMLAttributes.class
            },
            title: {
                default: null
            }
        }
    },
    parseHTML() {
        return [{
            tag: "a[href]",
            getAttrs: t => {
                const e = t.getAttribute("href");
                return !e || !this.options.isAllowedUri(e, {
                    defaultValidate: n => !!io(n, this.options.protocols),
                    protocols: this.options.protocols,
                    defaultProtocol: this.options.defaultProtocol
                }) ? !1 : null
            }
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return this.options.isAllowedUri(t.href, {
            defaultValidate: e => !!io(e, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
        }) ? ["a", We(this.options.HTMLAttributes, t), 0] : ["a", We(this.options.HTMLAttributes, {
            ...t,
            href: ""
        }), 0]
    },
    markdownTokenName: "link",
    parseMarkdown: (t, e) => e.applyMark("link", e.parseInline(t.tokens || []), {
        href: t.href,
        title: t.title || null
    }),
    renderMarkdown: (t, e) => {
        var n, r, o, l;
        const a = (r = (n = t.attrs) == null ? void 0 : n.href) != null ? r : ""
          , u = (l = (o = t.attrs) == null ? void 0 : o.title) != null ? l : ""
          , f = e.renderChildren(t);
        return u ? `[${f}](${a} "${u}")` : `[${f}](${a})`
    }
    ,
    addCommands() {
        return {
            setLink: t => ({chain: e}) => {
                const {href: n} = t;
                return this.options.isAllowedUri(n, {
                    defaultValidate: r => !!io(r, this.options.protocols),
                    protocols: this.options.protocols,
                    defaultProtocol: this.options.defaultProtocol
                }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1
            }
            ,
            toggleLink: t => ({chain: e}) => {
                const {href: n} = t || {};
                return n && !this.options.isAllowedUri(n, {
                    defaultValidate: r => !!io(r, this.options.protocols),
                    protocols: this.options.protocols,
                    defaultProtocol: this.options.defaultProtocol
                }) ? !1 : e().toggleMark(this.name, t, {
                    extendEmptyMarkRange: !0
                }).setMeta("preventAutolink", !0).run()
            }
            ,
            unsetLink: () => ({chain: t}) => t().unsetMark(this.name, {
                extendEmptyMarkRange: !0
            }).setMeta("preventAutolink", !0).run()
        }
    },
    addPasteRules() {
        return [xo({
            find: t => {
                const e = [];
                if (t) {
                    const {protocols: n, defaultProtocol: r} = this.options
                      , o = q3(t).filter(l => l.isLink && this.options.isAllowedUri(l.value, {
                        defaultValidate: a => !!io(a, n),
                        protocols: n,
                        defaultProtocol: r
                    }));
                    o.length && o.forEach(l => {
                        this.options.shouldAutoLink(l.value) && e.push({
                            text: l.value,
                            data: {
                                href: l.href
                            },
                            index: l.start
                        })
                    }
                    )
                }
                return e
            }
            ,
            type: this.type,
            getAttributes: t => {
                var e;
                return {
                    href: (e = t.data) == null ? void 0 : e.href
                }
            }
        })]
    },
    addProseMirrorPlugins() {
        const t = []
          , {protocols: e, defaultProtocol: n} = this.options;
        return this.options.autolink && t.push(eN({
            type: this.type,
            defaultProtocol: this.options.defaultProtocol,
            validate: r => this.options.isAllowedUri(r, {
                defaultValidate: o => !!io(o, e),
                protocols: e,
                defaultProtocol: n
            }),
            shouldAutoLink: this.options.shouldAutoLink
        })),
        t.push(tN({
            type: this.type,
            editor: this.editor,
            openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
            enableClickSelection: this.options.enableClickSelection
        })),
        this.options.linkOnPaste && t.push(nN({
            editor: this.editor,
            defaultProtocol: this.options.defaultProtocol,
            type: this.type,
            shouldAutoLink: this.options.shouldAutoLink
        })),
        t
    }
})
  , rN = $3
  , iN = Object.defineProperty
  , oN = (t, e) => {
    for (var n in e)
        iN(t, n, {
            get: e[n],
            enumerable: !0
        })
}
  , lN = "listItem"
  , lC = "textStyle"
  , sC = /^\s*([-+*])\s$/
  , F3 = Nt.create({
    name: "bulletList",
    addOptions() {
        return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: !1,
            keepAttributes: !1
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    parseHTML() {
        return [{
            tag: "ul"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["ul", We(this.options.HTMLAttributes, t), 0]
    },
    markdownTokenName: "list",
    parseMarkdown: (t, e) => t.type !== "list" || t.ordered ? [] : {
        type: "bulletList",
        content: t.items ? e.parseChildren(t.items) : []
    },
    renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
    markdownOptions: {
        indentsContent: !0
    },
    addCommands() {
        return {
            toggleBulletList: () => ({commands: t, chain: e}) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(lN, this.editor.getAttributes(lC)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
        }
    },
    addInputRules() {
        let t = jl({
            find: sC,
            type: this.type
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t = jl({
            find: sC,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: () => this.editor.getAttributes(lC),
            editor: this.editor
        })),
        [t]
    }
})
  , K3 = Nt.create({
    name: "listItem",
    addOptions() {
        return {
            HTMLAttributes: {},
            bulletListTypeName: "bulletList",
            orderedListTypeName: "orderedList"
        }
    },
    content: "paragraph block*",
    defining: !0,
    parseHTML() {
        return [{
            tag: "li"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["li", We(this.options.HTMLAttributes, t), 0]
    },
    markdownTokenName: "list_item",
    parseMarkdown: (t, e) => {
        if (t.type !== "list_item")
            return [];
        let n = [];
        if (t.tokens && t.tokens.length > 0)
            if (t.tokens.some(o => o.type === "paragraph"))
                n = e.parseChildren(t.tokens);
            else {
                const o = t.tokens[0];
                if (o && o.type === "text" && o.tokens && o.tokens.length > 0) {
                    if (n = [{
                        type: "paragraph",
                        content: e.parseInline(o.tokens)
                    }],
                    t.tokens.length > 1) {
                        const a = t.tokens.slice(1)
                          , u = e.parseChildren(a);
                        n.push(...u)
                    }
                } else
                    n = e.parseChildren(t.tokens)
            }
        return n.length === 0 && (n = [{
            type: "paragraph",
            content: []
        }]),
        {
            type: "listItem",
            content: n
        }
    }
    ,
    renderMarkdown: (t, e, n) => $1(t, e, r => {
        var o, l;
        return r.parentType === "bulletList" ? "- " : r.parentType === "orderedList" ? `${(((l = (o = r.meta) == null ? void 0 : o.parentAttrs) == null ? void 0 : l.start) || 1) + r.index}. ` : "- "
    }
    , n),
    addKeyboardShortcuts() {
        return {
            Enter: () => this.editor.commands.splitListItem(this.name),
            Tab: () => this.editor.commands.sinkListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        }
    }
})
  , sN = {};
oN(sN, {
    findListItemPos: () => Ta,
    getNextListDepth: () => ng,
    handleBackspace: () => Fm,
    handleDelete: () => Km,
    hasListBefore: () => G3,
    hasListItemAfter: () => aN,
    hasListItemBefore: () => Y3,
    listItemHasSubList: () => Z3,
    nextListIsDeeper: () => W3,
    nextListIsHigher: () => X3
});
var Ta = (t, e) => {
    const {$from: n} = e.selection
      , r = dt(t, e.schema);
    let o = null
      , l = n.depth
      , a = n.pos
      , u = null;
    for (; l > 0 && u === null; )
        o = n.node(l),
        o.type === r ? u = l : (l -= 1,
        a -= 1);
    return u === null ? null : {
        $pos: e.doc.resolve(a),
        depth: u
    }
}
  , ng = (t, e) => {
    const n = Ta(t, e);
    if (!n)
        return !1;
    const [,r] = uM(e, t, n.$pos.pos + 4);
    return r
}
  , G3 = (t, e, n) => {
    const {$anchor: r} = t.selection
      , o = Math.max(0, r.pos - 2)
      , l = t.doc.resolve(o).node();
    return !(!l || !n.includes(l.type.name))
}
  , Y3 = (t, e) => {
    var n;
    const {$anchor: r} = e.selection
      , o = e.doc.resolve(r.pos - 2);
    return !(o.index() === 0 || ((n = o.nodeBefore) == null ? void 0 : n.type.name) !== t)
}
  , Z3 = (t, e, n) => {
    if (!n)
        return !1;
    const r = dt(t, e.schema);
    let o = !1;
    return n.descendants(l => {
        l.type === r && (o = !0)
    }
    ),
    o
}
  , Fm = (t, e, n) => {
    if (t.commands.undoInputRule())
        return !0;
    if (t.state.selection.from !== t.state.selection.to)
        return !1;
    if (!Ni(t.state, e) && G3(t.state, e, n)) {
        const {$anchor: u} = t.state.selection
          , f = t.state.doc.resolve(u.before() - 1)
          , h = [];
        f.node().descendants( (y, b) => {
            y.type.name === e && h.push({
                node: y,
                pos: b
            })
        }
        );
        const p = h.at(-1);
        if (!p)
            return !1;
        const m = t.state.doc.resolve(f.start() + p.pos + 1);
        return t.chain().cut({
            from: u.start() - 1,
            to: u.end() + 1
        }, m.end()).joinForward().run()
    }
    if (!Ni(t.state, e) || !pM(t.state))
        return !1;
    const r = Ta(e, t.state);
    if (!r)
        return !1;
    const l = t.state.doc.resolve(r.$pos.pos - 2).node(r.depth)
      , a = Z3(e, t.state, l);
    return Y3(e, t.state) && !a ? t.commands.joinItemBackward() : t.chain().liftListItem(e).run()
}
  , W3 = (t, e) => {
    const n = ng(t, e)
      , r = Ta(t, e);
    return !r || !n ? !1 : n > r.depth
}
  , X3 = (t, e) => {
    const n = ng(t, e)
      , r = Ta(t, e);
    return !r || !n ? !1 : n < r.depth
}
  , Km = (t, e) => {
    if (!Ni(t.state, e) || !hM(t.state, e))
        return !1;
    const {selection: n} = t.state
      , {$from: r, $to: o} = n;
    return !n.empty && r.sameParent(o) ? !1 : W3(e, t.state) ? t.chain().focus(t.state.selection.from + 4).lift(e).joinBackward().run() : X3(e, t.state) ? t.chain().joinForward().joinBackward().run() : t.commands.joinItemForward()
}
  , aN = (t, e) => {
    var n;
    const {$anchor: r} = e.selection
      , o = e.doc.resolve(r.pos - r.parentOffset - 2);
    return !(o.index() === o.parent.childCount - 1 || ((n = o.nodeAfter) == null ? void 0 : n.type.name) !== t)
}
  , J3 = rt.create({
    name: "listKeymap",
    addOptions() {
        return {
            listTypes: [{
                itemName: "listItem",
                wrapperNames: ["bulletList", "orderedList"]
            }, {
                itemName: "taskItem",
                wrapperNames: ["taskList"]
            }]
        }
    },
    addKeyboardShortcuts() {
        return {
            Delete: ({editor: t}) => {
                let e = !1;
                return this.options.listTypes.forEach( ({itemName: n}) => {
                    t.state.schema.nodes[n] !== void 0 && Km(t, n) && (e = !0)
                }
                ),
                e
            }
            ,
            "Mod-Delete": ({editor: t}) => {
                let e = !1;
                return this.options.listTypes.forEach( ({itemName: n}) => {
                    t.state.schema.nodes[n] !== void 0 && Km(t, n) && (e = !0)
                }
                ),
                e
            }
            ,
            Backspace: ({editor: t}) => {
                let e = !1;
                return this.options.listTypes.forEach( ({itemName: n, wrapperNames: r}) => {
                    t.state.schema.nodes[n] !== void 0 && Fm(t, n, r) && (e = !0)
                }
                ),
                e
            }
            ,
            "Mod-Backspace": ({editor: t}) => {
                let e = !1;
                return this.options.listTypes.forEach( ({itemName: n, wrapperNames: r}) => {
                    t.state.schema.nodes[n] !== void 0 && Fm(t, n, r) && (e = !0)
                }
                ),
                e
            }
        }
    }
})
  , aC = /^(\s*)(\d+)\.\s+(.*)$/
  , cN = /^\s/;
function uN(t) {
    const e = [];
    let n = 0
      , r = 0;
    for (; n < t.length; ) {
        const o = t[n]
          , l = o.match(aC);
        if (!l)
            break;
        const [,a,u,f] = l
          , h = a.length;
        let p = f
          , m = n + 1;
        const y = [o];
        for (; m < t.length; ) {
            const b = t[m];
            if (b.match(aC))
                break;
            if (b.trim() === "")
                y.push(b),
                p += `
`,
                m += 1;
            else if (b.match(cN))
                y.push(b),
                p += `
${b.slice(h + 2)}`,
                m += 1;
            else
                break
        }
        e.push({
            indent: h,
            number: parseInt(u, 10),
            content: p.trim(),
            raw: y.join(`
`)
        }),
        r = m,
        n = m
    }
    return [e, r]
}
function Q3(t, e, n) {
    var r;
    const o = [];
    let l = 0;
    for (; l < t.length; ) {
        const a = t[l];
        if (a.indent === e) {
            const u = a.content.split(`
`)
              , f = ((r = u[0]) == null ? void 0 : r.trim()) || ""
              , h = [];
            f && h.push({
                type: "paragraph",
                raw: f,
                tokens: n.inlineTokens(f)
            });
            const p = u.slice(1).join(`
`).trim();
            if (p) {
                const b = n.blockTokens(p);
                h.push(...b)
            }
            let m = l + 1;
            const y = [];
            for (; m < t.length && t[m].indent > e; )
                y.push(t[m]),
                m += 1;
            if (y.length > 0) {
                const b = Math.min(...y.map(S => S.indent))
                  , C = Q3(y, b, n);
                h.push({
                    type: "list",
                    ordered: !0,
                    start: y[0].number,
                    items: C,
                    raw: y.map(S => S.raw).join(`
`)
                })
            }
            o.push({
                type: "list_item",
                raw: a.raw,
                tokens: h
            }),
            l = m
        } else
            l += 1
    }
    return o
}
function fN(t, e) {
    return t.map(n => {
        if (n.type !== "list_item")
            return e.parseChildren([n])[0];
        const r = [];
        return n.tokens && n.tokens.length > 0 && n.tokens.forEach(o => {
            if (o.type === "paragraph" || o.type === "list" || o.type === "blockquote" || o.type === "code")
                r.push(...e.parseChildren([o]));
            else if (o.type === "text" && o.tokens) {
                const l = e.parseChildren([o]);
                r.push({
                    type: "paragraph",
                    content: l
                })
            } else {
                const l = e.parseChildren([o]);
                l.length > 0 && r.push(...l)
            }
        }
        ),
        {
            type: "listItem",
            content: r
        }
    }
    )
}
var dN = "listItem"
  , cC = "textStyle"
  , uC = /^(\d+)\.\s$/
  , e4 = Nt.create({
    name: "orderedList",
    addOptions() {
        return {
            itemTypeName: "listItem",
            HTMLAttributes: {},
            keepMarks: !1,
            keepAttributes: !1
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    addAttributes() {
        return {
            start: {
                default: 1,
                parseHTML: t => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
            },
            type: {
                default: null,
                parseHTML: t => t.getAttribute("type")
            }
        }
    },
    parseHTML() {
        return [{
            tag: "ol"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        const {start: e, ...n} = t;
        return e === 1 ? ["ol", We(this.options.HTMLAttributes, n), 0] : ["ol", We(this.options.HTMLAttributes, t), 0]
    },
    markdownTokenName: "list",
    parseMarkdown: (t, e) => {
        if (t.type !== "list" || !t.ordered)
            return [];
        const n = t.start || 1
          , r = t.items ? fN(t.items, e) : [];
        return n !== 1 ? {
            type: "orderedList",
            attrs: {
                start: n
            },
            content: r
        } : {
            type: "orderedList",
            content: r
        }
    }
    ,
    renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
    markdownTokenizer: {
        name: "orderedList",
        level: "block",
        start: t => {
            const e = t.match(/^(\s*)(\d+)\.\s+/)
              , n = e?.index;
            return n !== void 0 ? n : -1
        }
        ,
        tokenize: (t, e, n) => {
            var r;
            const o = t.split(`
`)
              , [l,a] = uN(o);
            if (l.length === 0)
                return;
            const u = Q3(l, 0, n);
            return u.length === 0 ? void 0 : {
                type: "list",
                ordered: !0,
                start: ((r = l[0]) == null ? void 0 : r.number) || 1,
                items: u,
                raw: o.slice(0, a).join(`
`)
            }
        }
    },
    markdownOptions: {
        indentsContent: !0
    },
    addCommands() {
        return {
            toggleOrderedList: () => ({commands: t, chain: e}) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(dN, this.editor.getAttributes(cC)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
        }
    },
    addInputRules() {
        let t = jl({
            find: uC,
            type: this.type,
            getAttributes: e => ({
                start: +e[1]
            }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
        });
        return (this.options.keepMarks || this.options.keepAttributes) && (t = jl({
            find: uC,
            type: this.type,
            keepMarks: this.options.keepMarks,
            keepAttributes: this.options.keepAttributes,
            getAttributes: e => ({
                start: +e[1],
                ...this.editor.getAttributes(cC)
            }),
            joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
            editor: this.editor
        })),
        [t]
    }
})
  , hN = /^\s*(\[([( |x])?\])\s$/
  , pN = Nt.create({
    name: "taskItem",
    addOptions() {
        return {
            nested: !1,
            HTMLAttributes: {},
            taskListTypeName: "taskList",
            a11y: void 0
        }
    },
    content() {
        return this.options.nested ? "paragraph block*" : "paragraph+"
    },
    defining: !0,
    addAttributes() {
        return {
            checked: {
                default: !1,
                keepOnSplit: !1,
                parseHTML: t => {
                    const e = t.getAttribute("data-checked");
                    return e === "" || e === "true"
                }
                ,
                renderHTML: t => ({
                    "data-checked": t.checked
                })
            }
        }
    },
    parseHTML() {
        return [{
            tag: `li[data-type="${this.name}"]`,
            priority: 51
        }]
    },
    renderHTML({node: t, HTMLAttributes: e}) {
        return ["li", We(this.options.HTMLAttributes, e, {
            "data-type": this.name
        }), ["label", ["input", {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
        }], ["span"]], ["div", 0]]
    },
    parseMarkdown: (t, e) => {
        const n = [];
        if (t.tokens && t.tokens.length > 0 ? n.push(e.createNode("paragraph", {}, e.parseInline(t.tokens))) : t.text ? n.push(e.createNode("paragraph", {}, [e.createNode("text", {
            text: t.text
        })])) : n.push(e.createNode("paragraph", {}, [])),
        t.nestedTokens && t.nestedTokens.length > 0) {
            const r = e.parseChildren(t.nestedTokens);
            n.push(...r)
        }
        return e.createNode("taskItem", {
            checked: t.checked || !1
        }, n)
    }
    ,
    renderMarkdown: (t, e) => {
        var n;
        const o = `- [${(n = t.attrs) != null && n.checked ? "x" : " "}] `;
        return $1(t, e, o)
    }
    ,
    addKeyboardShortcuts() {
        const t = {
            Enter: () => this.editor.commands.splitListItem(this.name),
            "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
        };
        return this.options.nested ? {
            ...t,
            Tab: () => this.editor.commands.sinkListItem(this.name)
        } : t
    },
    addNodeView() {
        return ({node: t, HTMLAttributes: e, getPos: n, editor: r}) => {
            const o = document.createElement("li")
              , l = document.createElement("label")
              , a = document.createElement("span")
              , u = document.createElement("input")
              , f = document.createElement("div")
              , h = m => {
                var y, b;
                u.ariaLabel = ((b = (y = this.options.a11y) == null ? void 0 : y.checkboxLabel) == null ? void 0 : b.call(y, m, u.checked)) || `Task item checkbox for ${m.textContent || "empty task item"}`
            }
            ;
            h(t),
            l.contentEditable = "false",
            u.type = "checkbox",
            u.addEventListener("mousedown", m => m.preventDefault()),
            u.addEventListener("change", m => {
                if (!r.isEditable && !this.options.onReadOnlyChecked) {
                    u.checked = !u.checked;
                    return
                }
                const {checked: y} = m.target;
                r.isEditable && typeof n == "function" && r.chain().focus(void 0, {
                    scrollIntoView: !1
                }).command( ({tr: b}) => {
                    const C = n();
                    if (typeof C != "number")
                        return !1;
                    const S = b.doc.nodeAt(C);
                    return b.setNodeMarkup(C, void 0, {
                        ...S?.attrs,
                        checked: y
                    }),
                    !0
                }
                ).run(),
                !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, y) || (u.checked = !u.checked))
            }
            ),
            Object.entries(this.options.HTMLAttributes).forEach( ([m,y]) => {
                o.setAttribute(m, y)
            }
            ),
            o.dataset.checked = t.attrs.checked,
            u.checked = t.attrs.checked,
            l.append(u, a),
            o.append(l, f),
            Object.entries(e).forEach( ([m,y]) => {
                o.setAttribute(m, y)
            }
            );
            let p = new Set(Object.keys(e));
            return {
                dom: o,
                contentDOM: f,
                update: m => {
                    if (m.type !== this.type)
                        return !1;
                    o.dataset.checked = m.attrs.checked,
                    u.checked = m.attrs.checked,
                    h(m);
                    const y = r.extensionManager.attributes
                      , b = ga(m, y)
                      , C = new Set(Object.keys(b))
                      , S = this.options.HTMLAttributes;
                    return p.forEach(w => {
                        C.has(w) || (w in S ? o.setAttribute(w, S[w]) : o.removeAttribute(w))
                    }
                    ),
                    Object.entries(b).forEach( ([w,k]) => {
                        k == null ? w in S ? o.setAttribute(w, S[w]) : o.removeAttribute(w) : o.setAttribute(w, k)
                    }
                    ),
                    p = C,
                    !0
                }
            }
        }
    },
    addInputRules() {
        return [jl({
            find: hN,
            type: this.type,
            getAttributes: t => ({
                checked: t[t.length - 1] === "x"
            })
        })]
    }
})
  , mN = Nt.create({
    name: "taskList",
    addOptions() {
        return {
            itemTypeName: "taskItem",
            HTMLAttributes: {}
        }
    },
    group: "block list",
    content() {
        return `${this.options.itemTypeName}+`
    },
    parseHTML() {
        return [{
            tag: `ul[data-type="${this.name}"]`,
            priority: 51
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["ul", We(this.options.HTMLAttributes, t, {
            "data-type": this.name
        }), 0]
    },
    parseMarkdown: (t, e) => e.createNode("taskList", {}, e.parseChildren(t.items || [])),
    renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
    markdownTokenizer: {
        name: "taskList",
        level: "block",
        start(t) {
            var e;
            const n = (e = t.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : e.index;
            return n !== void 0 ? n : -1
        },
        tokenize(t, e, n) {
            const r = l => {
                const a = _m(l, {
                    itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
                    extractItemData: u => ({
                        indentLevel: u[1].length,
                        mainContent: u[4],
                        checked: u[3].toLowerCase() === "x"
                    }),
                    createToken: (u, f) => ({
                        type: "taskItem",
                        raw: "",
                        mainContent: u.mainContent,
                        indentLevel: u.indentLevel,
                        checked: u.checked,
                        text: u.mainContent,
                        tokens: n.inlineTokens(u.mainContent),
                        nestedTokens: f
                    }),
                    customNestedParser: r
                }, n);
                return a ? [{
                    type: "taskList",
                    raw: a.raw,
                    items: a.items
                }] : n.blockTokens(l)
            }
              , o = _m(t, {
                itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
                extractItemData: l => ({
                    indentLevel: l[1].length,
                    mainContent: l[4],
                    checked: l[3].toLowerCase() === "x"
                }),
                createToken: (l, a) => ({
                    type: "taskItem",
                    raw: "",
                    mainContent: l.mainContent,
                    indentLevel: l.indentLevel,
                    checked: l.checked,
                    text: l.mainContent,
                    tokens: n.inlineTokens(l.mainContent),
                    nestedTokens: a
                }),
                customNestedParser: r
            }, n);
            if (o)
                return {
                    type: "taskList",
                    raw: o.raw,
                    items: o.items
                }
        }
    },
    markdownOptions: {
        indentsContent: !0
    },
    addCommands() {
        return {
            toggleTaskList: () => ({commands: t}) => t.toggleList(this.name, this.options.itemTypeName)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
        }
    }
});
rt.create({
    name: "listKit",
    addExtensions() {
        const t = [];
        return this.options.bulletList !== !1 && t.push(F3.configure(this.options.bulletList)),
        this.options.listItem !== !1 && t.push(K3.configure(this.options.listItem)),
        this.options.listKeymap !== !1 && t.push(J3.configure(this.options.listKeymap)),
        this.options.orderedList !== !1 && t.push(e4.configure(this.options.orderedList)),
        this.options.taskItem !== !1 && t.push(pN.configure(this.options.taskItem)),
        this.options.taskList !== !1 && t.push(mN.configure(this.options.taskList)),
        t
    }
});
var fC = "&nbsp;"
  , gN = ""
  , yN = Nt.create({
    name: "paragraph",
    priority: 1e3,
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    group: "block",
    content: "inline*",
    parseHTML() {
        return [{
            tag: "p"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["p", We(this.options.HTMLAttributes, t), 0]
    },
    parseMarkdown: (t, e) => {
        const n = t.tokens || [];
        if (n.length === 1 && n[0].type === "image")
            return e.parseChildren([n[0]]);
        const r = e.parseInline(n);
        return r.length === 1 && r[0].type === "text" && (r[0].text === fC || r[0].text === gN) ? e.createNode("paragraph", void 0, []) : e.createNode("paragraph", void 0, r)
    }
    ,
    renderMarkdown: (t, e) => {
        if (!t)
            return "";
        const n = Array.isArray(t.content) ? t.content : [];
        return n.length === 0 ? fC : e.renderChildren(n)
    }
    ,
    addCommands() {
        return {
            setParagraph: () => ({commands: t}) => t.setNode(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Alt-0": () => this.editor.commands.setParagraph()
        }
    }
})
  , vN = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/
  , bN = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g
  , CN = Mo.create({
    name: "strike",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "s"
        }, {
            tag: "del"
        }, {
            tag: "strike"
        }, {
            style: "text-decoration",
            consuming: !1,
            getAttrs: t => t.includes("line-through") ? {} : !1
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["s", We(this.options.HTMLAttributes, t), 0]
    },
    markdownTokenName: "del",
    parseMarkdown: (t, e) => e.applyMark("strike", e.parseInline(t.tokens || [])),
    renderMarkdown: (t, e) => `~~${e.renderChildren(t)}~~`,
    addCommands() {
        return {
            setStrike: () => ({commands: t}) => t.setMark(this.name),
            toggleStrike: () => ({commands: t}) => t.toggleMark(this.name),
            unsetStrike: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-Shift-s": () => this.editor.commands.toggleStrike()
        }
    },
    addInputRules() {
        return [Bl({
            find: vN,
            type: this.type
        })]
    },
    addPasteRules() {
        return [xo({
            find: bN,
            type: this.type
        })]
    }
})
  , SN = Nt.create({
    name: "text",
    group: "inline",
    parseMarkdown: t => ({
        type: "text",
        text: t.text || ""
    }),
    renderMarkdown: t => t.text || ""
})
  , t4 = Mo.create({
    name: "underline",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    parseHTML() {
        return [{
            tag: "u"
        }, {
            style: "text-decoration",
            consuming: !1,
            getAttrs: t => t.includes("underline") ? {} : !1
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["u", We(this.options.HTMLAttributes, t), 0]
    },
    parseMarkdown(t, e) {
        return e.applyMark(this.name || "underline", e.parseInline(t.tokens || []))
    },
    renderMarkdown(t, e) {
        return `++${e.renderChildren(t)}++`
    },
    markdownTokenizer: {
        name: "underline",
        level: "inline",
        start(t) {
            return t.indexOf("++")
        },
        tokenize(t, e, n) {
            const o = /^(\+\+)([\s\S]+?)(\+\+)/.exec(t);
            if (!o)
                return;
            const l = o[2].trim();
            return {
                type: "underline",
                raw: o[0],
                text: l,
                tokens: n.inlineTokens(l)
            }
        }
    },
    addCommands() {
        return {
            setUnderline: () => ({commands: t}) => t.setMark(this.name),
            toggleUnderline: () => ({commands: t}) => t.toggleMark(this.name),
            unsetUnderline: () => ({commands: t}) => t.unsetMark(this.name)
        }
    },
    addKeyboardShortcuts() {
        return {
            "Mod-u": () => this.editor.commands.toggleUnderline(),
            "Mod-U": () => this.editor.commands.toggleUnderline()
        }
    }
})
  , xN = t4;
function wN(t={}) {
    return new Ye({
        view(e) {
            return new EN(e,t)
        }
    })
}
class EN {
    constructor(e, n) {
        var r;
        this.editorView = e,
        this.cursorPos = null,
        this.element = null,
        this.timeout = -1,
        this.width = (r = n.width) !== null && r !== void 0 ? r : 1,
        this.color = n.color === !1 ? void 0 : n.color || "black",
        this.class = n.class,
        this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(o => {
            let l = a => {
                this[o](a)
            }
            ;
            return e.dom.addEventListener(o, l),
            {
                name: o,
                handler: l
            }
        }
        )
    }
    destroy() {
        this.handlers.forEach( ({name: e, handler: n}) => this.editorView.dom.removeEventListener(e, n))
    }
    update(e, n) {
        this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay())
    }
    setCursor(e) {
        e != this.cursorPos && (this.cursorPos = e,
        e == null ? (this.element.parentNode.removeChild(this.element),
        this.element = null) : this.updateOverlay())
    }
    updateOverlay() {
        let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, o = this.editorView.dom, l = o.getBoundingClientRect(), a = l.width / o.offsetWidth, u = l.height / o.offsetHeight;
        if (n) {
            let m = e.nodeBefore
              , y = e.nodeAfter;
            if (m || y) {
                let b = this.editorView.nodeDOM(this.cursorPos - (m ? m.nodeSize : 0));
                if (b) {
                    let C = b.getBoundingClientRect()
                      , S = m ? C.bottom : C.top;
                    m && y && (S = (S + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
                    let w = this.width / 2 * u;
                    r = {
                        left: C.left,
                        right: C.right,
                        top: S - w,
                        bottom: S + w
                    }
                }
            }
        }
        if (!r) {
            let m = this.editorView.coordsAtPos(this.cursorPos)
              , y = this.width / 2 * a;
            r = {
                left: m.left - y,
                right: m.left + y,
                top: m.top,
                bottom: m.bottom
            }
        }
        let f = this.editorView.dom.offsetParent;
        this.element || (this.element = f.appendChild(document.createElement("div")),
        this.class && (this.element.className = this.class),
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;",
        this.color && (this.element.style.backgroundColor = this.color)),
        this.element.classList.toggle("prosemirror-dropcursor-block", n),
        this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
        let h, p;
        if (!f || f == document.body && getComputedStyle(f).position == "static")
            h = -pageXOffset,
            p = -pageYOffset;
        else {
            let m = f.getBoundingClientRect()
              , y = m.width / f.offsetWidth
              , b = m.height / f.offsetHeight;
            h = m.left - f.scrollLeft * y,
            p = m.top - f.scrollTop * b
        }
        this.element.style.left = (r.left - h) / a + "px",
        this.element.style.top = (r.top - p) / u + "px",
        this.element.style.width = (r.right - r.left) / a + "px",
        this.element.style.height = (r.bottom - r.top) / u + "px"
    }
    scheduleRemoval(e) {
        clearTimeout(this.timeout),
        this.timeout = setTimeout( () => this.setCursor(null), e)
    }
    dragover(e) {
        if (!this.editorView.editable)
            return;
        let n = this.editorView.posAtCoords({
            left: e.clientX,
            top: e.clientY
        })
          , r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside)
          , o = r && r.type.spec.disableDropCursor
          , l = typeof o == "function" ? o(this.editorView, n, e) : o;
        if (n && !l) {
            let a = n.pos;
            if (this.editorView.dragging && this.editorView.dragging.slice) {
                let u = YS(this.editorView.state.doc, a, this.editorView.dragging.slice);
                u != null && (a = u)
            }
            this.setCursor(a),
            this.scheduleRemoval(5e3)
        }
    }
    dragend() {
        this.scheduleRemoval(20)
    }
    drop() {
        this.scheduleRemoval(20)
    }
    dragleave(e) {
        this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null)
    }
}
class et extends ye {
    constructor(e) {
        super(e, e)
    }
    map(e, n) {
        let r = e.resolve(n.map(this.head));
        return et.valid(r) ? new et(r) : ye.near(r)
    }
    content() {
        return te.empty
    }
    eq(e) {
        return e instanceof et && e.head == this.head
    }
    toJSON() {
        return {
            type: "gapcursor",
            pos: this.head
        }
    }
    static fromJSON(e, n) {
        if (typeof n.pos != "number")
            throw new RangeError("Invalid input for GapCursor.fromJSON");
        return new et(e.resolve(n.pos))
    }
    getBookmark() {
        return new rg(this.anchor)
    }
    static valid(e) {
        let n = e.parent;
        if (n.isTextblock || !TN(e) || !kN(e))
            return !1;
        let r = n.type.spec.allowGapCursor;
        if (r != null)
            return r;
        let o = n.contentMatchAt(e.index()).defaultType;
        return o && o.isTextblock
    }
    static findGapCursorFrom(e, n, r=!1) {
        e: for (; ; ) {
            if (!r && et.valid(e))
                return e;
            let o = e.pos
              , l = null;
            for (let a = e.depth; ; a--) {
                let u = e.node(a);
                if (n > 0 ? e.indexAfter(a) < u.childCount : e.index(a) > 0) {
                    l = u.child(n > 0 ? e.indexAfter(a) : e.index(a) - 1);
                    break
                } else if (a == 0)
                    return null;
                o += n;
                let f = e.doc.resolve(o);
                if (et.valid(f))
                    return f
            }
            for (; ; ) {
                let a = n > 0 ? l.firstChild : l.lastChild;
                if (!a) {
                    if (l.isAtom && !l.isText && !le.isSelectable(l)) {
                        e = e.doc.resolve(o + l.nodeSize * n),
                        r = !1;
                        continue e
                    }
                    break
                }
                l = a,
                o += n;
                let u = e.doc.resolve(o);
                if (et.valid(u))
                    return u
            }
            return null
        }
    }
}
et.prototype.visible = !1;
et.findFrom = et.findGapCursorFrom;
ye.jsonID("gapcursor", et);
class rg {
    constructor(e) {
        this.pos = e
    }
    map(e) {
        return new rg(e.map(this.pos))
    }
    resolve(e) {
        let n = e.resolve(this.pos);
        return et.valid(n) ? new et(n) : ye.near(n)
    }
}
function n4(t) {
    return t.isAtom || t.spec.isolating || t.spec.createGapCursor
}
function TN(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.index(e)
          , r = t.node(e);
        if (n == 0) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let o = r.child(n - 1); ; o = o.lastChild) {
            if (o.childCount == 0 && !o.inlineContent || n4(o.type))
                return !0;
            if (o.inlineContent)
                return !1
        }
    }
    return !0
}
function kN(t) {
    for (let e = t.depth; e >= 0; e--) {
        let n = t.indexAfter(e)
          , r = t.node(e);
        if (n == r.childCount) {
            if (r.type.spec.isolating)
                return !0;
            continue
        }
        for (let o = r.child(n); ; o = o.firstChild) {
            if (o.childCount == 0 && !o.inlineContent || n4(o.type))
                return !0;
            if (o.inlineContent)
                return !1
        }
    }
    return !0
}
function MN() {
    return new Ye({
        props: {
            decorations: ON,
            createSelectionBetween(t, e, n) {
                return e.pos == n.pos && et.valid(n) ? new et(n) : null
            },
            handleClick: NN,
            handleKeyDown: AN,
            handleDOMEvents: {
                beforeinput: RN
            }
        }
    })
}
const AN = z1({
    ArrowLeft: ou("horiz", -1),
    ArrowRight: ou("horiz", 1),
    ArrowUp: ou("vert", -1),
    ArrowDown: ou("vert", 1)
});
function ou(t, e) {
    const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
    return function(r, o, l) {
        let a = r.selection
          , u = e > 0 ? a.$to : a.$from
          , f = a.empty;
        if (a instanceof se) {
            if (!l.endOfTextblock(n) || u.depth == 0)
                return !1;
            f = !1,
            u = r.doc.resolve(e > 0 ? u.after() : u.before())
        }
        let h = et.findGapCursorFrom(u, e, f);
        return h ? (o && o(r.tr.setSelection(new et(h))),
        !0) : !1
    }
}
function NN(t, e, n) {
    if (!t || !t.editable)
        return !1;
    let r = t.state.doc.resolve(e);
    if (!et.valid(r))
        return !1;
    let o = t.posAtCoords({
        left: n.clientX,
        top: n.clientY
    });
    return o && o.inside > -1 && le.isSelectable(t.state.doc.nodeAt(o.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new et(r))),
    !0)
}
function RN(t, e) {
    if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof et))
        return !1;
    let {$from: n} = t.state.selection
      , r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
    if (!r)
        return !1;
    let o = Z.empty;
    for (let a = r.length - 1; a >= 0; a--)
        o = Z.from(r[a].createAndFill(null, o));
    let l = t.state.tr.replace(n.pos, n.pos, new te(o,0,0));
    return l.setSelection(se.near(l.doc.resolve(n.pos + 1))),
    t.dispatch(l),
    !1
}
function ON(t) {
    if (!(t.selection instanceof et))
        return null;
    let e = document.createElement("div");
    return e.className = "ProseMirror-gapcursor",
    Ue.create(t.doc, [yt.widget(t.selection.head, e, {
        key: "gapcursor"
    })])
}
var vf = 200
  , bt = function() {};
bt.prototype.append = function(e) {
    return e.length ? (e = bt.from(e),
    !this.length && e || e.length < vf && this.leafAppend(e) || this.length < vf && e.leafPrepend(this) || this.appendInner(e)) : this
}
;
bt.prototype.prepend = function(e) {
    return e.length ? bt.from(e).append(this) : this
}
;
bt.prototype.appendInner = function(e) {
    return new DN(this,e)
}
;
bt.prototype.slice = function(e, n) {
    return e === void 0 && (e = 0),
    n === void 0 && (n = this.length),
    e >= n ? bt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n))
}
;
bt.prototype.get = function(e) {
    if (!(e < 0 || e >= this.length))
        return this.getInner(e)
}
;
bt.prototype.forEach = function(e, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length),
    n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0)
}
;
bt.prototype.map = function(e, n, r) {
    n === void 0 && (n = 0),
    r === void 0 && (r = this.length);
    var o = [];
    return this.forEach(function(l, a) {
        return o.push(e(l, a))
    }, n, r),
    o
}
;
bt.from = function(e) {
    return e instanceof bt ? e : e && e.length ? new r4(e) : bt.empty
}
;
var r4 = (function(t) {
    function e(r) {
        t.call(this),
        this.values = r
    }
    t && (e.__proto__ = t),
    e.prototype = Object.create(t && t.prototype),
    e.prototype.constructor = e;
    var n = {
        length: {
            configurable: !0
        },
        depth: {
            configurable: !0
        }
    };
    return e.prototype.flatten = function() {
        return this.values
    }
    ,
    e.prototype.sliceInner = function(o, l) {
        return o == 0 && l == this.length ? this : new e(this.values.slice(o, l))
    }
    ,
    e.prototype.getInner = function(o) {
        return this.values[o]
    }
    ,
    e.prototype.forEachInner = function(o, l, a, u) {
        for (var f = l; f < a; f++)
            if (o(this.values[f], u + f) === !1)
                return !1
    }
    ,
    e.prototype.forEachInvertedInner = function(o, l, a, u) {
        for (var f = l - 1; f >= a; f--)
            if (o(this.values[f], u + f) === !1)
                return !1
    }
    ,
    e.prototype.leafAppend = function(o) {
        if (this.length + o.length <= vf)
            return new e(this.values.concat(o.flatten()))
    }
    ,
    e.prototype.leafPrepend = function(o) {
        if (this.length + o.length <= vf)
            return new e(o.flatten().concat(this.values))
    }
    ,
    n.length.get = function() {
        return this.values.length
    }
    ,
    n.depth.get = function() {
        return 0
    }
    ,
    Object.defineProperties(e.prototype, n),
    e
}
)(bt);
bt.empty = new r4([]);
var DN = (function(t) {
    function e(n, r) {
        t.call(this),
        this.left = n,
        this.right = r,
        this.length = n.length + r.length,
        this.depth = Math.max(n.depth, r.depth) + 1
    }
    return t && (e.__proto__ = t),
    e.prototype = Object.create(t && t.prototype),
    e.prototype.constructor = e,
    e.prototype.flatten = function() {
        return this.left.flatten().concat(this.right.flatten())
    }
    ,
    e.prototype.getInner = function(r) {
        return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length)
    }
    ,
    e.prototype.forEachInner = function(r, o, l, a) {
        var u = this.left.length;
        if (o < u && this.left.forEachInner(r, o, Math.min(l, u), a) === !1 || l > u && this.right.forEachInner(r, Math.max(o - u, 0), Math.min(this.length, l) - u, a + u) === !1)
            return !1
    }
    ,
    e.prototype.forEachInvertedInner = function(r, o, l, a) {
        var u = this.left.length;
        if (o > u && this.right.forEachInvertedInner(r, o - u, Math.max(l, u) - u, a + u) === !1 || l < u && this.left.forEachInvertedInner(r, Math.min(o, u), l, a) === !1)
            return !1
    }
    ,
    e.prototype.sliceInner = function(r, o) {
        if (r == 0 && o == this.length)
            return this;
        var l = this.left.length;
        return o <= l ? this.left.slice(r, o) : r >= l ? this.right.slice(r - l, o - l) : this.left.slice(r, l).append(this.right.slice(0, o - l))
    }
    ,
    e.prototype.leafAppend = function(r) {
        var o = this.right.leafAppend(r);
        if (o)
            return new e(this.left,o)
    }
    ,
    e.prototype.leafPrepend = function(r) {
        var o = this.left.leafPrepend(r);
        if (o)
            return new e(o,this.right)
    }
    ,
    e.prototype.appendInner = function(r) {
        return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left,new e(this.right,r)) : new e(this,r)
    }
    ,
    e
}
)(bt);
const LN = 500;
class zn {
    constructor(e, n) {
        this.items = e,
        this.eventCount = n
    }
    popEvent(e, n) {
        if (this.eventCount == 0)
            return null;
        let r = this.items.length;
        for (; ; r--)
            if (this.items.get(r - 1).selection) {
                --r;
                break
            }
        let o, l;
        n && (o = this.remapping(r, this.items.length),
        l = o.maps.length);
        let a = e.tr, u, f, h = [], p = [];
        return this.items.forEach( (m, y) => {
            if (!m.step) {
                o || (o = this.remapping(r, y + 1),
                l = o.maps.length),
                l--,
                p.push(m);
                return
            }
            if (o) {
                p.push(new $n(m.map));
                let b = m.step.map(o.slice(l)), C;
                b && a.maybeStep(b).doc && (C = a.mapping.maps[a.mapping.maps.length - 1],
                h.push(new $n(C,void 0,void 0,h.length + p.length))),
                l--,
                C && o.appendMap(C, l)
            } else
                a.maybeStep(m.step);
            if (m.selection)
                return u = o ? m.selection.map(o.slice(l)) : m.selection,
                f = new zn(this.items.slice(0, r).append(p.reverse().concat(h)),this.eventCount - 1),
                !1
        }
        , this.items.length, 0),
        {
            remaining: f,
            transform: a,
            selection: u
        }
    }
    addTransform(e, n, r, o) {
        let l = []
          , a = this.eventCount
          , u = this.items
          , f = !o && u.length ? u.get(u.length - 1) : null;
        for (let p = 0; p < e.steps.length; p++) {
            let m = e.steps[p].invert(e.docs[p]), y = new $n(e.mapping.maps[p],m,n), b;
            (b = f && f.merge(y)) && (y = b,
            p ? l.pop() : u = u.slice(0, u.length - 1)),
            l.push(y),
            n && (a++,
            n = void 0),
            o || (f = y)
        }
        let h = a - r.depth;
        return h > _N && (u = zN(u, h),
        a -= h),
        new zn(u.append(l),a)
    }
    remapping(e, n) {
        let r = new ua;
        return this.items.forEach( (o, l) => {
            let a = o.mirrorOffset != null && l - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
            r.appendMap(o.map, a)
        }
        , e, n),
        r
    }
    addMaps(e) {
        return this.eventCount == 0 ? this : new zn(this.items.append(e.map(n => new $n(n))),this.eventCount)
    }
    rebased(e, n) {
        if (!this.eventCount)
            return this;
        let r = []
          , o = Math.max(0, this.items.length - n)
          , l = e.mapping
          , a = e.steps.length
          , u = this.eventCount;
        this.items.forEach(y => {
            y.selection && u--
        }
        , o);
        let f = n;
        this.items.forEach(y => {
            let b = l.getMirror(--f);
            if (b == null)
                return;
            a = Math.min(a, b);
            let C = l.maps[b];
            if (y.step) {
                let S = e.steps[b].invert(e.docs[b])
                  , w = y.selection && y.selection.map(l.slice(f + 1, b));
                w && u++,
                r.push(new $n(C,S,w))
            } else
                r.push(new $n(C))
        }
        , o);
        let h = [];
        for (let y = n; y < a; y++)
            h.push(new $n(l.maps[y]));
        let p = this.items.slice(0, o).append(h).append(r)
          , m = new zn(p,u);
        return m.emptyItemCount() > LN && (m = m.compress(this.items.length - r.length)),
        m
    }
    emptyItemCount() {
        let e = 0;
        return this.items.forEach(n => {
            n.step || e++
        }
        ),
        e
    }
    compress(e=this.items.length) {
        let n = this.remapping(0, e)
          , r = n.maps.length
          , o = []
          , l = 0;
        return this.items.forEach( (a, u) => {
            if (u >= e)
                o.push(a),
                a.selection && l++;
            else if (a.step) {
                let f = a.step.map(n.slice(r))
                  , h = f && f.getMap();
                if (r--,
                h && n.appendMap(h, r),
                f) {
                    let p = a.selection && a.selection.map(n.slice(r));
                    p && l++;
                    let m = new $n(h.invert(),f,p), y, b = o.length - 1;
                    (y = o.length && o[b].merge(m)) ? o[b] = y : o.push(m)
                }
            } else
                a.map && r--
        }
        , this.items.length, 0),
        new zn(bt.from(o.reverse()),l)
    }
}
zn.empty = new zn(bt.empty,0);
function zN(t, e) {
    let n;
    return t.forEach( (r, o) => {
        if (r.selection && e-- == 0)
            return n = o,
            !1
    }
    ),
    t.slice(n)
}
class $n {
    constructor(e, n, r, o) {
        this.map = e,
        this.step = n,
        this.selection = r,
        this.mirrorOffset = o
    }
    merge(e) {
        if (this.step && e.step && !e.selection) {
            let n = e.step.merge(this.step);
            if (n)
                return new $n(n.getMap().invert(),n,this.selection)
        }
    }
}
class hi {
    constructor(e, n, r, o, l) {
        this.done = e,
        this.undone = n,
        this.prevRanges = r,
        this.prevTime = o,
        this.prevComposition = l
    }
}
const _N = 20;
function BN(t, e, n, r) {
    let o = n.getMeta(yo), l;
    if (o)
        return o.historyState;
    n.getMeta(IN) && (t = new hi(t.done,t.undone,null,0,-1));
    let a = n.getMeta("appendedTransaction");
    if (n.steps.length == 0)
        return t;
    if (a && a.getMeta(yo))
        return a.getMeta(yo).redo ? new hi(t.done.addTransform(n, void 0, r, Su(e)),t.undone,dC(n.mapping.maps),t.prevTime,t.prevComposition) : new hi(t.done,t.undone.addTransform(n, void 0, r, Su(e)),null,t.prevTime,t.prevComposition);
    if (n.getMeta("addToHistory") !== !1 && !(a && a.getMeta("addToHistory") === !1)) {
        let u = n.getMeta("composition")
          , f = t.prevTime == 0 || !a && t.prevComposition != u && (t.prevTime < (n.time || 0) - r.newGroupDelay || !jN(n, t.prevRanges))
          , h = a ? Xp(t.prevRanges, n.mapping) : dC(n.mapping.maps);
        return new hi(t.done.addTransform(n, f ? e.selection.getBookmark() : void 0, r, Su(e)),zn.empty,h,n.time,u ?? t.prevComposition)
    } else
        return (l = n.getMeta("rebased")) ? new hi(t.done.rebased(n, l),t.undone.rebased(n, l),Xp(t.prevRanges, n.mapping),t.prevTime,t.prevComposition) : new hi(t.done.addMaps(n.mapping.maps),t.undone.addMaps(n.mapping.maps),Xp(t.prevRanges, n.mapping),t.prevTime,t.prevComposition)
}
function jN(t, e) {
    if (!e)
        return !1;
    if (!t.docChanged)
        return !0;
    let n = !1;
    return t.mapping.maps[0].forEach( (r, o) => {
        for (let l = 0; l < e.length; l += 2)
            r <= e[l + 1] && o >= e[l] && (n = !0)
    }
    ),
    n
}
function dC(t) {
    let e = [];
    for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
        t[n].forEach( (r, o, l, a) => e.push(l, a));
    return e
}
function Xp(t, e) {
    if (!t)
        return null;
    let n = [];
    for (let r = 0; r < t.length; r += 2) {
        let o = e.map(t[r], 1)
          , l = e.map(t[r + 1], -1);
        o <= l && n.push(o, l)
    }
    return n
}
function HN(t, e, n) {
    let r = Su(e)
      , o = yo.get(e).spec.config
      , l = (n ? t.undone : t.done).popEvent(e, r);
    if (!l)
        return null;
    let a = l.selection.resolve(l.transform.doc)
      , u = (n ? t.done : t.undone).addTransform(l.transform, e.selection.getBookmark(), o, r)
      , f = new hi(n ? u : l.remaining,n ? l.remaining : u,null,0,-1);
    return l.transform.setSelection(a).setMeta(yo, {
        redo: n,
        historyState: f
    })
}
let Jp = !1
  , hC = null;
function Su(t) {
    let e = t.plugins;
    if (hC != e) {
        Jp = !1,
        hC = e;
        for (let n = 0; n < e.length; n++)
            if (e[n].spec.historyPreserveItems) {
                Jp = !0;
                break
            }
    }
    return Jp
}
const yo = new nt("history")
  , IN = new nt("closeHistory");
function VN(t={}) {
    return t = {
        depth: t.depth || 100,
        newGroupDelay: t.newGroupDelay || 500
    },
    new Ye({
        key: yo,
        state: {
            init() {
                return new hi(zn.empty,zn.empty,null,0,-1)
            },
            apply(e, n, r) {
                return BN(n, r, e, t)
            }
        },
        config: t,
        props: {
            handleDOMEvents: {
                beforeinput(e, n) {
                    let r = n.inputType
                      , o = r == "historyUndo" ? o4 : r == "historyRedo" ? l4 : null;
                    return !o || !e.editable ? !1 : (n.preventDefault(),
                    o(e.state, e.dispatch))
                }
            }
        }
    })
}
function i4(t, e) {
    return (n, r) => {
        let o = yo.getState(n);
        if (!o || (t ? o.undone : o.done).eventCount == 0)
            return !1;
        if (r) {
            let l = HN(o, n, t);
            l && r(e ? l.scrollIntoView() : l)
        }
        return !0
    }
}
const o4 = i4(!1, !0)
  , l4 = i4(!0, !0);
rt.create({
    name: "characterCount",
    addOptions() {
        return {
            limit: null,
            mode: "textSize",
            textCounter: t => t.length,
            wordCounter: t => t.split(" ").filter(e => e !== "").length
        }
    },
    addStorage() {
        return {
            characters: () => 0,
            words: () => 0
        }
    },
    onBeforeCreate() {
        this.storage.characters = t => {
            const e = t?.node || this.editor.state.doc;
            if ((t?.mode || this.options.mode) === "textSize") {
                const r = e.textBetween(0, e.content.size, void 0, " ");
                return this.options.textCounter(r)
            }
            return e.nodeSize
        }
        ,
        this.storage.words = t => {
            const e = t?.node || this.editor.state.doc
              , n = e.textBetween(0, e.content.size, " ", " ");
            return this.options.wordCounter(n)
        }
    },
    addProseMirrorPlugins() {
        let t = !1;
        return [new Ye({
            key: new nt("characterCount"),
            appendTransaction: (e, n, r) => {
                if (t)
                    return;
                const o = this.options.limit;
                if (o == null || o === 0) {
                    t = !0;
                    return
                }
                const l = this.storage.characters({
                    node: r.doc
                });
                if (l > o) {
                    const a = l - o
                      , u = 0
                      , f = a;
                    console.warn(`[CharacterCount] Initial content exceeded limit of ${o} characters. Content was automatically trimmed.`);
                    const h = r.tr.deleteRange(u, f);
                    return t = !0,
                    h
                }
                t = !0
            }
            ,
            filterTransaction: (e, n) => {
                const r = this.options.limit;
                if (!e.docChanged || r === 0 || r === null || r === void 0)
                    return !0;
                const o = this.storage.characters({
                    node: n.doc
                })
                  , l = this.storage.characters({
                    node: e.doc
                });
                if (l <= r || o > r && l > r && l <= o)
                    return !0;
                if (o > r && l > r && l > o || !e.getMeta("paste"))
                    return !1;
                const u = e.selection.$head.pos
                  , f = l - r
                  , h = u - f
                  , p = u;
                return e.deleteRange(h, p),
                !(this.storage.characters({
                    node: e.doc
                }) > r)
            }
        })]
    }
});
var UN = rt.create({
    name: "dropCursor",
    addOptions() {
        return {
            color: "currentColor",
            width: 1,
            class: void 0
        }
    },
    addProseMirrorPlugins() {
        return [wN(this.options)]
    }
});
rt.create({
    name: "focus",
    addOptions() {
        return {
            className: "has-focus",
            mode: "all"
        }
    },
    addProseMirrorPlugins() {
        return [new Ye({
            key: new nt("focus"),
            props: {
                decorations: ({doc: t, selection: e}) => {
                    const {isEditable: n, isFocused: r} = this.editor
                      , {anchor: o} = e
                      , l = [];
                    if (!n || !r)
                        return Ue.create(t, []);
                    let a = 0;
                    this.options.mode === "deepest" && t.descendants( (f, h) => {
                        if (f.isText)
                            return;
                        if (!(o >= h && o <= h + f.nodeSize - 1))
                            return !1;
                        a += 1
                    }
                    );
                    let u = 0;
                    return t.descendants( (f, h) => {
                        if (f.isText || !(o >= h && o <= h + f.nodeSize - 1))
                            return !1;
                        if (u += 1,
                        this.options.mode === "deepest" && a - u > 0 || this.options.mode === "shallowest" && u > 1)
                            return this.options.mode === "deepest";
                        l.push(yt.node(h, h + f.nodeSize, {
                            class: this.options.className
                        }))
                    }
                    ),
                    Ue.create(t, l)
                }
            }
        })]
    }
});
var PN = rt.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
        return [MN()]
    },
    extendNodeSchema(t) {
        var e;
        const n = {
            name: t.name,
            options: t.options,
            storage: t.storage
        };
        return {
            allowGapCursor: (e = Le(fe(t, "allowGapCursor", n))) != null ? e : null
        }
    }
})
  , pC = "placeholder";
function qN(t) {
    return t.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-]/g, "").replace(/^[0-9-]+/, "").replace(/^-+/, "").toLowerCase()
}
var $N = rt.create({
    name: "placeholder",
    addOptions() {
        return {
            emptyEditorClass: "is-editor-empty",
            emptyNodeClass: "is-empty",
            dataAttribute: pC,
            placeholder: "Write something ",
            showOnlyWhenEditable: !0,
            showOnlyCurrent: !0,
            includeChildren: !1
        }
    },
    addProseMirrorPlugins() {
        const t = this.options.dataAttribute ? `data-${qN(this.options.dataAttribute)}` : `data-${pC}`;
        return [new Ye({
            key: new nt("placeholder"),
            props: {
                decorations: ({doc: e, selection: n}) => {
                    const r = this.editor.isEditable || !this.options.showOnlyWhenEditable
                      , {anchor: o} = n
                      , l = [];
                    if (!r)
                        return null;
                    const a = this.editor.isEmpty;
                    return e.descendants( (u, f) => {
                        const h = o >= f && o <= f + u.nodeSize
                          , p = !u.isLeaf && If(u);
                        if ((h || !this.options.showOnlyCurrent) && p) {
                            const m = [this.options.emptyNodeClass];
                            a && m.push(this.options.emptyEditorClass);
                            const y = yt.node(f, f + u.nodeSize, {
                                class: m.join(" "),
                                [t]: typeof this.options.placeholder == "function" ? this.options.placeholder({
                                    editor: this.editor,
                                    node: u,
                                    pos: f,
                                    hasAnchor: h
                                }) : this.options.placeholder
                            });
                            l.push(y)
                        }
                        return this.options.includeChildren
                    }
                    ),
                    Ue.create(e, l)
                }
            }
        })]
    }
});
rt.create({
    name: "selection",
    addOptions() {
        return {
            className: "selection"
        }
    },
    addProseMirrorPlugins() {
        const {editor: t, options: e} = this;
        return [new Ye({
            key: new nt("selection"),
            props: {
                decorations(n) {
                    return n.selection.empty || t.isFocused || !t.isEditable || f3(n.selection) || t.view.dragging ? null : Ue.create(n.doc, [yt.inline(n.selection.from, n.selection.to, {
                        class: e.className
                    })])
                }
            }
        })]
    }
});
function mC({types: t, node: e}) {
    return e && Array.isArray(t) && t.includes(e.type) || e?.type === t
}
var FN = rt.create({
    name: "trailingNode",
    addOptions() {
        return {
            node: void 0,
            notAfter: []
        }
    },
    addProseMirrorPlugins() {
        var t;
        const e = new nt(this.name)
          , n = this.options.node || ((t = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : t.name) || "paragraph"
          , r = Object.entries(this.editor.schema.nodes).map( ([,o]) => o).filter(o => (this.options.notAfter || []).concat(n).includes(o.name));
        return [new Ye({
            key: e,
            appendTransaction: (o, l, a) => {
                const {doc: u, tr: f, schema: h} = a
                  , p = e.getState(a)
                  , m = u.content.size
                  , y = h.nodes[n];
                if (p)
                    return f.insert(m, y.create())
            }
            ,
            state: {
                init: (o, l) => {
                    const a = l.tr.doc.lastChild;
                    return !mC({
                        node: a,
                        types: r
                    })
                }
                ,
                apply: (o, l) => {
                    if (!o.docChanged || o.getMeta("__uniqueIDTransaction"))
                        return l;
                    const a = o.doc.lastChild;
                    return !mC({
                        node: a,
                        types: r
                    })
                }
            }
        })]
    }
})
  , KN = rt.create({
    name: "undoRedo",
    addOptions() {
        return {
            depth: 100,
            newGroupDelay: 500
        }
    },
    addCommands() {
        return {
            undo: () => ({state: t, dispatch: e}) => o4(t, e),
            redo: () => ({state: t, dispatch: e}) => l4(t, e)
        }
    },
    addProseMirrorPlugins() {
        return [VN(this.options)]
    },
    addKeyboardShortcuts() {
        return {
            "Mod-z": () => this.editor.commands.undo(),
            "Shift-Mod-z": () => this.editor.commands.redo(),
            "Mod-y": () => this.editor.commands.redo(),
            "Mod-": () => this.editor.commands.undo(),
            "Shift-Mod-": () => this.editor.commands.redo()
        }
    }
})
  , GN = rt.create({
    name: "starterKit",
    addExtensions() {
        var t, e, n, r;
        const o = [];
        return this.options.bold !== !1 && o.push(y8.configure(this.options.bold)),
        this.options.blockquote !== !1 && o.push(d8.configure(this.options.blockquote)),
        this.options.bulletList !== !1 && o.push(F3.configure(this.options.bulletList)),
        this.options.code !== !1 && o.push(C8.configure(this.options.code)),
        this.options.codeBlock !== !1 && o.push(w8.configure(this.options.codeBlock)),
        this.options.document !== !1 && o.push(E8.configure(this.options.document)),
        this.options.dropcursor !== !1 && o.push(UN.configure(this.options.dropcursor)),
        this.options.gapcursor !== !1 && o.push(PN.configure(this.options.gapcursor)),
        this.options.hardBreak !== !1 && o.push(T8.configure(this.options.hardBreak)),
        this.options.heading !== !1 && o.push(k8.configure(this.options.heading)),
        this.options.undoRedo !== !1 && o.push(KN.configure(this.options.undoRedo)),
        this.options.horizontalRule !== !1 && o.push(M8.configure(this.options.horizontalRule)),
        this.options.italic !== !1 && o.push(D8.configure(this.options.italic)),
        this.options.listItem !== !1 && o.push(K3.configure(this.options.listItem)),
        this.options.listKeymap !== !1 && o.push(J3.configure((t = this.options) == null ? void 0 : t.listKeymap)),
        this.options.link !== !1 && o.push($3.configure((e = this.options) == null ? void 0 : e.link)),
        this.options.orderedList !== !1 && o.push(e4.configure(this.options.orderedList)),
        this.options.paragraph !== !1 && o.push(yN.configure(this.options.paragraph)),
        this.options.strike !== !1 && o.push(CN.configure(this.options.strike)),
        this.options.text !== !1 && o.push(SN.configure(this.options.text)),
        this.options.underline !== !1 && o.push(t4.configure((n = this.options) == null ? void 0 : n.underline)),
        this.options.trailingNode !== !1 && o.push(FN.configure((r = this.options) == null ? void 0 : r.trailingNode)),
        o
    }
})
  , YN = GN
  , ZN = $N;
let Gm, Ym;
if (typeof WeakMap < "u") {
    let t = new WeakMap;
    Gm = e => t.get(e),
    Ym = (e, n) => (t.set(e, n),
    n)
} else {
    const t = [];
    let n = 0;
    Gm = r => {
        for (let o = 0; o < t.length; o += 2)
            if (t[o] == r)
                return t[o + 1]
    }
    ,
    Ym = (r, o) => (n == 10 && (n = 0),
    t[n++] = r,
    t[n++] = o)
}
var tt = class {
    constructor(t, e, n, r) {
        this.width = t,
        this.height = e,
        this.map = n,
        this.problems = r
    }
    findCell(t) {
        for (let e = 0; e < this.map.length; e++) {
            const n = this.map[e];
            if (n != t)
                continue;
            const r = e % this.width
              , o = e / this.width | 0;
            let l = r + 1
              , a = o + 1;
            for (let u = 1; l < this.width && this.map[e + u] == n; u++)
                l++;
            for (let u = 1; a < this.height && this.map[e + this.width * u] == n; u++)
                a++;
            return {
                left: r,
                top: o,
                right: l,
                bottom: a
            }
        }
        throw new RangeError(`No cell with offset ${t} found`)
    }
    colCount(t) {
        for (let e = 0; e < this.map.length; e++)
            if (this.map[e] == t)
                return e % this.width;
        throw new RangeError(`No cell with offset ${t} found`)
    }
    nextCell(t, e, n) {
        const {left: r, right: o, top: l, bottom: a} = this.findCell(t);
        return e == "horiz" ? (n < 0 ? r == 0 : o == this.width) ? null : this.map[l * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? l == 0 : a == this.height) ? null : this.map[r + this.width * (n < 0 ? l - 1 : a)]
    }
    rectBetween(t, e) {
        const {left: n, right: r, top: o, bottom: l} = this.findCell(t)
          , {left: a, right: u, top: f, bottom: h} = this.findCell(e);
        return {
            left: Math.min(n, a),
            top: Math.min(o, f),
            right: Math.max(r, u),
            bottom: Math.max(l, h)
        }
    }
    cellsInRect(t) {
        const e = []
          , n = {};
        for (let r = t.top; r < t.bottom; r++)
            for (let o = t.left; o < t.right; o++) {
                const l = r * this.width + o
                  , a = this.map[l];
                n[a] || (n[a] = !0,
                !(o == t.left && o && this.map[l - 1] == a || r == t.top && r && this.map[l - this.width] == a) && e.push(a))
            }
        return e
    }
    positionAt(t, e, n) {
        for (let r = 0, o = 0; ; r++) {
            const l = o + n.child(r).nodeSize;
            if (r == t) {
                let a = e + t * this.width;
                const u = (t + 1) * this.width;
                for (; a < u && this.map[a] < o; )
                    a++;
                return a == u ? l - 1 : this.map[a]
            }
            o = l
        }
    }
    static get(t) {
        return Gm(t) || Ym(t, WN(t))
    }
}
;
function WN(t) {
    if (t.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + t.type.name);
    const e = XN(t)
      , n = t.childCount
      , r = [];
    let o = 0
      , l = null;
    const a = [];
    for (let h = 0, p = e * n; h < p; h++)
        r[h] = 0;
    for (let h = 0, p = 0; h < n; h++) {
        const m = t.child(h);
        p++;
        for (let C = 0; ; C++) {
            for (; o < r.length && r[o] != 0; )
                o++;
            if (C == m.childCount)
                break;
            const S = m.child(C)
              , {colspan: w, rowspan: k, colwidth: A} = S.attrs;
            for (let O = 0; O < k; O++) {
                if (O + h >= n) {
                    (l || (l = [])).push({
                        type: "overlong_rowspan",
                        pos: p,
                        n: k - O
                    });
                    break
                }
                const B = o + O * e;
                for (let z = 0; z < w; z++) {
                    r[B + z] == 0 ? r[B + z] = p : (l || (l = [])).push({
                        type: "collision",
                        row: h,
                        pos: p,
                        n: w - z
                    });
                    const $ = A && A[z];
                    if ($) {
                        const _ = (B + z) % e * 2
                          , W = a[_];
                        W == null || W != $ && a[_ + 1] == 1 ? (a[_] = $,
                        a[_ + 1] = 1) : W == $ && a[_ + 1]++
                    }
                }
            }
            o += w,
            p += S.nodeSize
        }
        const y = (h + 1) * e;
        let b = 0;
        for (; o < y; )
            r[o++] == 0 && b++;
        b && (l || (l = [])).push({
            type: "missing",
            row: h,
            n: b
        }),
        p++
    }
    (e === 0 || n === 0) && (l || (l = [])).push({
        type: "zero_sized"
    });
    const u = new tt(e,n,r,l);
    let f = !1;
    for (let h = 0; !f && h < a.length; h += 2)
        a[h] != null && a[h + 1] < n && (f = !0);
    return f && JN(u, a, t),
    u
}
function XN(t) {
    let e = -1
      , n = !1;
    for (let r = 0; r < t.childCount; r++) {
        const o = t.child(r);
        let l = 0;
        if (n)
            for (let a = 0; a < r; a++) {
                const u = t.child(a);
                for (let f = 0; f < u.childCount; f++) {
                    const h = u.child(f);
                    a + h.attrs.rowspan > r && (l += h.attrs.colspan)
                }
            }
        for (let a = 0; a < o.childCount; a++) {
            const u = o.child(a);
            l += u.attrs.colspan,
            u.attrs.rowspan > 1 && (n = !0)
        }
        e == -1 ? e = l : e != l && (e = Math.max(e, l))
    }
    return e
}
function JN(t, e, n) {
    t.problems || (t.problems = []);
    const r = {};
    for (let o = 0; o < t.map.length; o++) {
        const l = t.map[o];
        if (r[l])
            continue;
        r[l] = !0;
        const a = n.nodeAt(l);
        if (!a)
            throw new RangeError(`No cell with offset ${l} found`);
        let u = null;
        const f = a.attrs;
        for (let h = 0; h < f.colspan; h++) {
            const p = e[(o + h) % t.width * 2];
            p != null && (!f.colwidth || f.colwidth[h] != p) && ((u || (u = QN(f)))[h] = p)
        }
        u && t.problems.unshift({
            type: "colwidth mismatch",
            pos: l,
            colwidth: u
        })
    }
}
function QN(t) {
    if (t.colwidth)
        return t.colwidth.slice();
    const e = [];
    for (let n = 0; n < t.colspan; n++)
        e.push(0);
    return e
}
function Lt(t) {
    let e = t.cached.tableNodeTypes;
    if (!e) {
        e = t.cached.tableNodeTypes = {};
        for (const n in t.nodes) {
            const r = t.nodes[n]
              , o = r.spec.tableRole;
            o && (e[o] = r)
        }
    }
    return e
}
const gi = new nt("selectingCells");
function wo(t) {
    for (let e = t.depth - 1; e > 0; e--)
        if (t.node(e).type.spec.tableRole == "row")
            return t.node(0).resolve(t.before(e + 1));
    return null
}
function eR(t) {
    for (let e = t.depth; e > 0; e--) {
        const n = t.node(e).type.spec.tableRole;
        if (n === "cell" || n === "header_cell")
            return t.node(e)
    }
    return null
}
function jn(t) {
    const e = t.selection.$head;
    for (let n = e.depth; n > 0; n--)
        if (e.node(n).type.spec.tableRole == "row")
            return !0;
    return !1
}
function qf(t) {
    const e = t.selection;
    if ("$anchorCell"in e && e.$anchorCell)
        return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
    if ("node"in e && e.node && e.node.type.spec.tableRole == "cell")
        return e.$anchor;
    const n = wo(e.$head) || tR(e.$head);
    if (n)
        return n;
    throw new RangeError(`No cell found around position ${e.head}`)
}
function tR(t) {
    for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild,
    n++) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell")
            return t.doc.resolve(n)
    }
    for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild,
    n--) {
        const r = e.type.spec.tableRole;
        if (r == "cell" || r == "header_cell")
            return t.doc.resolve(n - e.nodeSize)
    }
}
function Zm(t) {
    return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter
}
function nR(t) {
    return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize)
}
function ig(t, e) {
    return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1)
}
function s4(t, e, n) {
    const r = t.node(-1)
      , o = tt.get(r)
      , l = t.start(-1)
      , a = o.nextCell(t.pos - l, e, n);
    return a == null ? null : t.node(0).resolve(l + a)
}
function Eo(t, e, n=1) {
    const r = {
        ...t,
        colspan: t.colspan - n
    };
    return r.colwidth && (r.colwidth = r.colwidth.slice(),
    r.colwidth.splice(e, n),
    r.colwidth.some(o => o > 0) || (r.colwidth = null)),
    r
}
function a4(t, e, n=1) {
    const r = {
        ...t,
        colspan: t.colspan + n
    };
    if (r.colwidth) {
        r.colwidth = r.colwidth.slice();
        for (let o = 0; o < n; o++)
            r.colwidth.splice(e, 0, 0)
    }
    return r
}
function rR(t, e, n) {
    const r = Lt(e.type.schema).header_cell;
    for (let o = 0; o < t.height; o++)
        if (e.nodeAt(t.map[n + o * t.width]).type != r)
            return !1;
    return !0
}
var Pe = class Tr extends ye {
    constructor(e, n=e) {
        const r = e.node(-1)
          , o = tt.get(r)
          , l = e.start(-1)
          , a = o.rectBetween(e.pos - l, n.pos - l)
          , u = e.node(0)
          , f = o.cellsInRect(a).filter(p => p != n.pos - l);
        f.unshift(n.pos - l);
        const h = f.map(p => {
            const m = r.nodeAt(p);
            if (!m)
                throw new RangeError(`No cell with offset ${p} found`);
            const y = l + p + 1;
            return new QS(u.resolve(y),u.resolve(y + m.content.size))
        }
        );
        super(h[0].$from, h[0].$to, h),
        this.$anchorCell = e,
        this.$headCell = n
    }
    map(e, n) {
        const r = e.resolve(n.map(this.$anchorCell.pos))
          , o = e.resolve(n.map(this.$headCell.pos));
        if (Zm(r) && Zm(o) && ig(r, o)) {
            const l = this.$anchorCell.node(-1) != r.node(-1);
            return l && this.isRowSelection() ? Tr.rowSelection(r, o) : l && this.isColSelection() ? Tr.colSelection(r, o) : new Tr(r,o)
        }
        return se.between(r, o)
    }
    content() {
        const e = this.$anchorCell.node(-1)
          , n = tt.get(e)
          , r = this.$anchorCell.start(-1)
          , o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r)
          , l = {}
          , a = [];
        for (let f = o.top; f < o.bottom; f++) {
            const h = [];
            for (let p = f * n.width + o.left, m = o.left; m < o.right; m++,
            p++) {
                const y = n.map[p];
                if (l[y])
                    continue;
                l[y] = !0;
                const b = n.findCell(y);
                let C = e.nodeAt(y);
                if (!C)
                    throw new RangeError(`No cell with offset ${y} found`);
                const S = o.left - b.left
                  , w = b.right - o.right;
                if (S > 0 || w > 0) {
                    let k = C.attrs;
                    if (S > 0 && (k = Eo(k, 0, S)),
                    w > 0 && (k = Eo(k, k.colspan - w, w)),
                    b.left < o.left) {
                        if (C = C.type.createAndFill(k),
                        !C)
                            throw new RangeError(`Could not create cell with attrs ${JSON.stringify(k)}`)
                    } else
                        C = C.type.create(k, C.content)
                }
                if (b.top < o.top || b.bottom > o.bottom) {
                    const k = {
                        ...C.attrs,
                        rowspan: Math.min(b.bottom, o.bottom) - Math.max(b.top, o.top)
                    };
                    b.top < o.top ? C = C.type.createAndFill(k) : C = C.type.create(k, C.content)
                }
                h.push(C)
            }
            a.push(e.child(f).copy(Z.from(h)))
        }
        const u = this.isColSelection() && this.isRowSelection() ? e : a;
        return new te(Z.from(u),1,1)
    }
    replace(e, n=te.empty) {
        const r = e.steps.length
          , o = this.ranges;
        for (let a = 0; a < o.length; a++) {
            const {$from: u, $to: f} = o[a]
              , h = e.mapping.slice(r);
            e.replace(h.map(u.pos), h.map(f.pos), a ? te.empty : n)
        }
        const l = ye.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1);
        l && e.setSelection(l)
    }
    replaceWith(e, n) {
        this.replace(e, new te(Z.from(n),0,0))
    }
    forEachCell(e) {
        const n = this.$anchorCell.node(-1)
          , r = tt.get(n)
          , o = this.$anchorCell.start(-1)
          , l = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o));
        for (let a = 0; a < l.length; a++)
            e(n.nodeAt(l[a]), o + l[a])
    }
    isColSelection() {
        const e = this.$anchorCell.index(-1)
          , n = this.$headCell.index(-1);
        if (Math.min(e, n) > 0)
            return !1;
        const r = e + this.$anchorCell.nodeAfter.attrs.rowspan
          , o = n + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(r, o) == this.$headCell.node(-1).childCount
    }
    static colSelection(e, n=e) {
        const r = e.node(-1)
          , o = tt.get(r)
          , l = e.start(-1)
          , a = o.findCell(e.pos - l)
          , u = o.findCell(n.pos - l)
          , f = e.node(0);
        return a.top <= u.top ? (a.top > 0 && (e = f.resolve(l + o.map[a.left])),
        u.bottom < o.height && (n = f.resolve(l + o.map[o.width * (o.height - 1) + u.right - 1]))) : (u.top > 0 && (n = f.resolve(l + o.map[u.left])),
        a.bottom < o.height && (e = f.resolve(l + o.map[o.width * (o.height - 1) + a.right - 1]))),
        new Tr(e,n)
    }
    isRowSelection() {
        const e = this.$anchorCell.node(-1)
          , n = tt.get(e)
          , r = this.$anchorCell.start(-1)
          , o = n.colCount(this.$anchorCell.pos - r)
          , l = n.colCount(this.$headCell.pos - r);
        if (Math.min(o, l) > 0)
            return !1;
        const a = o + this.$anchorCell.nodeAfter.attrs.colspan
          , u = l + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(a, u) == n.width
    }
    eq(e) {
        return e instanceof Tr && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos
    }
    static rowSelection(e, n=e) {
        const r = e.node(-1)
          , o = tt.get(r)
          , l = e.start(-1)
          , a = o.findCell(e.pos - l)
          , u = o.findCell(n.pos - l)
          , f = e.node(0);
        return a.left <= u.left ? (a.left > 0 && (e = f.resolve(l + o.map[a.top * o.width])),
        u.right < o.width && (n = f.resolve(l + o.map[o.width * (u.top + 1) - 1]))) : (u.left > 0 && (n = f.resolve(l + o.map[u.top * o.width])),
        a.right < o.width && (e = f.resolve(l + o.map[o.width * (a.top + 1) - 1]))),
        new Tr(e,n)
    }
    toJSON() {
        return {
            type: "cell",
            anchor: this.$anchorCell.pos,
            head: this.$headCell.pos
        }
    }
    static fromJSON(e, n) {
        return new Tr(e.resolve(n.anchor),e.resolve(n.head))
    }
    static create(e, n, r=n) {
        return new Tr(e.resolve(n),e.resolve(r))
    }
    getBookmark() {
        return new iR(this.$anchorCell.pos,this.$headCell.pos)
    }
}
;
Pe.prototype.visible = !1;
ye.jsonID("cell", Pe);
var iR = class c4 {
    constructor(e, n) {
        this.anchor = e,
        this.head = n
    }
    map(e) {
        return new c4(e.map(this.anchor),e.map(this.head))
    }
    resolve(e) {
        const n = e.resolve(this.anchor)
          , r = e.resolve(this.head);
        return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && ig(n, r) ? new Pe(n,r) : ye.near(r, 1)
    }
}
;
function oR(t) {
    if (!(t.selection instanceof Pe))
        return null;
    const e = [];
    return t.selection.forEachCell( (n, r) => {
        e.push(yt.node(r, r + n.nodeSize, {
            class: "selectedCell"
        }))
    }
    ),
    Ue.create(t.doc, e)
}
function lR({$from: t, $to: e}) {
    if (t.pos == e.pos || t.pos < e.pos - 6)
        return !1;
    let n = t.pos
      , r = e.pos
      , o = t.depth;
    for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--,
    n++)
        ;
    for (let l = e.depth; l >= 0 && !(e.before(l + 1) > e.start(l)); l--,
    r--)
        ;
    return n == r && /row|table/.test(t.node(o).type.spec.tableRole)
}
function sR({$from: t, $to: e}) {
    let n, r;
    for (let o = t.depth; o > 0; o--) {
        const l = t.node(o);
        if (l.type.spec.tableRole === "cell" || l.type.spec.tableRole === "header_cell") {
            n = l;
            break
        }
    }
    for (let o = e.depth; o > 0; o--) {
        const l = e.node(o);
        if (l.type.spec.tableRole === "cell" || l.type.spec.tableRole === "header_cell") {
            r = l;
            break
        }
    }
    return n !== r && e.parentOffset === 0
}
function aR(t, e, n) {
    const r = (e || t).selection
      , o = (e || t).doc;
    let l, a;
    if (r instanceof le && (a = r.node.type.spec.tableRole)) {
        if (a == "cell" || a == "header_cell")
            l = Pe.create(o, r.from);
        else if (a == "row") {
            const u = o.resolve(r.from + 1);
            l = Pe.rowSelection(u, u)
        } else if (!n) {
            const u = tt.get(r.node)
              , f = r.from + 1
              , h = f + u.map[u.width * u.height - 1];
            l = Pe.create(o, f + 1, h)
        }
    } else
        r instanceof se && lR(r) ? l = se.create(o, r.from) : r instanceof se && sR(r) && (l = se.create(o, r.$from.start(), r.$from.end()));
    return l && (e || (e = t.tr)).setSelection(l),
    e
}
const cR = new nt("fix-tables");
function u4(t, e, n, r) {
    const o = t.childCount
      , l = e.childCount;
    e: for (let a = 0, u = 0; a < l; a++) {
        const f = e.child(a);
        for (let h = u, p = Math.min(o, a + 3); h < p; h++)
            if (t.child(h) == f) {
                u = h + 1,
                n += f.nodeSize;
                continue e
            }
        r(f, n),
        u < o && t.child(u).sameMarkup(f) ? u4(t.child(u), f, n + 1, r) : f.nodesBetween(0, f.content.size, r, n + 1),
        n += f.nodeSize
    }
}
function f4(t, e) {
    let n;
    const r = (o, l) => {
        o.type.spec.tableRole == "table" && (n = uR(t, o, l, n))
    }
    ;
    return e ? e.doc != t.doc && u4(e.doc, t.doc, 0, r) : t.doc.descendants(r),
    n
}
function uR(t, e, n, r) {
    const o = tt.get(e);
    if (!o.problems)
        return r;
    r || (r = t.tr);
    const l = [];
    for (let f = 0; f < o.height; f++)
        l.push(0);
    for (let f = 0; f < o.problems.length; f++) {
        const h = o.problems[f];
        if (h.type == "collision") {
            const p = e.nodeAt(h.pos);
            if (!p)
                continue;
            const m = p.attrs;
            for (let y = 0; y < m.rowspan; y++)
                l[h.row + y] += h.n;
            r.setNodeMarkup(r.mapping.map(n + 1 + h.pos), null, Eo(m, m.colspan - h.n, h.n))
        } else if (h.type == "missing")
            l[h.row] += h.n;
        else if (h.type == "overlong_rowspan") {
            const p = e.nodeAt(h.pos);
            if (!p)
                continue;
            r.setNodeMarkup(r.mapping.map(n + 1 + h.pos), null, {
                ...p.attrs,
                rowspan: p.attrs.rowspan - h.n
            })
        } else if (h.type == "colwidth mismatch") {
            const p = e.nodeAt(h.pos);
            if (!p)
                continue;
            r.setNodeMarkup(r.mapping.map(n + 1 + h.pos), null, {
                ...p.attrs,
                colwidth: h.colwidth
            })
        } else if (h.type == "zero_sized") {
            const p = r.mapping.map(n);
            r.delete(p, p + e.nodeSize)
        }
    }
    let a, u;
    for (let f = 0; f < l.length; f++)
        l[f] && (a == null && (a = f),
        u = f);
    for (let f = 0, h = n + 1; f < o.height; f++) {
        const p = e.child(f)
          , m = h + p.nodeSize
          , y = l[f];
        if (y > 0) {
            let b = "cell";
            p.firstChild && (b = p.firstChild.type.spec.tableRole);
            const C = [];
            for (let w = 0; w < y; w++) {
                const k = Lt(t.schema)[b].createAndFill();
                k && C.push(k)
            }
            const S = (f == 0 || a == f - 1) && u == f ? h + 1 : m - 1;
            r.insert(r.mapping.map(S), C)
        }
        h = m
    }
    return r.setMeta(cR, {
        fixTables: !0
    })
}
function Jn(t) {
    const e = t.selection
      , n = qf(t)
      , r = n.node(-1)
      , o = n.start(-1)
      , l = tt.get(r);
    return {
        ...e instanceof Pe ? l.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o) : l.findCell(n.pos - o),
        tableStart: o,
        map: l,
        table: r
    }
}
function d4(t, {map: e, tableStart: n, table: r}, o) {
    let l = o > 0 ? -1 : 0;
    rR(e, r, o + l) && (l = o == 0 || o == e.width ? null : 0);
    for (let a = 0; a < e.height; a++) {
        const u = a * e.width + o;
        if (o > 0 && o < e.width && e.map[u - 1] == e.map[u]) {
            const f = e.map[u]
              , h = r.nodeAt(f);
            t.setNodeMarkup(t.mapping.map(n + f), null, a4(h.attrs, o - e.colCount(f))),
            a += h.attrs.rowspan - 1
        } else {
            const f = l == null ? Lt(r.type.schema).cell : r.nodeAt(e.map[u + l]).type
              , h = e.positionAt(a, o, r);
            t.insert(t.mapping.map(n + h), f.createAndFill())
        }
    }
    return t
}
function fR(t, e) {
    if (!jn(t))
        return !1;
    if (e) {
        const n = Jn(t);
        e(d4(t.tr, n, n.left))
    }
    return !0
}
function dR(t, e) {
    if (!jn(t))
        return !1;
    if (e) {
        const n = Jn(t);
        e(d4(t.tr, n, n.right))
    }
    return !0
}
function hR(t, {map: e, table: n, tableStart: r}, o) {
    const l = t.mapping.maps.length;
    for (let a = 0; a < e.height; ) {
        const u = a * e.width + o
          , f = e.map[u]
          , h = n.nodeAt(f)
          , p = h.attrs;
        if (o > 0 && e.map[u - 1] == f || o < e.width - 1 && e.map[u + 1] == f)
            t.setNodeMarkup(t.mapping.slice(l).map(r + f), null, Eo(p, o - e.colCount(f)));
        else {
            const m = t.mapping.slice(l).map(r + f);
            t.delete(m, m + h.nodeSize)
        }
        a += p.rowspan
    }
}
function pR(t, e) {
    if (!jn(t))
        return !1;
    if (e) {
        const n = Jn(t)
          , r = t.tr;
        if (n.left == 0 && n.right == n.map.width)
            return !1;
        for (let o = n.right - 1; hR(r, n, o),
        o != n.left; o--) {
            const l = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
            if (!l)
                throw new RangeError("No table found");
            n.table = l,
            n.map = tt.get(l)
        }
        e(r)
    }
    return !0
}
function mR(t, e, n) {
    var r;
    const o = Lt(e.type.schema).header_cell;
    for (let l = 0; l < t.width; l++)
        if (((r = e.nodeAt(t.map[l + n * t.width])) === null || r === void 0 ? void 0 : r.type) != o)
            return !1;
    return !0
}
function h4(t, {map: e, tableStart: n, table: r}, o) {
    let l = n;
    for (let h = 0; h < o; h++)
        l += r.child(h).nodeSize;
    const a = [];
    let u = o > 0 ? -1 : 0;
    mR(e, r, o + u) && (u = o == 0 || o == e.height ? null : 0);
    for (let h = 0, p = e.width * o; h < e.width; h++,
    p++)
        if (o > 0 && o < e.height && e.map[p] == e.map[p - e.width]) {
            const m = e.map[p]
              , y = r.nodeAt(m).attrs;
            t.setNodeMarkup(n + m, null, {
                ...y,
                rowspan: y.rowspan + 1
            }),
            h += y.colspan - 1
        } else {
            var f;
            const m = u == null ? Lt(r.type.schema).cell : (f = r.nodeAt(e.map[p + u * e.width])) === null || f === void 0 ? void 0 : f.type
              , y = m?.createAndFill();
            y && a.push(y)
        }
    return t.insert(l, Lt(r.type.schema).row.create(null, a)),
    t
}
function gR(t, e) {
    if (!jn(t))
        return !1;
    if (e) {
        const n = Jn(t);
        e(h4(t.tr, n, n.top))
    }
    return !0
}
function yR(t, e) {
    if (!jn(t))
        return !1;
    if (e) {
        const n = Jn(t);
        e(h4(t.tr, n, n.bottom))
    }
    return !0
}
function vR(t, {map: e, table: n, tableStart: r}, o) {
    let l = 0;
    for (let h = 0; h < o; h++)
        l += n.child(h).nodeSize;
    const a = l + n.child(o).nodeSize
      , u = t.mapping.maps.length;
    t.delete(l + r, a + r);
    const f = new Set;
    for (let h = 0, p = o * e.width; h < e.width; h++,
    p++) {
        const m = e.map[p];
        if (!f.has(m)) {
            if (f.add(m),
            o > 0 && m == e.map[p - e.width]) {
                const y = n.nodeAt(m).attrs;
                t.setNodeMarkup(t.mapping.slice(u).map(m + r), null, {
                    ...y,
                    rowspan: y.rowspan - 1
                }),
                h += y.colspan - 1
            } else if (o < e.height && m == e.map[p + e.width]) {
                const y = n.nodeAt(m)
                  , b = y.attrs
                  , C = y.type.create({
                    ...b,
                    rowspan: y.attrs.rowspan - 1
                }, y.content)
                  , S = e.positionAt(o + 1, h, n);
                t.insert(t.mapping.slice(u).map(r + S), C),
                h += b.colspan - 1
            }
        }
    }
}
function bR(t, e) {
    if (!jn(t))
        return !1;
    if (e) {
        const n = Jn(t)
          , r = t.tr;
        if (n.top == 0 && n.bottom == n.map.height)
            return !1;
        for (let o = n.bottom - 1; vR(r, n, o),
        o != n.top; o--) {
            const l = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
            if (!l)
                throw new RangeError("No table found");
            n.table = l,
            n.map = tt.get(n.table)
        }
        e(r)
    }
    return !0
}
function gC(t) {
    const e = t.content;
    return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0
}
function CR({width: t, height: e, map: n}, r) {
    let o = r.top * t + r.left
      , l = o
      , a = (r.bottom - 1) * t + r.left
      , u = o + (r.right - r.left - 1);
    for (let f = r.top; f < r.bottom; f++) {
        if (r.left > 0 && n[l] == n[l - 1] || r.right < t && n[u] == n[u + 1])
            return !0;
        l += t,
        u += t
    }
    for (let f = r.left; f < r.right; f++) {
        if (r.top > 0 && n[o] == n[o - t] || r.bottom < e && n[a] == n[a + t])
            return !0;
        o++,
        a++
    }
    return !1
}
function yC(t, e) {
    const n = t.selection;
    if (!(n instanceof Pe) || n.$anchorCell.pos == n.$headCell.pos)
        return !1;
    const r = Jn(t)
      , {map: o} = r;
    if (CR(o, r))
        return !1;
    if (e) {
        const l = t.tr
          , a = {};
        let u = Z.empty, f, h;
        for (let p = r.top; p < r.bottom; p++)
            for (let m = r.left; m < r.right; m++) {
                const y = o.map[p * o.width + m]
                  , b = r.table.nodeAt(y);
                if (!(a[y] || !b))
                    if (a[y] = !0,
                    f == null)
                        f = y,
                        h = b;
                    else {
                        gC(b) || (u = u.append(b.content));
                        const C = l.mapping.map(y + r.tableStart);
                        l.delete(C, C + b.nodeSize)
                    }
            }
        if (f == null || h == null)
            return !0;
        if (l.setNodeMarkup(f + r.tableStart, null, {
            ...a4(h.attrs, h.attrs.colspan, r.right - r.left - h.attrs.colspan),
            rowspan: r.bottom - r.top
        }),
        u.size > 0) {
            const p = f + 1 + h.content.size
              , m = gC(h) ? f + 1 : p;
            l.replaceWith(m + r.tableStart, p + r.tableStart, u)
        }
        l.setSelection(new Pe(l.doc.resolve(f + r.tableStart))),
        e(l)
    }
    return !0
}
function vC(t, e) {
    const n = Lt(t.schema);
    return SR( ({node: r}) => n[r.type.spec.tableRole])(t, e)
}
function SR(t) {
    return (e, n) => {
        const r = e.selection;
        let o, l;
        if (r instanceof Pe) {
            if (r.$anchorCell.pos != r.$headCell.pos)
                return !1;
            o = r.$anchorCell.nodeAfter,
            l = r.$anchorCell.pos
        } else {
            var a;
            if (o = eR(r.$from),
            !o)
                return !1;
            l = (a = wo(r.$from)) === null || a === void 0 ? void 0 : a.pos
        }
        if (o == null || l == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1)
            return !1;
        if (n) {
            let u = o.attrs;
            const f = []
              , h = u.colwidth;
            u.rowspan > 1 && (u = {
                ...u,
                rowspan: 1
            }),
            u.colspan > 1 && (u = {
                ...u,
                colspan: 1
            });
            const p = Jn(e)
              , m = e.tr;
            for (let b = 0; b < p.right - p.left; b++)
                f.push(h ? {
                    ...u,
                    colwidth: h && h[b] ? [h[b]] : null
                } : u);
            let y;
            for (let b = p.top; b < p.bottom; b++) {
                let C = p.map.positionAt(b, p.left, p.table);
                b == p.top && (C += o.nodeSize);
                for (let S = p.left, w = 0; S < p.right; S++,
                w++)
                    S == p.left && b == p.top || m.insert(y = m.mapping.map(C + p.tableStart, 1), t({
                        node: o,
                        row: b,
                        col: S
                    }).createAndFill(f[w]))
            }
            m.setNodeMarkup(l, t({
                node: o,
                row: p.top,
                col: p.left
            }), f[0]),
            r instanceof Pe && m.setSelection(new Pe(m.doc.resolve(r.$anchorCell.pos),y ? m.doc.resolve(y) : void 0)),
            n(m)
        }
        return !0
    }
}
function xR(t, e) {
    return function(n, r) {
        if (!jn(n))
            return !1;
        const o = qf(n);
        if (o.nodeAfter.attrs[t] === e)
            return !1;
        if (r) {
            const l = n.tr;
            n.selection instanceof Pe ? n.selection.forEachCell( (a, u) => {
                a.attrs[t] !== e && l.setNodeMarkup(u, null, {
                    ...a.attrs,
                    [t]: e
                })
            }
            ) : l.setNodeMarkup(o.pos, null, {
                ...o.nodeAfter.attrs,
                [t]: e
            }),
            r(l)
        }
        return !0
    }
}
function wR(t) {
    return function(e, n) {
        if (!jn(e))
            return !1;
        if (n) {
            const r = Lt(e.schema)
              , o = Jn(e)
              , l = e.tr
              , a = o.map.cellsInRect(t == "column" ? {
                left: o.left,
                top: 0,
                right: o.right,
                bottom: o.map.height
            } : t == "row" ? {
                left: 0,
                top: o.top,
                right: o.map.width,
                bottom: o.bottom
            } : o)
              , u = a.map(f => o.table.nodeAt(f));
            for (let f = 0; f < a.length; f++)
                u[f].type == r.header_cell && l.setNodeMarkup(o.tableStart + a[f], r.cell, u[f].attrs);
            if (l.steps.length === 0)
                for (let f = 0; f < a.length; f++)
                    l.setNodeMarkup(o.tableStart + a[f], r.header_cell, u[f].attrs);
            n(l)
        }
        return !0
    }
}
function bC(t, e, n) {
    const r = e.map.cellsInRect({
        left: 0,
        top: 0,
        right: t == "row" ? e.map.width : 1,
        bottom: t == "column" ? e.map.height : 1
    });
    for (let o = 0; o < r.length; o++) {
        const l = e.table.nodeAt(r[o]);
        if (l && l.type !== n.header_cell)
            return !1
    }
    return !0
}
function ba(t, e) {
    return e = e || {
        useDeprecatedLogic: !1
    },
    e.useDeprecatedLogic ? wR(t) : function(n, r) {
        if (!jn(n))
            return !1;
        if (r) {
            const o = Lt(n.schema)
              , l = Jn(n)
              , a = n.tr
              , u = bC("row", l, o)
              , f = bC("column", l, o)
              , h = (t === "column" ? u : t === "row" && f) ? 1 : 0
              , p = t == "column" ? {
                left: 0,
                top: h,
                right: 1,
                bottom: l.map.height
            } : t == "row" ? {
                left: h,
                top: 0,
                right: l.map.width,
                bottom: 1
            } : l
              , m = t == "column" ? f ? o.cell : o.header_cell : t == "row" ? u ? o.cell : o.header_cell : o.cell;
            l.map.cellsInRect(p).forEach(y => {
                const b = y + l.tableStart
                  , C = a.doc.nodeAt(b);
                C && a.setNodeMarkup(b, m, C.attrs)
            }
            ),
            r(a)
        }
        return !0
    }
}
ba("row", {
    useDeprecatedLogic: !0
});
ba("column", {
    useDeprecatedLogic: !0
});
const ER = ba("cell", {
    useDeprecatedLogic: !0
});
function TR(t, e) {
    if (e < 0) {
        const n = t.nodeBefore;
        if (n)
            return t.pos - n.nodeSize;
        for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
            const l = t.node(-1).child(r)
              , a = l.lastChild;
            if (a)
                return o - 1 - a.nodeSize;
            o -= l.nodeSize
        }
    } else {
        if (t.index() < t.parent.childCount - 1)
            return t.pos + t.nodeAfter.nodeSize;
        const n = t.node(-1);
        for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
            const l = n.child(r);
            if (l.childCount)
                return o + 1;
            o += l.nodeSize
        }
    }
    return null
}
function CC(t) {
    return function(e, n) {
        if (!jn(e))
            return !1;
        const r = TR(qf(e), t);
        if (r == null)
            return !1;
        if (n) {
            const o = e.doc.resolve(r);
            n(e.tr.setSelection(se.between(o, nR(o))).scrollIntoView())
        }
        return !0
    }
}
function kR(t, e) {
    const n = t.selection.$anchor;
    for (let r = n.depth; r > 0; r--)
        if (n.node(r).type.spec.tableRole == "table")
            return e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()),
            !0;
    return !1
}
function lu(t, e) {
    const n = t.selection;
    if (!(n instanceof Pe))
        return !1;
    if (e) {
        const r = t.tr
          , o = Lt(t.schema).cell.createAndFill().content;
        n.forEachCell( (l, a) => {
            l.content.eq(o) || r.replace(r.mapping.map(a + 1), r.mapping.map(a + l.nodeSize - 1), new te(o,0,0))
        }
        ),
        r.docChanged && e(r)
    }
    return !0
}
function MR(t) {
    if (t.size === 0)
        return null;
    let {content: e, openStart: n, openEnd: r} = t;
    for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
        n--,
        r--,
        e = e.child(0).content;
    const o = e.child(0)
      , l = o.type.spec.tableRole
      , a = o.type.schema
      , u = [];
    if (l == "row")
        for (let f = 0; f < e.childCount; f++) {
            let h = e.child(f).content;
            const p = f ? 0 : Math.max(0, n - 1)
              , m = f < e.childCount - 1 ? 0 : Math.max(0, r - 1);
            (p || m) && (h = Wm(Lt(a).row, new te(h,p,m)).content),
            u.push(h)
        }
    else if (l == "cell" || l == "header_cell")
        u.push(n || r ? Wm(Lt(a).row, new te(e,n,r)).content : e);
    else
        return null;
    return AR(a, u)
}
function AR(t, e) {
    const n = [];
    for (let o = 0; o < e.length; o++) {
        const l = e[o];
        for (let a = l.childCount - 1; a >= 0; a--) {
            const {rowspan: u, colspan: f} = l.child(a).attrs;
            for (let h = o; h < o + u; h++)
                n[h] = (n[h] || 0) + f
        }
    }
    let r = 0;
    for (let o = 0; o < n.length; o++)
        r = Math.max(r, n[o]);
    for (let o = 0; o < n.length; o++)
        if (o >= e.length && e.push(Z.empty),
        n[o] < r) {
            const l = Lt(t).cell.createAndFill()
              , a = [];
            for (let u = n[o]; u < r; u++)
                a.push(l);
            e[o] = e[o].append(Z.from(a))
        }
    return {
        height: e.length,
        width: r,
        rows: e
    }
}
function Wm(t, e) {
    const n = t.createAndFill();
    return new v1(n).replace(0, n.content.size, e).doc
}
function NR({width: t, height: e, rows: n}, r, o) {
    if (t != r) {
        const l = []
          , a = [];
        for (let u = 0; u < n.length; u++) {
            const f = n[u]
              , h = [];
            for (let p = l[u] || 0, m = 0; p < r; m++) {
                let y = f.child(m % f.childCount);
                p + y.attrs.colspan > r && (y = y.type.createChecked(Eo(y.attrs, y.attrs.colspan, p + y.attrs.colspan - r), y.content)),
                h.push(y),
                p += y.attrs.colspan;
                for (let b = 1; b < y.attrs.rowspan; b++)
                    l[u + b] = (l[u + b] || 0) + y.attrs.colspan
            }
            a.push(Z.from(h))
        }
        n = a,
        t = r
    }
    if (e != o) {
        const l = [];
        for (let a = 0, u = 0; a < o; a++,
        u++) {
            const f = []
              , h = n[u % e];
            for (let p = 0; p < h.childCount; p++) {
                let m = h.child(p);
                a + m.attrs.rowspan > o && (m = m.type.create({
                    ...m.attrs,
                    rowspan: Math.max(1, o - m.attrs.rowspan)
                }, m.content)),
                f.push(m)
            }
            l.push(Z.from(f))
        }
        n = l,
        e = o
    }
    return {
        width: t,
        height: e,
        rows: n
    }
}
function RR(t, e, n, r, o, l, a) {
    const u = t.doc.type.schema
      , f = Lt(u);
    let h, p;
    if (o > e.width)
        for (let m = 0, y = 0; m < e.height; m++) {
            const b = n.child(m);
            y += b.nodeSize;
            const C = [];
            let S;
            b.lastChild == null || b.lastChild.type == f.cell ? S = h || (h = f.cell.createAndFill()) : S = p || (p = f.header_cell.createAndFill());
            for (let w = e.width; w < o; w++)
                C.push(S);
            t.insert(t.mapping.slice(a).map(y - 1 + r), C)
        }
    if (l > e.height) {
        const m = [];
        for (let C = 0, S = (e.height - 1) * e.width; C < Math.max(e.width, o); C++) {
            const w = C >= e.width ? !1 : n.nodeAt(e.map[S + C]).type == f.header_cell;
            m.push(w ? p || (p = f.header_cell.createAndFill()) : h || (h = f.cell.createAndFill()))
        }
        const y = f.row.create(null, Z.from(m))
          , b = [];
        for (let C = e.height; C < l; C++)
            b.push(y);
        t.insert(t.mapping.slice(a).map(r + n.nodeSize - 2), b)
    }
    return !!(h || p)
}
function SC(t, e, n, r, o, l, a, u) {
    if (a == 0 || a == e.height)
        return !1;
    let f = !1;
    for (let h = o; h < l; h++) {
        const p = a * e.width + h
          , m = e.map[p];
        if (e.map[p - e.width] == m) {
            f = !0;
            const y = n.nodeAt(m)
              , {top: b, left: C} = e.findCell(m);
            t.setNodeMarkup(t.mapping.slice(u).map(m + r), null, {
                ...y.attrs,
                rowspan: a - b
            }),
            t.insert(t.mapping.slice(u).map(e.positionAt(a, C, n)), y.type.createAndFill({
                ...y.attrs,
                rowspan: b + y.attrs.rowspan - a
            })),
            h += y.attrs.colspan - 1
        }
    }
    return f
}
function xC(t, e, n, r, o, l, a, u) {
    if (a == 0 || a == e.width)
        return !1;
    let f = !1;
    for (let h = o; h < l; h++) {
        const p = h * e.width + a
          , m = e.map[p];
        if (e.map[p - 1] == m) {
            f = !0;
            const y = n.nodeAt(m)
              , b = e.colCount(m)
              , C = t.mapping.slice(u).map(m + r);
            t.setNodeMarkup(C, null, Eo(y.attrs, a - b, y.attrs.colspan - (a - b))),
            t.insert(C + y.nodeSize, y.type.createAndFill(Eo(y.attrs, 0, a - b))),
            h += y.attrs.rowspan - 1
        }
    }
    return f
}
function wC(t, e, n, r, o) {
    let l = n ? t.doc.nodeAt(n - 1) : t.doc;
    if (!l)
        throw new Error("No table found");
    let a = tt.get(l);
    const {top: u, left: f} = r
      , h = f + o.width
      , p = u + o.height
      , m = t.tr;
    let y = 0;
    function b() {
        if (l = n ? m.doc.nodeAt(n - 1) : m.doc,
        !l)
            throw new Error("No table found");
        a = tt.get(l),
        y = m.mapping.maps.length
    }
    RR(m, a, l, n, h, p, y) && b(),
    SC(m, a, l, n, f, h, u, y) && b(),
    SC(m, a, l, n, f, h, p, y) && b(),
    xC(m, a, l, n, u, p, f, y) && b(),
    xC(m, a, l, n, u, p, h, y) && b();
    for (let C = u; C < p; C++) {
        const S = a.positionAt(C, f, l)
          , w = a.positionAt(C, h, l);
        m.replace(m.mapping.slice(y).map(S + n), m.mapping.slice(y).map(w + n), new te(o.rows[C - u],0,0))
    }
    b(),
    m.setSelection(new Pe(m.doc.resolve(n + a.positionAt(u, f, l)),m.doc.resolve(n + a.positionAt(p - 1, h - 1, l)))),
    e(m)
}
const OR = z1({
    ArrowLeft: su("horiz", -1),
    ArrowRight: su("horiz", 1),
    ArrowUp: su("vert", -1),
    ArrowDown: su("vert", 1),
    "Shift-ArrowLeft": au("horiz", -1),
    "Shift-ArrowRight": au("horiz", 1),
    "Shift-ArrowUp": au("vert", -1),
    "Shift-ArrowDown": au("vert", 1),
    Backspace: lu,
    "Mod-Backspace": lu,
    Delete: lu,
    "Mod-Delete": lu
});
function xu(t, e, n) {
    return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()),
    !0)
}
function su(t, e) {
    return (n, r, o) => {
        if (!o)
            return !1;
        const l = n.selection;
        if (l instanceof Pe)
            return xu(n, r, ye.near(l.$headCell, e));
        if (t != "horiz" && !l.empty)
            return !1;
        const a = p4(o, t, e);
        if (a == null)
            return !1;
        if (t == "horiz")
            return xu(n, r, ye.near(n.doc.resolve(l.head + e), e));
        {
            const u = n.doc.resolve(a)
              , f = s4(u, t, e);
            let h;
            return f ? h = ye.near(f, 1) : e < 0 ? h = ye.near(n.doc.resolve(u.before(-1)), -1) : h = ye.near(n.doc.resolve(u.after(-1)), 1),
            xu(n, r, h)
        }
    }
}
function au(t, e) {
    return (n, r, o) => {
        if (!o)
            return !1;
        const l = n.selection;
        let a;
        if (l instanceof Pe)
            a = l;
        else {
            const f = p4(o, t, e);
            if (f == null)
                return !1;
            a = new Pe(n.doc.resolve(f))
        }
        const u = s4(a.$headCell, t, e);
        return u ? xu(n, r, new Pe(a.$anchorCell,u)) : !1
    }
}
function DR(t, e) {
    const n = t.state.doc
      , r = wo(n.resolve(e));
    return r ? (t.dispatch(t.state.tr.setSelection(new Pe(r))),
    !0) : !1
}
function LR(t, e, n) {
    if (!jn(t.state))
        return !1;
    let r = MR(n);
    const o = t.state.selection;
    if (o instanceof Pe) {
        r || (r = {
            width: 1,
            height: 1,
            rows: [Z.from(Wm(Lt(t.state.schema).cell, n))]
        });
        const l = o.$anchorCell.node(-1)
          , a = o.$anchorCell.start(-1)
          , u = tt.get(l).rectBetween(o.$anchorCell.pos - a, o.$headCell.pos - a);
        return r = NR(r, u.right - u.left, u.bottom - u.top),
        wC(t.state, t.dispatch, a, u, r),
        !0
    } else if (r) {
        const l = qf(t.state)
          , a = l.start(-1);
        return wC(t.state, t.dispatch, a, tt.get(l.node(-1)).findCell(l.pos - a), r),
        !0
    } else
        return !1
}
function zR(t, e) {
    var n;
    if (e.button != 0 || e.ctrlKey || e.metaKey)
        return;
    const r = EC(t, e.target);
    let o;
    if (e.shiftKey && t.state.selection instanceof Pe)
        l(t.state.selection.$anchorCell, e),
        e.preventDefault();
    else if (e.shiftKey && r && (o = wo(t.state.selection.$anchor)) != null && ((n = Qp(t, e)) === null || n === void 0 ? void 0 : n.pos) != o.pos)
        l(o, e),
        e.preventDefault();
    else if (!r)
        return;
    function l(f, h) {
        let p = Qp(t, h);
        const m = gi.getState(t.state) == null;
        if (!p || !ig(f, p))
            if (m)
                p = f;
            else
                return;
        const y = new Pe(f,p);
        if (m || !t.state.selection.eq(y)) {
            const b = t.state.tr.setSelection(y);
            m && b.setMeta(gi, f.pos),
            t.dispatch(b)
        }
    }
    function a() {
        t.root.removeEventListener("mouseup", a),
        t.root.removeEventListener("dragstart", a),
        t.root.removeEventListener("mousemove", u),
        gi.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(gi, -1))
    }
    function u(f) {
        const h = f
          , p = gi.getState(t.state);
        let m;
        if (p != null)
            m = t.state.doc.resolve(p);
        else if (EC(t, h.target) != r && (m = Qp(t, e),
        !m))
            return a();
        m && l(m, h)
    }
    t.root.addEventListener("mouseup", a),
    t.root.addEventListener("dragstart", a),
    t.root.addEventListener("mousemove", u)
}
function p4(t, e, n) {
    if (!(t.state.selection instanceof se))
        return null;
    const {$head: r} = t.state.selection;
    for (let o = r.depth - 1; o >= 0; o--) {
        const l = r.node(o);
        if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : l.childCount))
            return null;
        if (l.type.spec.tableRole == "cell" || l.type.spec.tableRole == "header_cell") {
            const a = r.before(o)
              , u = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
            return t.endOfTextblock(u) ? a : null
        }
    }
    return null
}
function EC(t, e) {
    for (; e && e != t.dom; e = e.parentNode)
        if (e.nodeName == "TD" || e.nodeName == "TH")
            return e;
    return null
}
function Qp(t, e) {
    const n = t.posAtCoords({
        left: e.clientX,
        top: e.clientY
    });
    if (!n)
        return null;
    let {inside: r, pos: o} = n;
    return r >= 0 && wo(t.state.doc.resolve(r)) || wo(t.state.doc.resolve(o))
}
var _R = class {
    constructor(e, n) {
        this.node = e,
        this.defaultCellMinWidth = n,
        this.dom = document.createElement("div"),
        this.dom.className = "tableWrapper",
        this.table = this.dom.appendChild(document.createElement("table")),
        this.table.style.setProperty("--default-cell-min-width", `${n}px`),
        this.colgroup = this.table.appendChild(document.createElement("colgroup")),
        Xm(e, this.colgroup, this.table, n),
        this.contentDOM = this.table.appendChild(document.createElement("tbody"))
    }
    update(e) {
        return e.type != this.node.type ? !1 : (this.node = e,
        Xm(e, this.colgroup, this.table, this.defaultCellMinWidth),
        !0)
    }
    ignoreMutation(e) {
        return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target))
    }
}
;
function Xm(t, e, n, r, o, l) {
    let a = 0
      , u = !0
      , f = e.firstChild;
    const h = t.firstChild;
    if (h) {
        for (let m = 0, y = 0; m < h.childCount; m++) {
            const {colspan: b, colwidth: C} = h.child(m).attrs;
            for (let S = 0; S < b; S++,
            y++) {
                const w = o == y ? l : C && C[S]
                  , k = w ? w + "px" : "";
                if (a += w || r,
                w || (u = !1),
                f)
                    f.style.width != k && (f.style.width = k),
                    f = f.nextSibling;
                else {
                    const A = document.createElement("col");
                    A.style.width = k,
                    e.appendChild(A)
                }
            }
        }
        for (; f; ) {
            var p;
            const m = f.nextSibling;
            (p = f.parentNode) === null || p === void 0 || p.removeChild(f),
            f = m
        }
        u ? (n.style.width = a + "px",
        n.style.minWidth = "") : (n.style.width = "",
        n.style.minWidth = a + "px")
    }
}
const fn = new nt("tableColumnResizing");
function BR({handleWidth: t=5, cellMinWidth: e=25, defaultCellMinWidth: n=100, View: r=_R, lastColumnResizable: o=!0}={}) {
    const l = new Ye({
        key: fn,
        state: {
            init(a, u) {
                var f;
                const h = (f = l.spec) === null || f === void 0 || (f = f.props) === null || f === void 0 ? void 0 : f.nodeViews
                  , p = Lt(u.schema).table.name;
                return r && h && (h[p] = (m, y) => new r(m,n,y)),
                new jR(-1,!1)
            },
            apply(a, u) {
                return u.apply(a)
            }
        },
        props: {
            attributes: a => {
                const u = fn.getState(a);
                return u && u.activeHandle > -1 ? {
                    class: "resize-cursor"
                } : {}
            }
            ,
            handleDOMEvents: {
                mousemove: (a, u) => {
                    HR(a, u, t, o)
                }
                ,
                mouseleave: a => {
                    IR(a)
                }
                ,
                mousedown: (a, u) => {
                    VR(a, u, e, n)
                }
            },
            decorations: a => {
                const u = fn.getState(a);
                if (u && u.activeHandle > -1)
                    return FR(a, u.activeHandle)
            }
            ,
            nodeViews: {}
        }
    });
    return l
}
var jR = class wu {
    constructor(e, n) {
        this.activeHandle = e,
        this.dragging = n
    }
    apply(e) {
        const n = this
          , r = e.getMeta(fn);
        if (r && r.setHandle != null)
            return new wu(r.setHandle,!1);
        if (r && r.setDragging !== void 0)
            return new wu(n.activeHandle,r.setDragging);
        if (n.activeHandle > -1 && e.docChanged) {
            let o = e.mapping.map(n.activeHandle, -1);
            return Zm(e.doc.resolve(o)) || (o = -1),
            new wu(o,n.dragging)
        }
        return n
    }
}
;
function HR(t, e, n, r) {
    if (!t.editable)
        return;
    const o = fn.getState(t.state);
    if (o && !o.dragging) {
        const l = PR(e.target);
        let a = -1;
        if (l) {
            const {left: u, right: f} = l.getBoundingClientRect();
            e.clientX - u <= n ? a = TC(t, e, "left", n) : f - e.clientX <= n && (a = TC(t, e, "right", n))
        }
        if (a != o.activeHandle) {
            if (!r && a !== -1) {
                const u = t.state.doc.resolve(a)
                  , f = u.node(-1)
                  , h = tt.get(f)
                  , p = u.start(-1);
                if (h.colCount(u.pos - p) + u.nodeAfter.attrs.colspan - 1 == h.width - 1)
                    return
            }
            m4(t, a)
        }
    }
}
function IR(t) {
    if (!t.editable)
        return;
    const e = fn.getState(t.state);
    e && e.activeHandle > -1 && !e.dragging && m4(t, -1)
}
function VR(t, e, n, r) {
    var o;
    if (!t.editable)
        return !1;
    const l = (o = t.dom.ownerDocument.defaultView) !== null && o !== void 0 ? o : window
      , a = fn.getState(t.state);
    if (!a || a.activeHandle == -1 || a.dragging)
        return !1;
    const u = t.state.doc.nodeAt(a.activeHandle)
      , f = UR(t, a.activeHandle, u.attrs);
    t.dispatch(t.state.tr.setMeta(fn, {
        setDragging: {
            startX: e.clientX,
            startWidth: f
        }
    }));
    function h(m) {
        l.removeEventListener("mouseup", h),
        l.removeEventListener("mousemove", p);
        const y = fn.getState(t.state);
        y?.dragging && (qR(t, y.activeHandle, kC(y.dragging, m, n)),
        t.dispatch(t.state.tr.setMeta(fn, {
            setDragging: null
        })))
    }
    function p(m) {
        if (!m.which)
            return h(m);
        const y = fn.getState(t.state);
        if (y && y.dragging) {
            const b = kC(y.dragging, m, n);
            MC(t, y.activeHandle, b, r)
        }
    }
    return MC(t, a.activeHandle, f, r),
    l.addEventListener("mouseup", h),
    l.addEventListener("mousemove", p),
    e.preventDefault(),
    !0
}
function UR(t, e, {colspan: n, colwidth: r}) {
    const o = r && r[r.length - 1];
    if (o)
        return o;
    const l = t.domAtPos(e);
    let a = l.node.childNodes[l.offset].offsetWidth
      , u = n;
    if (r)
        for (let f = 0; f < n; f++)
            r[f] && (a -= r[f],
            u--);
    return a / u
}
function PR(t) {
    for (; t && t.nodeName != "TD" && t.nodeName != "TH"; )
        t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
    return t
}
function TC(t, e, n, r) {
    const o = n == "right" ? -r : r
      , l = t.posAtCoords({
        left: e.clientX + o,
        top: e.clientY
    });
    if (!l)
        return -1;
    const {pos: a} = l
      , u = wo(t.state.doc.resolve(a));
    if (!u)
        return -1;
    if (n == "right")
        return u.pos;
    const f = tt.get(u.node(-1))
      , h = u.start(-1)
      , p = f.map.indexOf(u.pos - h);
    return p % f.width == 0 ? -1 : h + f.map[p - 1]
}
function kC(t, e, n) {
    const r = e.clientX - t.startX;
    return Math.max(n, t.startWidth + r)
}
function m4(t, e) {
    t.dispatch(t.state.tr.setMeta(fn, {
        setHandle: e
    }))
}
function qR(t, e, n) {
    const r = t.state.doc.resolve(e)
      , o = r.node(-1)
      , l = tt.get(o)
      , a = r.start(-1)
      , u = l.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1
      , f = t.state.tr;
    for (let h = 0; h < l.height; h++) {
        const p = h * l.width + u;
        if (h && l.map[p] == l.map[p - l.width])
            continue;
        const m = l.map[p]
          , y = o.nodeAt(m).attrs
          , b = y.colspan == 1 ? 0 : u - l.colCount(m);
        if (y.colwidth && y.colwidth[b] == n)
            continue;
        const C = y.colwidth ? y.colwidth.slice() : $R(y.colspan);
        C[b] = n,
        f.setNodeMarkup(a + m, null, {
            ...y,
            colwidth: C
        })
    }
    f.docChanged && t.dispatch(f)
}
function MC(t, e, n, r) {
    const o = t.state.doc.resolve(e)
      , l = o.node(-1)
      , a = o.start(-1)
      , u = tt.get(l).colCount(o.pos - a) + o.nodeAfter.attrs.colspan - 1;
    let f = t.domAtPos(o.start(-1)).node;
    for (; f && f.nodeName != "TABLE"; )
        f = f.parentNode;
    f && Xm(l, f.firstChild, f, r, u, n)
}
function $R(t) {
    return Array(t).fill(0)
}
function FR(t, e) {
    const n = []
      , r = t.doc.resolve(e)
      , o = r.node(-1);
    if (!o)
        return Ue.empty;
    const l = tt.get(o)
      , a = r.start(-1)
      , u = l.colCount(r.pos - a) + r.nodeAfter.attrs.colspan - 1;
    for (let h = 0; h < l.height; h++) {
        const p = u + h * l.width;
        if ((u == l.width - 1 || l.map[p] != l.map[p + 1]) && (h == 0 || l.map[p] != l.map[p - l.width])) {
            var f;
            const m = l.map[p]
              , y = a + m + o.nodeAt(m).nodeSize - 1
              , b = document.createElement("div");
            b.className = "column-resize-handle",
            !((f = fn.getState(t)) === null || f === void 0) && f.dragging && n.push(yt.node(a + m, a + m + o.nodeAt(m).nodeSize, {
                class: "column-resize-dragging"
            })),
            n.push(yt.widget(y, b))
        }
    }
    return Ue.create(t.doc, n)
}
function KR({allowTableNodeSelection: t=!1}={}) {
    return new Ye({
        key: gi,
        state: {
            init() {
                return null
            },
            apply(e, n) {
                const r = e.getMeta(gi);
                if (r != null)
                    return r == -1 ? null : r;
                if (n == null || !e.docChanged)
                    return n;
                const {deleted: o, pos: l} = e.mapping.mapResult(n);
                return o ? null : l
            }
        },
        props: {
            decorations: oR,
            handleDOMEvents: {
                mousedown: zR
            },
            createSelectionBetween(e) {
                return gi.getState(e.state) != null ? e.state.selection : null
            },
            handleTripleClick: DR,
            handleKeyDown: OR,
            handlePaste: LR
        },
        appendTransaction(e, n, r) {
            return aR(r, f4(r, n), t)
        }
    })
}
var GR = Nt.create({
    name: "tableCell",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "block+",
    addAttributes() {
        return {
            colspan: {
                default: 1
            },
            rowspan: {
                default: 1
            },
            colwidth: {
                default: null,
                parseHTML: t => {
                    var e, n;
                    const r = t.getAttribute("colwidth")
                      , o = r ? r.split(",").map(l => parseInt(l, 10)) : null;
                    if (!o) {
                        const l = (e = t.closest("table")) == null ? void 0 : e.querySelectorAll("colgroup > col")
                          , a = Array.from(((n = t.parentElement) == null ? void 0 : n.children) || []).indexOf(t);
                        if (a && a > -1 && l && l[a]) {
                            const u = l[a].getAttribute("width");
                            return u ? [parseInt(u, 10)] : null
                        }
                    }
                    return o
                }
            }
        }
    },
    tableRole: "cell",
    isolating: !0,
    parseHTML() {
        return [{
            tag: "td"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["td", We(this.options.HTMLAttributes, t), 0]
    }
})
  , YR = Nt.create({
    name: "tableHeader",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "block+",
    addAttributes() {
        return {
            colspan: {
                default: 1
            },
            rowspan: {
                default: 1
            },
            colwidth: {
                default: null,
                parseHTML: t => {
                    const e = t.getAttribute("colwidth");
                    return e ? e.split(",").map(r => parseInt(r, 10)) : null
                }
            }
        }
    },
    tableRole: "header_cell",
    isolating: !0,
    parseHTML() {
        return [{
            tag: "th"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["th", We(this.options.HTMLAttributes, t), 0]
    }
})
  , ZR = Nt.create({
    name: "tableRow",
    addOptions() {
        return {
            HTMLAttributes: {}
        }
    },
    content: "(tableCell | tableHeader)*",
    tableRole: "row",
    parseHTML() {
        return [{
            tag: "tr"
        }]
    },
    renderHTML({HTMLAttributes: t}) {
        return ["tr", We(this.options.HTMLAttributes, t), 0]
    }
});
function Jm(t, e) {
    return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`]
}
function AC(t, e, n, r, o, l) {
    var a;
    let u = 0
      , f = !0
      , h = e.firstChild;
    const p = t.firstChild;
    if (p !== null)
        for (let y = 0, b = 0; y < p.childCount; y += 1) {
            const {colspan: C, colwidth: S} = p.child(y).attrs;
            for (let w = 0; w < C; w += 1,
            b += 1) {
                const k = o === b ? l : S && S[w]
                  , A = k ? `${k}px` : "";
                if (u += k || r,
                k || (f = !1),
                h) {
                    if (h.style.width !== A) {
                        const [O,B] = Jm(r, k);
                        h.style.setProperty(O, B)
                    }
                    h = h.nextSibling
                } else {
                    const O = document.createElement("col")
                      , [B,z] = Jm(r, k);
                    O.style.setProperty(B, z),
                    e.appendChild(O)
                }
            }
        }
    for (; h; ) {
        const y = h.nextSibling;
        (a = h.parentNode) == null || a.removeChild(h),
        h = y
    }
    const m = t.attrs.style && typeof t.attrs.style == "string" && /\bwidth\s*:/i.test(t.attrs.style);
    f && !m ? (n.style.width = `${u}px`,
    n.style.minWidth = "") : (n.style.width = "",
    n.style.minWidth = `${u}px`)
}
var WR = class {
    constructor(t, e) {
        this.node = t,
        this.cellMinWidth = e,
        this.dom = document.createElement("div"),
        this.dom.className = "tableWrapper",
        this.table = this.dom.appendChild(document.createElement("table")),
        t.attrs.style && (this.table.style.cssText = t.attrs.style),
        this.colgroup = this.table.appendChild(document.createElement("colgroup")),
        AC(t, this.colgroup, this.table, e),
        this.contentDOM = this.table.appendChild(document.createElement("tbody"))
    }
    update(t) {
        return t.type !== this.node.type ? !1 : (this.node = t,
        AC(t, this.colgroup, this.table, this.cellMinWidth),
        !0)
    }
    ignoreMutation(t) {
        const e = t.target
          , n = this.dom.contains(e)
          , r = this.contentDOM.contains(e);
        return !!(n && !r && (t.type === "attributes" || t.type === "childList" || t.type === "characterData"))
    }
}
;
function XR(t, e, n, r) {
    let o = 0
      , l = !0;
    const a = []
      , u = t.firstChild;
    if (!u)
        return {};
    for (let m = 0, y = 0; m < u.childCount; m += 1) {
        const {colspan: b, colwidth: C} = u.child(m).attrs;
        for (let S = 0; S < b; S += 1,
        y += 1) {
            const w = n === y ? r : C && C[S];
            o += w || e,
            w || (l = !1);
            const [k,A] = Jm(e, w);
            a.push(["col", {
                style: `${k}: ${A}`
            }])
        }
    }
    const f = l ? `${o}px` : ""
      , h = l ? "" : `${o}px`;
    return {
        colgroup: ["colgroup", {}, ...a],
        tableWidth: f,
        tableMinWidth: h
    }
}
function NC(t, e) {
    return t.createAndFill()
}
function JR(t) {
    if (t.cached.tableNodeTypes)
        return t.cached.tableNodeTypes;
    const e = {};
    return Object.keys(t.nodes).forEach(n => {
        const r = t.nodes[n];
        r.spec.tableRole && (e[r.spec.tableRole] = r)
    }
    ),
    t.cached.tableNodeTypes = e,
    e
}
function QR(t, e, n, r, o) {
    const l = JR(t)
      , a = []
      , u = [];
    for (let h = 0; h < n; h += 1) {
        const p = NC(l.cell);
        if (p && u.push(p),
        r) {
            const m = NC(l.header_cell);
            m && a.push(m)
        }
    }
    const f = [];
    for (let h = 0; h < e; h += 1)
        f.push(l.row.createChecked(null, r && h === 0 ? a : u));
    return l.table.createChecked(null, f)
}
function eO(t) {
    return t instanceof Pe
}
var cu = ({editor: t}) => {
    const {selection: e} = t.state;
    if (!eO(e))
        return !1;
    let n = 0;
    const r = r3(e.ranges[0].$from, l => l.type.name === "table");
    return r?.node.descendants(l => {
        if (l.type.name === "table")
            return !1;
        ["tableCell", "tableHeader"].includes(l.type.name) && (n += 1)
    }
    ),
    n === e.ranges.length ? (t.commands.deleteTable(),
    !0) : !1
}
  , tO = "";
function nO(t) {
    return (t || "").replace(/\s+/g, " ").trim()
}
function rO(t, e, n={}) {
    var r;
    const o = (r = n.cellLineSeparator) != null ? r : tO;
    if (!t || !t.content || t.content.length === 0)
        return "";
    const l = [];
    t.content.forEach(C => {
        const S = [];
        C.content && C.content.forEach(w => {
            let k = "";
            w.content && Array.isArray(w.content) && w.content.length > 1 ? k = w.content.map(z => e.renderChildren(z)).join(o) : k = w.content ? e.renderChildren(w.content) : "";
            const A = nO(k)
              , O = w.type === "tableHeader";
            S.push({
                text: A,
                isHeader: O
            })
        }
        ),
        l.push(S)
    }
    );
    const a = l.reduce( (C, S) => Math.max(C, S.length), 0);
    if (a === 0)
        return "";
    const u = new Array(a).fill(0);
    l.forEach(C => {
        var S;
        for (let w = 0; w < a; w += 1) {
            const A = (((S = C[w]) == null ? void 0 : S.text) || "").length;
            A > u[w] && (u[w] = A),
            u[w] < 3 && (u[w] = 3)
        }
    }
    );
    const f = (C, S) => C + " ".repeat(Math.max(0, S - C.length))
      , h = l[0]
      , p = h.some(C => C.isHeader);
    let m = `
`;
    const y = new Array(a).fill(0).map( (C, S) => p && h[S] && h[S].text || "");
    return m += `| ${y.map( (C, S) => f(C, u[S])).join(" | ")} |
`,
    m += `| ${u.map(C => "-".repeat(Math.max(3, C))).join(" | ")} |
`,
    (p ? l.slice(1) : l).forEach(C => {
        m += `| ${new Array(a).fill(0).map( (S, w) => f(C[w] && C[w].text || "", u[w])).join(" | ")} |
`
    }
    ),
    m
}
var iO = rO
  , oO = Nt.create({
    name: "table",
    addOptions() {
        return {
            HTMLAttributes: {},
            resizable: !1,
            renderWrapper: !1,
            handleWidth: 5,
            cellMinWidth: 25,
            View: WR,
            lastColumnResizable: !0,
            allowTableNodeSelection: !1
        }
    },
    content: "tableRow+",
    tableRole: "table",
    isolating: !0,
    group: "block",
    parseHTML() {
        return [{
            tag: "table"
        }]
    },
    renderHTML({node: t, HTMLAttributes: e}) {
        const {colgroup: n, tableWidth: r, tableMinWidth: o} = XR(t, this.options.cellMinWidth)
          , l = e.style;
        function a() {
            return l || (r ? `width: ${r}` : `min-width: ${o}`)
        }
        const u = ["table", We(this.options.HTMLAttributes, e, {
            style: a()
        }), n, ["tbody", 0]];
        return this.options.renderWrapper ? ["div", {
            class: "tableWrapper"
        }, u] : u
    },
    parseMarkdown: (t, e) => {
        const n = [];
        if (t.header) {
            const r = [];
            t.header.forEach(o => {
                r.push(e.createNode("tableHeader", {}, [{
                    type: "paragraph",
                    content: e.parseInline(o.tokens)
                }]))
            }
            ),
            n.push(e.createNode("tableRow", {}, r))
        }
        return t.rows && t.rows.forEach(r => {
            const o = [];
            r.forEach(l => {
                o.push(e.createNode("tableCell", {}, [{
                    type: "paragraph",
                    content: e.parseInline(l.tokens)
                }]))
            }
            ),
            n.push(e.createNode("tableRow", {}, o))
        }
        ),
        e.createNode("table", void 0, n)
    }
    ,
    renderMarkdown: (t, e) => iO(t, e),
    addCommands() {
        return {
            insertTable: ({rows: t=3, cols: e=3, withHeaderRow: n=!0}={}) => ({tr: r, dispatch: o, editor: l}) => {
                const a = QR(l.schema, t, e, n);
                if (o) {
                    const u = r.selection.from + 1;
                    r.replaceSelectionWith(a).scrollIntoView().setSelection(se.near(r.doc.resolve(u)))
                }
                return !0
            }
            ,
            addColumnBefore: () => ({state: t, dispatch: e}) => fR(t, e),
            addColumnAfter: () => ({state: t, dispatch: e}) => dR(t, e),
            deleteColumn: () => ({state: t, dispatch: e}) => pR(t, e),
            addRowBefore: () => ({state: t, dispatch: e}) => gR(t, e),
            addRowAfter: () => ({state: t, dispatch: e}) => yR(t, e),
            deleteRow: () => ({state: t, dispatch: e}) => bR(t, e),
            deleteTable: () => ({state: t, dispatch: e}) => kR(t, e),
            mergeCells: () => ({state: t, dispatch: e}) => yC(t, e),
            splitCell: () => ({state: t, dispatch: e}) => vC(t, e),
            toggleHeaderColumn: () => ({state: t, dispatch: e}) => ba("column")(t, e),
            toggleHeaderRow: () => ({state: t, dispatch: e}) => ba("row")(t, e),
            toggleHeaderCell: () => ({state: t, dispatch: e}) => ER(t, e),
            mergeOrSplit: () => ({state: t, dispatch: e}) => yC(t, e) ? !0 : vC(t, e),
            setCellAttribute: (t, e) => ({state: n, dispatch: r}) => xR(t, e)(n, r),
            goToNextCell: () => ({state: t, dispatch: e}) => CC(1)(t, e),
            goToPreviousCell: () => ({state: t, dispatch: e}) => CC(-1)(t, e),
            fixTables: () => ({state: t, dispatch: e}) => (e && f4(t),
            !0),
            setCellSelection: t => ({tr: e, dispatch: n}) => {
                if (n) {
                    const r = Pe.create(e.doc, t.anchorCell, t.headCell);
                    e.setSelection(r)
                }
                return !0
            }
        }
    },
    addKeyboardShortcuts() {
        return {
            Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
            "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
            Backspace: cu,
            "Mod-Backspace": cu,
            Delete: cu,
            "Mod-Delete": cu
        }
    },
    addProseMirrorPlugins() {
        return [...this.options.resizable && this.editor.isEditable ? [BR({
            handleWidth: this.options.handleWidth,
            cellMinWidth: this.options.cellMinWidth,
            defaultCellMinWidth: this.options.cellMinWidth,
            View: this.options.View,
            lastColumnResizable: this.options.lastColumnResizable
        })] : [], KR({
            allowTableNodeSelection: this.options.allowTableNodeSelection
        })]
    },
    extendNodeSchema(t) {
        const e = {
            name: t.name,
            options: t.options,
            storage: t.storage
        };
        return {
            tableRole: Le(fe(t, "tableRole", e))
        }
    }
})
  , lO = rt.create({
    name: "tableKit",
    addExtensions() {
        const t = [];
        return this.options.table !== !1 && t.push(oO.configure(this.options.table)),
        this.options.tableCell !== !1 && t.push(GR.configure(this.options.tableCell)),
        this.options.tableHeader !== !1 && t.push(YR.configure(this.options.tableHeader)),
        this.options.tableRow !== !1 && t.push(ZR.configure(this.options.tableRow)),
        t
    }
});
const sO = [ZN.configure({
    placeholder: "    "
}), YN.configure({
    heading: {
        levels: [1, 2, 3, 4]
    }
}), rN.configure({
    openOnClick: !1
}), xN, lO.configure({
    table: {
        resizable: !0
    }
})];
function aO(t) {
    return t = t.replace(/<colgroup[\s\S]*?<\/colgroup>/gi, ""),
    t = t.replace(/<(table|thead|tbody|tfoot|tr|td|th)(\s[^>]*?)>/gi, (e, n, r) => (r = r.replace(/\s+(style|width|height)="[^"]*"/gi, ""),
    r = r.replace(/\s+(style|width|height)='[^']*'/gi, ""),
    `<${n}${r}>`)),
    t
}
const cO = {
    mod: "",
    command: "",
    meta: "",
    ctrl: "",
    control: "",
    alt: "",
    option: "",
    shift: "",
    backspace: "Del",
    delete: "",
    enter: "",
    escape: "",
    capslock: ""
};
function It(...t) {
    return t.filter(Boolean).join(" ")
}
function uO() {
    return typeof navigator < "u" && navigator.platform.toLowerCase().includes("mac")
}
const fO = (t, e, n=!0) => {
    if (e) {
        const r = t.toLowerCase();
        return cO[r] || (n ? t.toUpperCase() : t)
    }
    return n ? t.charAt(0).toUpperCase() + t.slice(1) : t
}
  , No = t => {
    const {shortcutKeys: e, delimiter: n="+", capitalize: r=!0} = t;
    return e ? e.split(n).map(o => o.trim()).map(o => fO(o, uO(), r)) : []
}
  , og = (t, e) => e?.schema ? e.schema.spec.marks.get(t) !== void 0 : !1
  , _i = (t, e) => e?.schema ? e.schema.spec.nodes.get(t) !== void 0 : !1;
function ka(t) {
    return typeof t == "number" && t >= 0
}
function dO(t, e) {
    try {
        const n = t.state.doc.nodeAt(e);
        return n || (console.warn(`No node found at position ${e}`),
        null)
    } catch (n) {
        return console.error(`Error getting node at position ${e}:`, n),
        null
    }
}
function $f(t) {
    const {editor: e, node: n, nodePos: r} = t;
    if (!e || !e.state?.doc)
        return null;
    const o = n != null
      , l = ka(r);
    if (!o && !l)
        return null;
    if (o) {
        let a = -1
          , u = null;
        if (e.state.doc.descendants( (f, h) => f === n ? (a = h,
        u = f,
        !1) : !0),
        a !== -1 && u !== null)
            return {
                pos: a,
                node: u
            }
    }
    if (l) {
        const a = dO(e, r);
        if (a)
            return {
                pos: r,
                node: a
            }
    }
    return null
}
function Ro(t, e=[], n=!1) {
    if (!t || !t.state.selection)
        return !1;
    const {selection: r} = t.state;
    if (r.empty)
        return !1;
    if (r instanceof le) {
        const o = r.node;
        return o ? e.includes(o.type.name) : !1
    }
    if (n) {
        const {$from: o} = r;
        for (let l = o.depth; l > 0; l--) {
            const a = o.node(l);
            if (e.includes(a.type.name))
                return !0
        }
    }
    return !1
}
function Bi(t, e=[]) {
    if (!t || e.length === 0)
        return !1;
    const {state: n} = t
      , {selection: r} = n
      , o = new Set(e);
    if (r instanceof le) {
        const l = r.node?.type?.name;
        return !!l && o.has(l)
    }
    if (r instanceof se || r instanceof Zt) {
        let l = !0;
        return n.doc.nodesBetween(r.from, r.to, a => a.isTextblock && !o.has(a.type.name) ? (l = !1,
        !1) : l),
        l
    }
    return !1
}
const hO = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function pO(t, e) {
    const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
    return !t || t.replace(hO, "").match(new RegExp(`^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,"i"))
}
function mO(t, e, n) {
    try {
        const r = new URL(t,e);
        if (pO(r.href, n))
            return r.href
    } catch {}
    return "#"
}
function Ff(t) {
    const {doc: e} = t.state
      , {from: n, to: r} = t.state.selection
      , o = []
      , l = new Set;
    return e.nodesBetween(n, r, (a, u) => {
        if (a.isBlock)
            return l.has(u) || (l.add(u),
            o.push(a)),
            !1
    }
    ),
    o
}
const lg = T.forwardRef( ({decorative: t, orientation: e="vertical", className: n, ...r}, o) => {
    const a = t ? {
        role: "none"
    } : {
        "aria-orientation": e === "vertical" ? e : void 0,
        role: "separator"
    };
    return E.jsx("div", {
        className: It("tiptap-separator", n),
        "data-orientation": e,
        ...a,
        ...r,
        ref: o
    })
}
);
lg.displayName = "Separator";
function gO({editor: t, containerRef: e, query: n, items: r, onSelect: o, onClose: l, orientation: a="vertical", autoSelectFirstItem: u=!0}) {
    const [f,h] = T.useState(u ? 0 : -1);
    return T.useEffect( () => {
        const p = y => {
            if (!r.length)
                return !1;
            const b = () => h(S => S === -1 ? 0 : (S + 1) % r.length)
              , C = () => h(S => S === -1 ? r.length - 1 : (S - 1 + r.length) % r.length);
            switch (y.key) {
            case "ArrowUp":
                return a === "horizontal" ? !1 : (y.preventDefault(),
                C(),
                !0);
            case "ArrowDown":
                return a === "horizontal" ? !1 : (y.preventDefault(),
                b(),
                !0);
            case "ArrowLeft":
                return a === "vertical" ? !1 : (y.preventDefault(),
                C(),
                !0);
            case "ArrowRight":
                return a === "vertical" ? !1 : (y.preventDefault(),
                b(),
                !0);
            case "Tab":
                return y.preventDefault(),
                y.shiftKey ? C() : b(),
                !0;
            case "Home":
                return y.preventDefault(),
                h(0),
                !0;
            case "End":
                return y.preventDefault(),
                h(r.length - 1),
                !0;
            case "Enter":
                return y.isComposing ? !1 : (y.preventDefault(),
                f !== -1 && r[f] && o?.(r[f]),
                !0);
            case "Escape":
                return y.preventDefault(),
                l?.(),
                !0;
            default:
                return !1
            }
        }
        ;
        let m = null;
        if (t ? m = t.view.dom : e?.current && (m = e.current),
        m)
            return m.addEventListener("keydown", p, !0),
            () => {
                m?.removeEventListener("keydown", p, !0)
            }
    }
    , [t, e, r, f, o, l, a]),
    T.useEffect( () => {
        n && h(u ? 0 : -1)
    }
    , [n, u]),
    {
        selectedIndex: r.length ? f : void 0,
        setSelectedIndex: h
    }
}
const RC = (t, e) => {
    typeof t == "function" ? t(e) : t && typeof t == "object" && "current"in t && (t.current = e)
}
  , yO = (t, e) => {
    const n = T.useRef(null);
    return T.useCallback(r => {
        t && "current"in t && (t.current = r),
        n.current && RC(n.current, null),
        n.current = e,
        e && RC(e, r)
    }
    , [t, e])
}
  , vO = t => {
    const [e,n] = T.useState([])
      , r = T.useCallback( () => t.current ? Array.from(t.current.querySelectorAll('button:not([disabled]), [role="button"]:not([disabled]), [tabindex="0"]:not([disabled])')) : [], [t]);
    T.useEffect( () => {
        const l = t.current;
        if (!l)
            return;
        const a = () => n(r());
        a();
        const u = new MutationObserver(a);
        return u.observe(l, {
            childList: !0,
            subtree: !0
        }),
        () => u.disconnect()
    }
    , [r, t]);
    const {selectedIndex: o} = gO({
        containerRef: t,
        items: e,
        orientation: "horizontal",
        onSelect: l => l.click(),
        autoSelectFirstItem: !1
    });
    T.useEffect( () => {
        const l = t.current;
        if (!l)
            return;
        const a = f => {
            const h = f.target;
            l.contains(h) && h.setAttribute("data-focus-visible", "true")
        }
          , u = f => {
            const h = f.target;
            l.contains(h) && h.removeAttribute("data-focus-visible")
        }
        ;
        return l.addEventListener("focus", a, !0),
        l.addEventListener("blur", u, !0),
        () => {
            l.removeEventListener("focus", a, !0),
            l.removeEventListener("blur", u, !0)
        }
    }
    , [t]),
    T.useEffect( () => {
        o !== void 0 && e[o] && e[o].focus()
    }
    , [o, e])
}
  , g4 = T.forwardRef( ({children: t, className: e, variant: n="fixed", ...r}, o) => {
    const l = T.useRef(null)
      , a = yO(l, o);
    return vO(l),
    E.jsx("div", {
        ref: a,
        role: "toolbar",
        "aria-label": "toolbar",
        "data-variant": n,
        className: It("tiptap-toolbar", e),
        ...r,
        children: t
    })
}
);
g4.displayName = "Toolbar";
const lo = T.forwardRef( ({children: t, className: e, ...n}, r) => E.jsx("div", {
    ref: r,
    role: "group",
    className: It("tiptap-toolbar-group", e),
    ...n,
    children: t
}));
lo.displayName = "ToolbarGroup";
const Zs = T.forwardRef( ({...t}, e) => E.jsx(lg, {
    ref: e,
    orientation: "vertical",
    decorative: !0,
    ...t
}));
Zs.displayName = "ToolbarSeparator";
function Kf() {
    return typeof window < "u"
}
function Pl(t) {
    return sg(t) ? (t.nodeName || "").toLowerCase() : "#document"
}
function Xt(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function Qn(t) {
    var e;
    return (e = (sg(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}
function sg(t) {
    return Kf() ? t instanceof Node || t instanceof Xt(t).Node : !1
}
function Ge(t) {
    return Kf() ? t instanceof Element || t instanceof Xt(t).Element : !1
}
function dn(t) {
    return Kf() ? t instanceof HTMLElement || t instanceof Xt(t).HTMLElement : !1
}
function Qm(t) {
    return !Kf() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Xt(t).ShadowRoot
}
const bO = new Set(["inline", "contents"]);
function Ma(t) {
    const {overflow: e, overflowX: n, overflowY: r, display: o} = Rn(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !bO.has(o)
}
const CO = new Set(["table", "td", "th"]);
function SO(t) {
    return CO.has(Pl(t))
}
const xO = [":popover-open", ":modal"];
function Gf(t) {
    return xO.some(e => {
        try {
            return t.matches(e)
        } catch {
            return !1
        }
    }
    )
}
const wO = ["transform", "translate", "scale", "rotate", "perspective"]
  , EO = ["transform", "translate", "scale", "rotate", "perspective", "filter"]
  , TO = ["paint", "layout", "strict", "content"];
function ag(t) {
    const e = Yf()
      , n = Ge(t) ? Rn(t) : t;
    return wO.some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || EO.some(r => (n.willChange || "").includes(r)) || TO.some(r => (n.contain || "").includes(r))
}
function kO(t) {
    let e = Or(t);
    for (; dn(e) && !Rr(e); ) {
        if (ag(e))
            return e;
        if (Gf(e))
            return null;
        e = Or(e)
    }
    return null
}
function Yf() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
const MO = new Set(["html", "body", "#document"]);
function Rr(t) {
    return MO.has(Pl(t))
}
function Rn(t) {
    return Xt(t).getComputedStyle(t)
}
function Zf(t) {
    return Ge(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.scrollX,
        scrollTop: t.scrollY
    }
}
function Or(t) {
    if (Pl(t) === "html")
        return t;
    const e = t.assignedSlot || t.parentNode || Qm(t) && t.host || Qn(t);
    return Qm(e) ? e.host : e
}
function y4(t) {
    const e = Or(t);
    return Rr(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : dn(e) && Ma(e) ? e : y4(e)
}
function Ti(t, e, n) {
    var r;
    e === void 0 && (e = []),
    n === void 0 && (n = !0);
    const o = y4(t)
      , l = o === ((r = t.ownerDocument) == null ? void 0 : r.body)
      , a = Xt(o);
    if (l) {
        const u = e1(a);
        return e.concat(a, a.visualViewport || [], Ma(o) ? o : [], u && n ? Ti(u) : [])
    }
    return e.concat(o, Ti(o, [], n))
}
function e1(t) {
    return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
}
const AO = ["top", "right", "bottom", "left"]
  , Ri = Math.min
  , cn = Math.max
  , bf = Math.round
  , uu = Math.floor
  , Zn = t => ({
    x: t,
    y: t
})
  , NO = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , RO = {
    start: "end",
    end: "start"
};
function t1(t, e, n) {
    return cn(t, Ri(e, n))
}
function Dr(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Lr(t) {
    return t.split("-")[0]
}
function ql(t) {
    return t.split("-")[1]
}
function cg(t) {
    return t === "x" ? "y" : "x"
}
function ug(t) {
    return t === "y" ? "height" : "width"
}
const OO = new Set(["top", "bottom"]);
function Gn(t) {
    return OO.has(Lr(t)) ? "y" : "x"
}
function fg(t) {
    return cg(Gn(t))
}
function DO(t, e, n) {
    n === void 0 && (n = !1);
    const r = ql(t)
      , o = fg(t)
      , l = ug(o);
    let a = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return e.reference[l] > e.floating[l] && (a = Cf(a)),
    [a, Cf(a)]
}
function LO(t) {
    const e = Cf(t);
    return [n1(t), e, n1(e)]
}
function n1(t) {
    return t.replace(/start|end/g, e => RO[e])
}
const OC = ["left", "right"]
  , DC = ["right", "left"]
  , zO = ["top", "bottom"]
  , _O = ["bottom", "top"];
function BO(t, e, n) {
    switch (t) {
    case "top":
    case "bottom":
        return n ? e ? DC : OC : e ? OC : DC;
    case "left":
    case "right":
        return e ? zO : _O;
    default:
        return []
    }
}
function jO(t, e, n, r) {
    const o = ql(t);
    let l = BO(Lr(t), n === "start", r);
    return o && (l = l.map(a => a + "-" + o),
    e && (l = l.concat(l.map(n1)))),
    l
}
function Cf(t) {
    return t.replace(/left|right|bottom|top/g, e => NO[e])
}
function HO(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}
function v4(t) {
    return typeof t != "number" ? HO(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}
function Sf(t) {
    const {x: e, y: n, width: r, height: o} = t;
    return {
        width: r,
        height: o,
        top: n,
        left: e,
        right: e + r,
        bottom: n + o,
        x: e,
        y: n
    }
}
var IO = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"]
  , r1 = IO.join(",")
  , b4 = typeof Element > "u"
  , Ca = b4 ? function() {}
: Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector
  , xf = !b4 && Element.prototype.getRootNode ? function(t) {
    var e;
    return t == null || (e = t.getRootNode) === null || e === void 0 ? void 0 : e.call(t)
}
: function(t) {
    return t?.ownerDocument
}
  , wf = function(e, n) {
    var r;
    n === void 0 && (n = !0);
    var o = e == null || (r = e.getAttribute) === null || r === void 0 ? void 0 : r.call(e, "inert")
      , l = o === "" || o === "true"
      , a = l || n && e && (typeof e.closest == "function" ? e.closest("[inert]") : wf(e.parentNode));
    return a
}
  , VO = function(e) {
    var n, r = e == null || (n = e.getAttribute) === null || n === void 0 ? void 0 : n.call(e, "contenteditable");
    return r === "" || r === "true"
}
  , UO = function(e, n, r) {
    if (wf(e))
        return [];
    var o = Array.prototype.slice.apply(e.querySelectorAll(r1));
    return n && Ca.call(e, r1) && o.unshift(e),
    o = o.filter(r),
    o
}
  , i1 = function(e, n, r) {
    for (var o = [], l = Array.from(e); l.length; ) {
        var a = l.shift();
        if (!wf(a, !1))
            if (a.tagName === "SLOT") {
                var u = a.assignedElements()
                  , f = u.length ? u : a.children
                  , h = i1(f, !0, r);
                r.flatten ? o.push.apply(o, h) : o.push({
                    scopeParent: a,
                    candidates: h
                })
            } else {
                var p = Ca.call(a, r1);
                p && r.filter(a) && (n || !e.includes(a)) && o.push(a);
                var m = a.shadowRoot || typeof r.getShadowRoot == "function" && r.getShadowRoot(a)
                  , y = !wf(m, !1) && (!r.shadowRootFilter || r.shadowRootFilter(a));
                if (m && y) {
                    var b = i1(m === !0 ? a.children : m.children, !0, r);
                    r.flatten ? o.push.apply(o, b) : o.push({
                        scopeParent: a,
                        candidates: b
                    })
                } else
                    l.unshift.apply(l, a.children)
            }
    }
    return o
}
  , C4 = function(e) {
    return !isNaN(parseInt(e.getAttribute("tabindex"), 10))
}
  , S4 = function(e) {
    if (!e)
        throw new Error("No node provided");
    return e.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || VO(e)) && !C4(e) ? 0 : e.tabIndex
}
  , PO = function(e, n) {
    var r = S4(e);
    return r < 0 && n && !C4(e) ? 0 : r
}
  , qO = function(e, n) {
    return e.tabIndex === n.tabIndex ? e.documentOrder - n.documentOrder : e.tabIndex - n.tabIndex
}
  , x4 = function(e) {
    return e.tagName === "INPUT"
}
  , $O = function(e) {
    return x4(e) && e.type === "hidden"
}
  , FO = function(e) {
    var n = e.tagName === "DETAILS" && Array.prototype.slice.apply(e.children).some(function(r) {
        return r.tagName === "SUMMARY"
    });
    return n
}
  , KO = function(e, n) {
    for (var r = 0; r < e.length; r++)
        if (e[r].checked && e[r].form === n)
            return e[r]
}
  , GO = function(e) {
    if (!e.name)
        return !0;
    var n = e.form || xf(e), r = function(u) {
        return n.querySelectorAll('input[type="radio"][name="' + u + '"]')
    }, o;
    if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
        o = r(window.CSS.escape(e.name));
    else
        try {
            o = r(e.name)
        } catch (a) {
            return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", a.message),
            !1
        }
    var l = KO(o, e.form);
    return !l || l === e
}
  , YO = function(e) {
    return x4(e) && e.type === "radio"
}
  , ZO = function(e) {
    return YO(e) && !GO(e)
}
  , WO = function(e) {
    var n, r = e && xf(e), o = (n = r) === null || n === void 0 ? void 0 : n.host, l = !1;
    if (r && r !== e) {
        var a, u, f;
        for (l = !!((a = o) !== null && a !== void 0 && (u = a.ownerDocument) !== null && u !== void 0 && u.contains(o) || e != null && (f = e.ownerDocument) !== null && f !== void 0 && f.contains(e)); !l && o; ) {
            var h, p, m;
            r = xf(o),
            o = (h = r) === null || h === void 0 ? void 0 : h.host,
            l = !!((p = o) !== null && p !== void 0 && (m = p.ownerDocument) !== null && m !== void 0 && m.contains(o))
        }
    }
    return l
}
  , LC = function(e) {
    var n = e.getBoundingClientRect()
      , r = n.width
      , o = n.height;
    return r === 0 && o === 0
}
  , XO = function(e, n) {
    var r = n.displayCheck
      , o = n.getShadowRoot;
    if (r === "full-native" && "checkVisibility"in e) {
        var l = e.checkVisibility({
            checkOpacity: !1,
            opacityProperty: !1,
            contentVisibilityAuto: !0,
            visibilityProperty: !0,
            checkVisibilityCSS: !0
        });
        return !l
    }
    if (getComputedStyle(e).visibility === "hidden")
        return !0;
    var a = Ca.call(e, "details>summary:first-of-type")
      , u = a ? e.parentElement : e;
    if (Ca.call(u, "details:not([open]) *"))
        return !0;
    if (!r || r === "full" || r === "full-native" || r === "legacy-full") {
        if (typeof o == "function") {
            for (var f = e; e; ) {
                var h = e.parentElement
                  , p = xf(e);
                if (h && !h.shadowRoot && o(h) === !0)
                    return LC(e);
                e.assignedSlot ? e = e.assignedSlot : !h && p !== e.ownerDocument ? e = p.host : e = h
            }
            e = f
        }
        if (WO(e))
            return !e.getClientRects().length;
        if (r !== "legacy-full")
            return !0
    } else if (r === "non-zero-area")
        return LC(e);
    return !1
}
  , JO = function(e) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
        for (var n = e.parentElement; n; ) {
            if (n.tagName === "FIELDSET" && n.disabled) {
                for (var r = 0; r < n.children.length; r++) {
                    var o = n.children.item(r);
                    if (o.tagName === "LEGEND")
                        return Ca.call(n, "fieldset[disabled] *") ? !0 : !o.contains(e)
                }
                return !0
            }
            n = n.parentElement
        }
    return !1
}
  , QO = function(e, n) {
    return !(n.disabled || $O(n) || XO(n, e) || FO(n) || JO(n))
}
  , zC = function(e, n) {
    return !(ZO(n) || S4(n) < 0 || !QO(e, n))
}
  , eD = function(e) {
    var n = parseInt(e.getAttribute("tabindex"), 10);
    return !!(isNaN(n) || n >= 0)
}
  , w4 = function(e) {
    var n = []
      , r = [];
    return e.forEach(function(o, l) {
        var a = !!o.scopeParent
          , u = a ? o.scopeParent : o
          , f = PO(u, a)
          , h = a ? w4(o.candidates) : u;
        f === 0 ? a ? n.push.apply(n, h) : n.push(u) : r.push({
            documentOrder: l,
            tabIndex: f,
            item: o,
            isScope: a,
            content: h
        })
    }),
    r.sort(qO).reduce(function(o, l) {
        return l.isScope ? o.push.apply(o, l.content) : o.push(l.content),
        o
    }, []).concat(n)
}
  , E4 = function(e, n) {
    n = n || {};
    var r;
    return n.getShadowRoot ? r = i1([e], n.includeContainer, {
        filter: zC.bind(null, n),
        flatten: !1,
        getShadowRoot: n.getShadowRoot,
        shadowRootFilter: eD
    }) : r = UO(e, n.includeContainer, zC.bind(null, n)),
    w4(r)
};
function tD() {
    const t = navigator.userAgentData;
    return t != null && t.platform ? t.platform : navigator.platform
}
function nD() {
    const t = navigator.userAgentData;
    return t && Array.isArray(t.brands) ? t.brands.map(e => {
        let {brand: n, version: r} = e;
        return n + "/" + r
    }
    ).join(" ") : navigator.userAgent
}
function T4() {
    return /apple/i.test(navigator.vendor)
}
function rD() {
    return tD().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints
}
function iD() {
    return nD().includes("jsdom/")
}
const _C = "data-floating-ui-focusable"
  , oD = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function o1(t) {
    let e = t.activeElement;
    for (; ((n = e) == null || (n = n.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
        var n;
        e = e.shadowRoot.activeElement
    }
    return e
}
function Hl(t, e) {
    if (!t || !e)
        return !1;
    const n = e.getRootNode == null ? void 0 : e.getRootNode();
    if (t.contains(e))
        return !0;
    if (n && Qm(n)) {
        let r = e;
        for (; r; ) {
            if (t === r)
                return !0;
            r = r.parentNode || r.host
        }
    }
    return !1
}
function El(t) {
    return "composedPath"in t ? t.composedPath()[0] : t.target
}
function em(t, e) {
    if (e == null)
        return !1;
    if ("composedPath"in t)
        return t.composedPath().includes(e);
    const n = t;
    return n.target != null && e.contains(n.target)
}
function lD(t) {
    return t.matches("html,body")
}
function Yn(t) {
    return t?.ownerDocument || document
}
function sD(t) {
    return dn(t) && t.matches(oD)
}
function aD(t) {
    if (!t || iD())
        return !0;
    try {
        return t.matches(":focus-visible")
    } catch {
        return !0
    }
}
function cD(t) {
    return t ? t.hasAttribute(_C) ? t : t.querySelector("[" + _C + "]") || t : null
}
function Eu(t, e, n) {
    return n === void 0 && (n = !0),
    t.filter(o => {
        var l;
        return o.parentId === e && (!n || ((l = o.context) == null ? void 0 : l.open))
    }
    ).flatMap(o => [o, ...Eu(t, o.id, n)])
}
function uD(t) {
    return "nativeEvent"in t
}
function l1(t, e) {
    const n = ["mouse", "pen"];
    return n.push("", void 0),
    n.includes(t)
}
var fD = typeof document < "u"
  , dD = function() {}
  , Bn = fD ? T.useLayoutEffect : dD;
const hD = {
    ...kf
};
function fu(t) {
    const e = T.useRef(t);
    return Bn( () => {
        e.current = t
    }
    ),
    e
}
const pD = hD.useInsertionEffect
  , mD = pD || (t => t());
function Fn(t) {
    const e = T.useRef( () => {}
    );
    return mD( () => {
        e.current = t
    }
    ),
    T.useCallback(function() {
        for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
            r[o] = arguments[o];
        return e.current == null ? void 0 : e.current(...r)
    }, [])
}
const k4 = () => ({
    getShadowRoot: !0,
    displayCheck: typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
});
function M4(t, e) {
    const n = E4(t, k4())
      , r = n.length;
    if (r === 0)
        return;
    const o = o1(Yn(t))
      , l = n.indexOf(o)
      , a = l === -1 ? e === 1 ? 0 : r - 1 : l + e;
    return n[a]
}
function gD(t) {
    return M4(Yn(t).body, 1) || t
}
function yD(t) {
    return M4(Yn(t).body, -1) || t
}
function tm(t, e) {
    const n = e || t.currentTarget
      , r = t.relatedTarget;
    return !r || !Hl(n, r)
}
function vD(t) {
    E4(t, k4()).forEach(n => {
        n.dataset.tabindex = n.getAttribute("tabindex") || "",
        n.setAttribute("tabindex", "-1")
    }
    )
}
function BC(t) {
    t.querySelectorAll("[data-tabindex]").forEach(n => {
        const r = n.dataset.tabindex;
        delete n.dataset.tabindex,
        r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex")
    }
    )
}
function jC(t, e, n) {
    let {reference: r, floating: o} = t;
    const l = Gn(e)
      , a = fg(e)
      , u = ug(a)
      , f = Lr(e)
      , h = l === "y"
      , p = r.x + r.width / 2 - o.width / 2
      , m = r.y + r.height / 2 - o.height / 2
      , y = r[u] / 2 - o[u] / 2;
    let b;
    switch (f) {
    case "top":
        b = {
            x: p,
            y: r.y - o.height
        };
        break;
    case "bottom":
        b = {
            x: p,
            y: r.y + r.height
        };
        break;
    case "right":
        b = {
            x: r.x + r.width,
            y: m
        };
        break;
    case "left":
        b = {
            x: r.x - o.width,
            y: m
        };
        break;
    default:
        b = {
            x: r.x,
            y: r.y
        }
    }
    switch (ql(e)) {
    case "start":
        b[a] -= y * (n && h ? -1 : 1);
        break;
    case "end":
        b[a] += y * (n && h ? -1 : 1);
        break
    }
    return b
}
async function bD(t, e) {
    var n;
    e === void 0 && (e = {});
    const {x: r, y: o, platform: l, rects: a, elements: u, strategy: f} = t
      , {boundary: h="clippingAncestors", rootBoundary: p="viewport", elementContext: m="floating", altBoundary: y=!1, padding: b=0} = Dr(e, t)
      , C = v4(b)
      , w = u[y ? m === "floating" ? "reference" : "floating" : m]
      , k = Sf(await l.getClippingRect({
        element: (n = await (l.isElement == null ? void 0 : l.isElement(w))) == null || n ? w : w.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(u.floating)),
        boundary: h,
        rootBoundary: p,
        strategy: f
    }))
      , A = m === "floating" ? {
        x: r,
        y: o,
        width: a.floating.width,
        height: a.floating.height
    } : a.reference
      , O = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(u.floating))
      , B = await (l.isElement == null ? void 0 : l.isElement(O)) ? await (l.getScale == null ? void 0 : l.getScale(O)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , z = Sf(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: u,
        rect: A,
        offsetParent: O,
        strategy: f
    }) : A);
    return {
        top: (k.top - z.top + C.top) / B.y,
        bottom: (z.bottom - k.bottom + C.bottom) / B.y,
        left: (k.left - z.left + C.left) / B.x,
        right: (z.right - k.right + C.right) / B.x
    }
}
const CD = async (t, e, n) => {
    const {placement: r="bottom", strategy: o="absolute", middleware: l=[], platform: a} = n
      , u = l.filter(Boolean)
      , f = await (a.isRTL == null ? void 0 : a.isRTL(e));
    let h = await a.getElementRects({
        reference: t,
        floating: e,
        strategy: o
    })
      , {x: p, y: m} = jC(h, r, f)
      , y = r
      , b = {}
      , C = 0;
    for (let w = 0; w < u.length; w++) {
        var S;
        const {name: k, fn: A} = u[w]
          , {x: O, y: B, data: z, reset: $} = await A({
            x: p,
            y: m,
            initialPlacement: r,
            placement: y,
            strategy: o,
            middlewareData: b,
            rects: h,
            platform: {
                ...a,
                detectOverflow: (S = a.detectOverflow) != null ? S : bD
            },
            elements: {
                reference: t,
                floating: e
            }
        });
        p = O ?? p,
        m = B ?? m,
        b = {
            ...b,
            [k]: {
                ...b[k],
                ...z
            }
        },
        $ && C <= 50 && (C++,
        typeof $ == "object" && ($.placement && (y = $.placement),
        $.rects && (h = $.rects === !0 ? await a.getElementRects({
            reference: t,
            floating: e,
            strategy: o
        }) : $.rects),
        {x: p, y: m} = jC(h, y, f)),
        w = -1)
    }
    return {
        x: p,
        y: m,
        placement: y,
        strategy: o,
        middlewareData: b
    }
}
  , SD = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
        const {x: n, y: r, placement: o, rects: l, platform: a, elements: u, middlewareData: f} = e
          , {element: h, padding: p=0} = Dr(t, e) || {};
        if (h == null)
            return {};
        const m = v4(p)
          , y = {
            x: n,
            y: r
        }
          , b = fg(o)
          , C = ug(b)
          , S = await a.getDimensions(h)
          , w = b === "y"
          , k = w ? "top" : "left"
          , A = w ? "bottom" : "right"
          , O = w ? "clientHeight" : "clientWidth"
          , B = l.reference[C] + l.reference[b] - y[b] - l.floating[C]
          , z = y[b] - l.reference[b]
          , $ = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(h));
        let _ = $ ? $[O] : 0;
        (!_ || !await (a.isElement == null ? void 0 : a.isElement($))) && (_ = u.floating[O] || l.floating[C]);
        const W = B / 2 - z / 2
          , ne = _ / 2 - S[C] / 2 - 1
          , de = Ri(m[k], ne)
          , ve = Ri(m[A], ne)
          , pe = de
          , be = _ - S[C] - ve
          , Q = _ / 2 - S[C] / 2 + W
          , ae = t1(pe, Q, be)
          , j = !f.arrow && ql(o) != null && Q !== ae && l.reference[C] / 2 - (Q < pe ? de : ve) - S[C] / 2 < 0
          , P = j ? Q < pe ? Q - pe : Q - be : 0;
        return {
            [b]: y[b] + P,
            data: {
                [b]: ae,
                centerOffset: Q - ae - P,
                ...j && {
                    alignmentOffset: P
                }
            },
            reset: j
        }
    }
})
  , xD = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "flip",
        options: t,
        async fn(e) {
            var n, r;
            const {placement: o, middlewareData: l, rects: a, initialPlacement: u, platform: f, elements: h} = e
              , {mainAxis: p=!0, crossAxis: m=!0, fallbackPlacements: y, fallbackStrategy: b="bestFit", fallbackAxisSideDirection: C="none", flipAlignment: S=!0, ...w} = Dr(t, e);
            if ((n = l.arrow) != null && n.alignmentOffset)
                return {};
            const k = Lr(o)
              , A = Gn(u)
              , O = Lr(u) === u
              , B = await (f.isRTL == null ? void 0 : f.isRTL(h.floating))
              , z = y || (O || !S ? [Cf(u)] : LO(u))
              , $ = C !== "none";
            !y && $ && z.push(...jO(u, S, C, B));
            const _ = [u, ...z]
              , W = await f.detectOverflow(e, w)
              , ne = [];
            let de = ((r = l.flip) == null ? void 0 : r.overflows) || [];
            if (p && ne.push(W[k]),
            m) {
                const Q = DO(o, a, B);
                ne.push(W[Q[0]], W[Q[1]])
            }
            if (de = [...de, {
                placement: o,
                overflows: ne
            }],
            !ne.every(Q => Q <= 0)) {
                var ve, pe;
                const Q = (((ve = l.flip) == null ? void 0 : ve.index) || 0) + 1
                  , ae = _[Q];
                if (ae && (!(m === "alignment" ? A !== Gn(ae) : !1) || de.every(q => Gn(q.placement) === A ? q.overflows[0] > 0 : !0)))
                    return {
                        data: {
                            index: Q,
                            overflows: de
                        },
                        reset: {
                            placement: ae
                        }
                    };
                let j = (pe = de.filter(P => P.overflows[0] <= 0).sort( (P, q) => P.overflows[1] - q.overflows[1])[0]) == null ? void 0 : pe.placement;
                if (!j)
                    switch (b) {
                    case "bestFit":
                        {
                            var be;
                            const P = (be = de.filter(q => {
                                if ($) {
                                    const ee = Gn(q.placement);
                                    return ee === A || ee === "y"
                                }
                                return !0
                            }
                            ).map(q => [q.placement, q.overflows.filter(ee => ee > 0).reduce( (ee, ie) => ee + ie, 0)]).sort( (q, ee) => q[1] - ee[1])[0]) == null ? void 0 : be[0];
                            P && (j = P);
                            break
                        }
                    case "initialPlacement":
                        j = u;
                        break
                    }
                if (o !== j)
                    return {
                        reset: {
                            placement: j
                        }
                    }
            }
            return {}
        }
    }
};
function HC(t, e) {
    return {
        top: t.top - e.height,
        right: t.right - e.width,
        bottom: t.bottom - e.height,
        left: t.left - e.width
    }
}
function IC(t) {
    return AO.some(e => t[e] >= 0)
}
const wD = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "hide",
        options: t,
        async fn(e) {
            const {rects: n, platform: r} = e
              , {strategy: o="referenceHidden", ...l} = Dr(t, e);
            switch (o) {
            case "referenceHidden":
                {
                    const a = await r.detectOverflow(e, {
                        ...l,
                        elementContext: "reference"
                    })
                      , u = HC(a, n.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: u,
                            referenceHidden: IC(u)
                        }
                    }
                }
            case "escaped":
                {
                    const a = await r.detectOverflow(e, {
                        ...l,
                        altBoundary: !0
                    })
                      , u = HC(a, n.floating);
                    return {
                        data: {
                            escapedOffsets: u,
                            escaped: IC(u)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
}
  , A4 = new Set(["left", "top"]);
async function ED(t, e) {
    const {placement: n, platform: r, elements: o} = t
      , l = await (r.isRTL == null ? void 0 : r.isRTL(o.floating))
      , a = Lr(n)
      , u = ql(n)
      , f = Gn(n) === "y"
      , h = A4.has(a) ? -1 : 1
      , p = l && f ? -1 : 1
      , m = Dr(e, t);
    let {mainAxis: y, crossAxis: b, alignmentAxis: C} = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: m.mainAxis || 0,
        crossAxis: m.crossAxis || 0,
        alignmentAxis: m.alignmentAxis
    };
    return u && typeof C == "number" && (b = u === "end" ? C * -1 : C),
    f ? {
        x: b * p,
        y: y * h
    } : {
        x: y * h,
        y: b * p
    }
}
const TD = function(t) {
    return t === void 0 && (t = 0),
    {
        name: "offset",
        options: t,
        async fn(e) {
            var n, r;
            const {x: o, y: l, placement: a, middlewareData: u} = e
              , f = await ED(e, t);
            return a === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
                x: o + f.x,
                y: l + f.y,
                data: {
                    ...f,
                    placement: a
                }
            }
        }
    }
}
  , kD = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "shift",
        options: t,
        async fn(e) {
            const {x: n, y: r, placement: o, platform: l} = e
              , {mainAxis: a=!0, crossAxis: u=!1, limiter: f={
                fn: k => {
                    let {x: A, y: O} = k;
                    return {
                        x: A,
                        y: O
                    }
                }
            }, ...h} = Dr(t, e)
              , p = {
                x: n,
                y: r
            }
              , m = await l.detectOverflow(e, h)
              , y = Gn(Lr(o))
              , b = cg(y);
            let C = p[b]
              , S = p[y];
            if (a) {
                const k = b === "y" ? "top" : "left"
                  , A = b === "y" ? "bottom" : "right"
                  , O = C + m[k]
                  , B = C - m[A];
                C = t1(O, C, B)
            }
            if (u) {
                const k = y === "y" ? "top" : "left"
                  , A = y === "y" ? "bottom" : "right"
                  , O = S + m[k]
                  , B = S - m[A];
                S = t1(O, S, B)
            }
            const w = f.fn({
                ...e,
                [b]: C,
                [y]: S
            });
            return {
                ...w,
                data: {
                    x: w.x - n,
                    y: w.y - r,
                    enabled: {
                        [b]: a,
                        [y]: u
                    }
                }
            }
        }
    }
}
  , MD = function(t) {
    return t === void 0 && (t = {}),
    {
        options: t,
        fn(e) {
            const {x: n, y: r, placement: o, rects: l, middlewareData: a} = e
              , {offset: u=0, mainAxis: f=!0, crossAxis: h=!0} = Dr(t, e)
              , p = {
                x: n,
                y: r
            }
              , m = Gn(o)
              , y = cg(m);
            let b = p[y]
              , C = p[m];
            const S = Dr(u, e)
              , w = typeof S == "number" ? {
                mainAxis: S,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...S
            };
            if (f) {
                const O = y === "y" ? "height" : "width"
                  , B = l.reference[y] - l.floating[O] + w.mainAxis
                  , z = l.reference[y] + l.reference[O] - w.mainAxis;
                b < B ? b = B : b > z && (b = z)
            }
            if (h) {
                var k, A;
                const O = y === "y" ? "width" : "height"
                  , B = A4.has(Lr(o))
                  , z = l.reference[m] - l.floating[O] + (B && ((k = a.offset) == null ? void 0 : k[m]) || 0) + (B ? 0 : w.crossAxis)
                  , $ = l.reference[m] + l.reference[O] + (B ? 0 : ((A = a.offset) == null ? void 0 : A[m]) || 0) - (B ? w.crossAxis : 0);
                C < z ? C = z : C > $ && (C = $)
            }
            return {
                [y]: b,
                [m]: C
            }
        }
    }
}
  , AD = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "size",
        options: t,
        async fn(e) {
            var n, r;
            const {placement: o, rects: l, platform: a, elements: u} = e
              , {apply: f= () => {}
            , ...h} = Dr(t, e)
              , p = await a.detectOverflow(e, h)
              , m = Lr(o)
              , y = ql(o)
              , b = Gn(o) === "y"
              , {width: C, height: S} = l.floating;
            let w, k;
            m === "top" || m === "bottom" ? (w = m,
            k = y === (await (a.isRTL == null ? void 0 : a.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (k = m,
            w = y === "end" ? "top" : "bottom");
            const A = S - p.top - p.bottom
              , O = C - p.left - p.right
              , B = Ri(S - p[w], A)
              , z = Ri(C - p[k], O)
              , $ = !e.middlewareData.shift;
            let _ = B
              , W = z;
            if ((n = e.middlewareData.shift) != null && n.enabled.x && (W = O),
            (r = e.middlewareData.shift) != null && r.enabled.y && (_ = A),
            $ && !y) {
                const de = cn(p.left, 0)
                  , ve = cn(p.right, 0)
                  , pe = cn(p.top, 0)
                  , be = cn(p.bottom, 0);
                b ? W = C - 2 * (de !== 0 || ve !== 0 ? de + ve : cn(p.left, p.right)) : _ = S - 2 * (pe !== 0 || be !== 0 ? pe + be : cn(p.top, p.bottom))
            }
            await f({
                ...e,
                availableWidth: W,
                availableHeight: _
            });
            const ne = await a.getDimensions(u.floating);
            return C !== ne.width || S !== ne.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function N4(t) {
    const e = Rn(t);
    let n = parseFloat(e.width) || 0
      , r = parseFloat(e.height) || 0;
    const o = dn(t)
      , l = o ? t.offsetWidth : n
      , a = o ? t.offsetHeight : r
      , u = bf(n) !== l || bf(r) !== a;
    return u && (n = l,
    r = a),
    {
        width: n,
        height: r,
        $: u
    }
}
function dg(t) {
    return Ge(t) ? t : t.contextElement
}
function Nl(t) {
    const e = dg(t);
    if (!dn(e))
        return Zn(1);
    const n = e.getBoundingClientRect()
      , {width: r, height: o, $: l} = N4(e);
    let a = (l ? bf(n.width) : n.width) / r
      , u = (l ? bf(n.height) : n.height) / o;
    return (!a || !Number.isFinite(a)) && (a = 1),
    (!u || !Number.isFinite(u)) && (u = 1),
    {
        x: a,
        y: u
    }
}
const ND = Zn(0);
function R4(t) {
    const e = Xt(t);
    return !Yf() || !e.visualViewport ? ND : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function RD(t, e, n) {
    return e === void 0 && (e = !1),
    !n || e && n !== Xt(t) ? !1 : e
}
function To(t, e, n, r) {
    e === void 0 && (e = !1),
    n === void 0 && (n = !1);
    const o = t.getBoundingClientRect()
      , l = dg(t);
    let a = Zn(1);
    e && (r ? Ge(r) && (a = Nl(r)) : a = Nl(t));
    const u = RD(l, n, r) ? R4(l) : Zn(0);
    let f = (o.left + u.x) / a.x
      , h = (o.top + u.y) / a.y
      , p = o.width / a.x
      , m = o.height / a.y;
    if (l) {
        const y = Xt(l)
          , b = r && Ge(r) ? Xt(r) : r;
        let C = y
          , S = e1(C);
        for (; S && r && b !== C; ) {
            const w = Nl(S)
              , k = S.getBoundingClientRect()
              , A = Rn(S)
              , O = k.left + (S.clientLeft + parseFloat(A.paddingLeft)) * w.x
              , B = k.top + (S.clientTop + parseFloat(A.paddingTop)) * w.y;
            f *= w.x,
            h *= w.y,
            p *= w.x,
            m *= w.y,
            f += O,
            h += B,
            C = Xt(S),
            S = e1(C)
        }
    }
    return Sf({
        width: p,
        height: m,
        x: f,
        y: h
    })
}
function Wf(t, e) {
    const n = Zf(t).scrollLeft;
    return e ? e.left + n : To(Qn(t)).left + n
}
function O4(t, e) {
    const n = t.getBoundingClientRect()
      , r = n.left + e.scrollLeft - Wf(t, n)
      , o = n.top + e.scrollTop;
    return {
        x: r,
        y: o
    }
}
function OD(t) {
    let {elements: e, rect: n, offsetParent: r, strategy: o} = t;
    const l = o === "fixed"
      , a = Qn(r)
      , u = e ? Gf(e.floating) : !1;
    if (r === a || u && l)
        return n;
    let f = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , h = Zn(1);
    const p = Zn(0)
      , m = dn(r);
    if ((m || !m && !l) && ((Pl(r) !== "body" || Ma(a)) && (f = Zf(r)),
    dn(r))) {
        const b = To(r);
        h = Nl(r),
        p.x = b.x + r.clientLeft,
        p.y = b.y + r.clientTop
    }
    const y = a && !m && !l ? O4(a, f) : Zn(0);
    return {
        width: n.width * h.x,
        height: n.height * h.y,
        x: n.x * h.x - f.scrollLeft * h.x + p.x + y.x,
        y: n.y * h.y - f.scrollTop * h.y + p.y + y.y
    }
}
function DD(t) {
    return Array.from(t.getClientRects())
}
function LD(t) {
    const e = Qn(t)
      , n = Zf(t)
      , r = t.ownerDocument.body
      , o = cn(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth)
      , l = cn(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
    let a = -n.scrollLeft + Wf(t);
    const u = -n.scrollTop;
    return Rn(r).direction === "rtl" && (a += cn(e.clientWidth, r.clientWidth) - o),
    {
        width: o,
        height: l,
        x: a,
        y: u
    }
}
const VC = 25;
function zD(t, e) {
    const n = Xt(t)
      , r = Qn(t)
      , o = n.visualViewport;
    let l = r.clientWidth
      , a = r.clientHeight
      , u = 0
      , f = 0;
    if (o) {
        l = o.width,
        a = o.height;
        const p = Yf();
        (!p || p && e === "fixed") && (u = o.offsetLeft,
        f = o.offsetTop)
    }
    const h = Wf(r);
    if (h <= 0) {
        const p = r.ownerDocument
          , m = p.body
          , y = getComputedStyle(m)
          , b = p.compatMode === "CSS1Compat" && parseFloat(y.marginLeft) + parseFloat(y.marginRight) || 0
          , C = Math.abs(r.clientWidth - m.clientWidth - b);
        C <= VC && (l -= C)
    } else
        h <= VC && (l += h);
    return {
        width: l,
        height: a,
        x: u,
        y: f
    }
}
const _D = new Set(["absolute", "fixed"]);
function BD(t, e) {
    const n = To(t, !0, e === "fixed")
      , r = n.top + t.clientTop
      , o = n.left + t.clientLeft
      , l = dn(t) ? Nl(t) : Zn(1)
      , a = t.clientWidth * l.x
      , u = t.clientHeight * l.y
      , f = o * l.x
      , h = r * l.y;
    return {
        width: a,
        height: u,
        x: f,
        y: h
    }
}
function UC(t, e, n) {
    let r;
    if (e === "viewport")
        r = zD(t, n);
    else if (e === "document")
        r = LD(Qn(t));
    else if (Ge(e))
        r = BD(e, n);
    else {
        const o = R4(t);
        r = {
            x: e.x - o.x,
            y: e.y - o.y,
            width: e.width,
            height: e.height
        }
    }
    return Sf(r)
}
function D4(t, e) {
    const n = Or(t);
    return n === e || !Ge(n) || Rr(n) ? !1 : Rn(n).position === "fixed" || D4(n, e)
}
function jD(t, e) {
    const n = e.get(t);
    if (n)
        return n;
    let r = Ti(t, [], !1).filter(u => Ge(u) && Pl(u) !== "body")
      , o = null;
    const l = Rn(t).position === "fixed";
    let a = l ? Or(t) : t;
    for (; Ge(a) && !Rr(a); ) {
        const u = Rn(a)
          , f = ag(a);
        !f && u.position === "fixed" && (o = null),
        (l ? !f && !o : !f && u.position === "static" && !!o && _D.has(o.position) || Ma(a) && !f && D4(t, a)) ? r = r.filter(p => p !== a) : o = u,
        a = Or(a)
    }
    return e.set(t, r),
    r
}
function HD(t) {
    let {element: e, boundary: n, rootBoundary: r, strategy: o} = t;
    const a = [...n === "clippingAncestors" ? Gf(e) ? [] : jD(e, this._c) : [].concat(n), r]
      , u = a[0]
      , f = a.reduce( (h, p) => {
        const m = UC(e, p, o);
        return h.top = cn(m.top, h.top),
        h.right = Ri(m.right, h.right),
        h.bottom = Ri(m.bottom, h.bottom),
        h.left = cn(m.left, h.left),
        h
    }
    , UC(e, u, o));
    return {
        width: f.right - f.left,
        height: f.bottom - f.top,
        x: f.left,
        y: f.top
    }
}
function ID(t) {
    const {width: e, height: n} = N4(t);
    return {
        width: e,
        height: n
    }
}
function VD(t, e, n) {
    const r = dn(e)
      , o = Qn(e)
      , l = n === "fixed"
      , a = To(t, !0, l, e);
    let u = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const f = Zn(0);
    function h() {
        f.x = Wf(o)
    }
    if (r || !r && !l)
        if ((Pl(e) !== "body" || Ma(o)) && (u = Zf(e)),
        r) {
            const b = To(e, !0, l, e);
            f.x = b.x + e.clientLeft,
            f.y = b.y + e.clientTop
        } else
            o && h();
    l && !r && o && h();
    const p = o && !r && !l ? O4(o, u) : Zn(0)
      , m = a.left + u.scrollLeft - f.x - p.x
      , y = a.top + u.scrollTop - f.y - p.y;
    return {
        x: m,
        y,
        width: a.width,
        height: a.height
    }
}
function nm(t) {
    return Rn(t).position === "static"
}
function PC(t, e) {
    if (!dn(t) || Rn(t).position === "fixed")
        return null;
    if (e)
        return e(t);
    let n = t.offsetParent;
    return Qn(t) === n && (n = n.ownerDocument.body),
    n
}
function L4(t, e) {
    const n = Xt(t);
    if (Gf(t))
        return n;
    if (!dn(t)) {
        let o = Or(t);
        for (; o && !Rr(o); ) {
            if (Ge(o) && !nm(o))
                return o;
            o = Or(o)
        }
        return n
    }
    let r = PC(t, e);
    for (; r && SO(r) && nm(r); )
        r = PC(r, e);
    return r && Rr(r) && nm(r) && !ag(r) ? n : r || kO(t) || n
}
const UD = async function(t) {
    const e = this.getOffsetParent || L4
      , n = this.getDimensions
      , r = await n(t.floating);
    return {
        reference: VD(t.reference, await e(t.floating), t.strategy),
        floating: {
            x: 0,
            y: 0,
            width: r.width,
            height: r.height
        }
    }
};
function PD(t) {
    return Rn(t).direction === "rtl"
}
const qD = {
    convertOffsetParentRelativeRectToViewportRelativeRect: OD,
    getDocumentElement: Qn,
    getClippingRect: HD,
    getOffsetParent: L4,
    getElementRects: UD,
    getClientRects: DD,
    getDimensions: ID,
    getScale: Nl,
    isElement: Ge,
    isRTL: PD
};
function z4(t, e) {
    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
}
function $D(t, e) {
    let n = null, r;
    const o = Qn(t);
    function l() {
        var u;
        clearTimeout(r),
        (u = n) == null || u.disconnect(),
        n = null
    }
    function a(u, f) {
        u === void 0 && (u = !1),
        f === void 0 && (f = 1),
        l();
        const h = t.getBoundingClientRect()
          , {left: p, top: m, width: y, height: b} = h;
        if (u || e(),
        !y || !b)
            return;
        const C = uu(m)
          , S = uu(o.clientWidth - (p + y))
          , w = uu(o.clientHeight - (m + b))
          , k = uu(p)
          , O = {
            rootMargin: -C + "px " + -S + "px " + -w + "px " + -k + "px",
            threshold: cn(0, Ri(1, f)) || 1
        };
        let B = !0;
        function z($) {
            const _ = $[0].intersectionRatio;
            if (_ !== f) {
                if (!B)
                    return a();
                _ ? a(!1, _) : r = setTimeout( () => {
                    a(!1, 1e-7)
                }
                , 1e3)
            }
            _ === 1 && !z4(h, t.getBoundingClientRect()) && a(),
            B = !1
        }
        try {
            n = new IntersectionObserver(z,{
                ...O,
                root: o.ownerDocument
            })
        } catch {
            n = new IntersectionObserver(z,O)
        }
        n.observe(t)
    }
    return a(!0),
    l
}
function _4(t, e, n, r) {
    r === void 0 && (r = {});
    const {ancestorScroll: o=!0, ancestorResize: l=!0, elementResize: a=typeof ResizeObserver == "function", layoutShift: u=typeof IntersectionObserver == "function", animationFrame: f=!1} = r
      , h = dg(t)
      , p = o || l ? [...h ? Ti(h) : [], ...Ti(e)] : [];
    p.forEach(k => {
        o && k.addEventListener("scroll", n, {
            passive: !0
        }),
        l && k.addEventListener("resize", n)
    }
    );
    const m = h && u ? $D(h, n) : null;
    let y = -1
      , b = null;
    a && (b = new ResizeObserver(k => {
        let[A] = k;
        A && A.target === h && b && (b.unobserve(e),
        cancelAnimationFrame(y),
        y = requestAnimationFrame( () => {
            var O;
            (O = b) == null || O.observe(e)
        }
        )),
        n()
    }
    ),
    h && !f && b.observe(h),
    b.observe(e));
    let C, S = f ? To(t) : null;
    f && w();
    function w() {
        const k = To(t);
        S && !z4(S, k) && n(),
        S = k,
        C = requestAnimationFrame(w)
    }
    return n(),
    () => {
        var k;
        p.forEach(A => {
            o && A.removeEventListener("scroll", n),
            l && A.removeEventListener("resize", n)
        }
        ),
        m?.(),
        (k = b) == null || k.disconnect(),
        b = null,
        f && cancelAnimationFrame(C)
    }
}
const FD = TD
  , KD = kD
  , GD = xD
  , YD = AD
  , ZD = wD
  , qC = SD
  , WD = MD
  , XD = (t, e, n) => {
    const r = new Map
      , o = {
        platform: qD,
        ...n
    }
      , l = {
        ...o.platform,
        _c: r
    };
    return CD(t, e, {
        ...o,
        platform: l
    })
}
;
var JD = typeof document < "u"
  , QD = function() {}
  , Tu = JD ? T.useLayoutEffect : QD;
function Ef(t, e) {
    if (t === e)
        return !0;
    if (typeof t != typeof e)
        return !1;
    if (typeof t == "function" && t.toString() === e.toString())
        return !0;
    let n, r, o;
    if (t && e && typeof t == "object") {
        if (Array.isArray(t)) {
            if (n = t.length,
            n !== e.length)
                return !1;
            for (r = n; r-- !== 0; )
                if (!Ef(t[r], e[r]))
                    return !1;
            return !0
        }
        if (o = Object.keys(t),
        n = o.length,
        n !== Object.keys(e).length)
            return !1;
        for (r = n; r-- !== 0; )
            if (!{}.hasOwnProperty.call(e, o[r]))
                return !1;
        for (r = n; r-- !== 0; ) {
            const l = o[r];
            if (!(l === "_owner" && t.$$typeof) && !Ef(t[l], e[l]))
                return !1
        }
        return !0
    }
    return t !== t && e !== e
}
function B4(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function $C(t, e) {
    const n = B4(t);
    return Math.round(e * n) / n
}
function rm(t) {
    const e = T.useRef(t);
    return Tu( () => {
        e.current = t
    }
    ),
    e
}
function j4(t) {
    t === void 0 && (t = {});
    const {placement: e="bottom", strategy: n="absolute", middleware: r=[], platform: o, elements: {reference: l, floating: a}={}, transform: u=!0, whileElementsMounted: f, open: h} = t
      , [p,m] = T.useState({
        x: 0,
        y: 0,
        strategy: n,
        placement: e,
        middlewareData: {},
        isPositioned: !1
    })
      , [y,b] = T.useState(r);
    Ef(y, r) || b(r);
    const [C,S] = T.useState(null)
      , [w,k] = T.useState(null)
      , A = T.useCallback(q => {
        q !== $.current && ($.current = q,
        S(q))
    }
    , [])
      , O = T.useCallback(q => {
        q !== _.current && (_.current = q,
        k(q))
    }
    , [])
      , B = l || C
      , z = a || w
      , $ = T.useRef(null)
      , _ = T.useRef(null)
      , W = T.useRef(p)
      , ne = f != null
      , de = rm(f)
      , ve = rm(o)
      , pe = rm(h)
      , be = T.useCallback( () => {
        if (!$.current || !_.current)
            return;
        const q = {
            placement: e,
            strategy: n,
            middleware: y
        };
        ve.current && (q.platform = ve.current),
        XD($.current, _.current, q).then(ee => {
            const ie = {
                ...ee,
                isPositioned: pe.current !== !1
            };
            Q.current && !Ef(W.current, ie) && (W.current = ie,
            Mf.flushSync( () => {
                m(ie)
            }
            ))
        }
        )
    }
    , [y, e, n, ve, pe]);
    Tu( () => {
        h === !1 && W.current.isPositioned && (W.current.isPositioned = !1,
        m(q => ({
            ...q,
            isPositioned: !1
        })))
    }
    , [h]);
    const Q = T.useRef(!1);
    Tu( () => (Q.current = !0,
    () => {
        Q.current = !1
    }
    ), []),
    Tu( () => {
        if (B && ($.current = B),
        z && (_.current = z),
        B && z) {
            if (de.current)
                return de.current(B, z, be);
            be()
        }
    }
    , [B, z, be, de, ne]);
    const ae = T.useMemo( () => ({
        reference: $,
        floating: _,
        setReference: A,
        setFloating: O
    }), [A, O])
      , j = T.useMemo( () => ({
        reference: B,
        floating: z
    }), [B, z])
      , P = T.useMemo( () => {
        const q = {
            position: n,
            left: 0,
            top: 0
        };
        if (!j.floating)
            return q;
        const ee = $C(j.floating, p.x)
          , ie = $C(j.floating, p.y);
        return u ? {
            ...q,
            transform: "translate(" + ee + "px, " + ie + "px)",
            ...B4(j.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: n,
            left: ee,
            top: ie
        }
    }
    , [n, u, j.floating, p.x, p.y]);
    return T.useMemo( () => ({
        ...p,
        update: be,
        refs: ae,
        elements: j,
        floatingStyles: P
    }), [p, be, ae, j, P])
}
const eL = t => {
    function e(n) {
        return {}.hasOwnProperty.call(n, "current")
    }
    return {
        name: "arrow",
        options: t,
        fn(n) {
            const {element: r, padding: o} = typeof t == "function" ? t(n) : t;
            return r && e(r) ? r.current != null ? qC({
                element: r.current,
                padding: o
            }).fn(n) : {} : r ? qC({
                element: r,
                padding: o
            }).fn(n) : {}
        }
    }
}
  , H4 = (t, e) => ({
    ...FD(t),
    options: [t, e]
})
  , I4 = (t, e) => ({
    ...KD(t),
    options: [t, e]
})
  , tL = (t, e) => ({
    ...WD(t),
    options: [t, e]
})
  , V4 = (t, e) => ({
    ...GD(t),
    options: [t, e]
})
  , nL = (t, e) => ({
    ...YD(t),
    options: [t, e]
})
  , rL = (t, e) => ({
    ...ZD(t),
    options: [t, e]
})
  , iL = (t, e) => ({
    ...eL(t),
    options: [t, e]
});
function U4(t) {
    const e = T.useRef(void 0)
      , n = T.useCallback(r => {
        const o = t.map(l => {
            if (l != null) {
                if (typeof l == "function") {
                    const a = l
                      , u = a(r);
                    return typeof u == "function" ? u : () => {
                        a(null)
                    }
                }
                return l.current = r,
                () => {
                    l.current = null
                }
            }
        }
        );
        return () => {
            o.forEach(l => l?.())
        }
    }
    , t);
    return T.useMemo( () => t.every(r => r == null) ? null : r => {
        e.current && (e.current(),
        e.current = void 0),
        r != null && (e.current = n(r))
    }
    , t)
}
const oL = "data-floating-ui-focusable"
  , FC = "active"
  , KC = "selected"
  , lL = {
    ...kf
};
let GC = !1
  , sL = 0;
const YC = () => "floating-ui-" + Math.random().toString(36).slice(2, 6) + sL++;
function aL() {
    const [t,e] = T.useState( () => GC ? YC() : void 0);
    return Bn( () => {
        t == null && e(YC())
    }
    , []),
    T.useEffect( () => {
        GC = !0
    }
    , []),
    t
}
const cL = lL.useId
  , hg = cL || aL;
function uL() {
    const t = new Map;
    return {
        emit(e, n) {
            var r;
            (r = t.get(e)) == null || r.forEach(o => o(n))
        },
        on(e, n) {
            t.has(e) || t.set(e, new Set),
            t.get(e).add(n)
        },
        off(e, n) {
            var r;
            (r = t.get(e)) == null || r.delete(n)
        }
    }
}
const fL = T.createContext(null)
  , dL = T.createContext(null)
  , pg = () => {
    var t;
    return ((t = T.useContext(fL)) == null ? void 0 : t.id) || null
}
  , mg = () => T.useContext(dL);
function Aa(t) {
    return "data-floating-ui-" + t
}
function En(t) {
    t.current !== -1 && (clearTimeout(t.current),
    t.current = -1)
}
const ZC = Aa("safe-polygon");
function im(t, e, n) {
    if (n && !l1(n))
        return 0;
    if (typeof t == "number")
        return t;
    if (typeof t == "function") {
        const r = t();
        return typeof r == "number" ? r : r?.[e]
    }
    return t?.[e]
}
function om(t) {
    return typeof t == "function" ? t() : t
}
function hL(t, e) {
    e === void 0 && (e = {});
    const {open: n, onOpenChange: r, dataRef: o, events: l, elements: a} = t
      , {enabled: u=!0, delay: f=0, handleClose: h=null, mouseOnly: p=!1, restMs: m=0, move: y=!0} = e
      , b = mg()
      , C = pg()
      , S = fu(h)
      , w = fu(f)
      , k = fu(n)
      , A = fu(m)
      , O = T.useRef()
      , B = T.useRef(-1)
      , z = T.useRef()
      , $ = T.useRef(-1)
      , _ = T.useRef(!0)
      , W = T.useRef(!1)
      , ne = T.useRef( () => {}
    )
      , de = T.useRef(!1)
      , ve = Fn( () => {
        var P;
        const q = (P = o.current.openEvent) == null ? void 0 : P.type;
        return q?.includes("mouse") && q !== "mousedown"
    }
    );
    T.useEffect( () => {
        if (!u)
            return;
        function P(q) {
            let {open: ee} = q;
            ee || (En(B),
            En($),
            _.current = !0,
            de.current = !1)
        }
        return l.on("openchange", P),
        () => {
            l.off("openchange", P)
        }
    }
    , [u, l]),
    T.useEffect( () => {
        if (!u || !S.current || !n)
            return;
        function P(ee) {
            ve() && r(!1, ee, "hover")
        }
        const q = Yn(a.floating).documentElement;
        return q.addEventListener("mouseleave", P),
        () => {
            q.removeEventListener("mouseleave", P)
        }
    }
    , [a.floating, n, r, u, S, ve]);
    const pe = T.useCallback(function(P, q, ee) {
        q === void 0 && (q = !0),
        ee === void 0 && (ee = "hover");
        const ie = im(w.current, "close", O.current);
        ie && !z.current ? (En(B),
        B.current = window.setTimeout( () => r(!1, P, ee), ie)) : q && (En(B),
        r(!1, P, ee))
    }, [w, r])
      , be = Fn( () => {
        ne.current(),
        z.current = void 0
    }
    )
      , Q = Fn( () => {
        if (W.current) {
            const P = Yn(a.floating).body;
            P.style.pointerEvents = "",
            P.removeAttribute(ZC),
            W.current = !1
        }
    }
    )
      , ae = Fn( () => o.current.openEvent ? ["click", "mousedown"].includes(o.current.openEvent.type) : !1);
    T.useEffect( () => {
        if (!u)
            return;
        function P(U) {
            if (En(B),
            _.current = !1,
            p && !l1(O.current) || om(A.current) > 0 && !im(w.current, "open"))
                return;
            const X = im(w.current, "open", O.current);
            X ? B.current = window.setTimeout( () => {
                k.current || r(!0, U, "hover")
            }
            , X) : n || r(!0, U, "hover")
        }
        function q(U) {
            if (ae()) {
                Q();
                return
            }
            ne.current();
            const X = Yn(a.floating);
            if (En($),
            de.current = !1,
            S.current && o.current.floatingContext) {
                n || En(B),
                z.current = S.current({
                    ...o.current.floatingContext,
                    tree: b,
                    x: U.clientX,
                    y: U.clientY,
                    onClose() {
                        Q(),
                        be(),
                        ae() || pe(U, !0, "safe-polygon")
                    }
                });
                const ce = z.current;
                X.addEventListener("mousemove", ce),
                ne.current = () => {
                    X.removeEventListener("mousemove", ce)
                }
                ;
                return
            }
            (O.current !== "touch" || !Hl(a.floating, U.relatedTarget)) && pe(U)
        }
        function ee(U) {
            ae() || o.current.floatingContext && (S.current == null || S.current({
                ...o.current.floatingContext,
                tree: b,
                x: U.clientX,
                y: U.clientY,
                onClose() {
                    Q(),
                    be(),
                    ae() || pe(U)
                }
            })(U))
        }
        function ie() {
            En(B)
        }
        function R(U) {
            ae() || pe(U, !1)
        }
        if (Ge(a.domReference)) {
            const U = a.domReference
              , X = a.floating;
            return n && U.addEventListener("mouseleave", ee),
            y && U.addEventListener("mousemove", P, {
                once: !0
            }),
            U.addEventListener("mouseenter", P),
            U.addEventListener("mouseleave", q),
            X && (X.addEventListener("mouseleave", ee),
            X.addEventListener("mouseenter", ie),
            X.addEventListener("mouseleave", R)),
            () => {
                n && U.removeEventListener("mouseleave", ee),
                y && U.removeEventListener("mousemove", P),
                U.removeEventListener("mouseenter", P),
                U.removeEventListener("mouseleave", q),
                X && (X.removeEventListener("mouseleave", ee),
                X.removeEventListener("mouseenter", ie),
                X.removeEventListener("mouseleave", R))
            }
        }
    }
    , [a, u, t, p, y, pe, be, Q, r, n, k, b, w, S, o, ae, A]),
    Bn( () => {
        var P;
        if (u && n && (P = S.current) != null && (P = P.__options) != null && P.blockPointerEvents && ve()) {
            W.current = !0;
            const ee = a.floating;
            if (Ge(a.domReference) && ee) {
                var q;
                const ie = Yn(a.floating).body;
                ie.setAttribute(ZC, "");
                const R = a.domReference
                  , U = b == null || (q = b.nodesRef.current.find(X => X.id === C)) == null || (q = q.context) == null ? void 0 : q.elements.floating;
                return U && (U.style.pointerEvents = ""),
                ie.style.pointerEvents = "none",
                R.style.pointerEvents = "auto",
                ee.style.pointerEvents = "auto",
                () => {
                    ie.style.pointerEvents = "",
                    R.style.pointerEvents = "",
                    ee.style.pointerEvents = ""
                }
            }
        }
    }
    , [u, n, C, a, b, S, ve]),
    Bn( () => {
        n || (O.current = void 0,
        de.current = !1,
        be(),
        Q())
    }
    , [n, be, Q]),
    T.useEffect( () => () => {
        be(),
        En(B),
        En($),
        Q()
    }
    , [u, a.domReference, be, Q]);
    const j = T.useMemo( () => {
        function P(q) {
            O.current = q.pointerType
        }
        return {
            onPointerDown: P,
            onPointerEnter: P,
            onMouseMove(q) {
                const {nativeEvent: ee} = q;
                function ie() {
                    !_.current && !k.current && r(!0, ee, "hover")
                }
                p && !l1(O.current) || n || om(A.current) === 0 || de.current && q.movementX ** 2 + q.movementY ** 2 < 2 || (En($),
                O.current === "touch" ? ie() : (de.current = !0,
                $.current = window.setTimeout(ie, om(A.current))))
            }
        }
    }
    , [p, r, n, k, A]);
    return T.useMemo( () => u ? {
        reference: j
    } : {}, [u, j])
}
const WC = () => {}
  , pL = T.createContext({
    delay: 0,
    initialDelay: 0,
    timeoutMs: 0,
    currentId: null,
    setCurrentId: WC,
    setState: WC,
    isInstantPhase: !1
});
function mL(t) {
    const {children: e, delay: n, timeoutMs: r=0} = t
      , [o,l] = T.useReducer( (f, h) => ({
        ...f,
        ...h
    }), {
        delay: n,
        timeoutMs: r,
        initialDelay: n,
        currentId: null,
        isInstantPhase: !1
    })
      , a = T.useRef(null)
      , u = T.useCallback(f => {
        l({
            currentId: f
        })
    }
    , []);
    return Bn( () => {
        o.currentId ? a.current === null ? a.current = o.currentId : o.isInstantPhase || l({
            isInstantPhase: !0
        }) : (o.isInstantPhase && l({
            isInstantPhase: !1
        }),
        a.current = null)
    }
    , [o.currentId, o.isInstantPhase]),
    E.jsx(pL.Provider, {
        value: T.useMemo( () => ({
            ...o,
            setState: l,
            setCurrentId: u
        }), [o, u]),
        children: e
    })
}
const gL = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "fixed",
    whiteSpace: "nowrap",
    width: "1px",
    top: 0,
    left: 0
}
  , XC = T.forwardRef(function(e, n) {
    const [r,o] = T.useState();
    Bn( () => {
        T4() && o("button")
    }
    , []);
    const l = {
        ref: n,
        tabIndex: 0,
        role: r,
        "aria-hidden": r ? void 0 : !0,
        [Aa("focus-guard")]: "",
        style: gL
    };
    return E.jsx("span", {
        ...e,
        ...l
    })
})
  , yL = {
    clipPath: "inset(50%)",
    position: "fixed",
    top: 0,
    left: 0
}
  , P4 = T.createContext(null)
  , JC = Aa("portal");
function vL(t) {
    t === void 0 && (t = {});
    const {id: e, root: n} = t
      , r = hg()
      , o = CL()
      , [l,a] = T.useState(null)
      , u = T.useRef(null);
    return Bn( () => () => {
        l?.remove(),
        queueMicrotask( () => {
            u.current = null
        }
        )
    }
    , [l]),
    Bn( () => {
        if (!r || u.current)
            return;
        const f = e ? document.getElementById(e) : null;
        if (!f)
            return;
        const h = document.createElement("div");
        h.id = r,
        h.setAttribute(JC, ""),
        f.appendChild(h),
        u.current = h,
        a(h)
    }
    , [e, r]),
    Bn( () => {
        if (n === null || !r || u.current)
            return;
        let f = n || o?.portalNode;
        f && !sg(f) && (f = f.current),
        f = f || document.body;
        let h = null;
        e && (h = document.createElement("div"),
        h.id = e,
        f.appendChild(h));
        const p = document.createElement("div");
        p.id = r,
        p.setAttribute(JC, ""),
        f = h || f,
        f.appendChild(p),
        u.current = p,
        a(p)
    }
    , [e, n, r, o]),
    l
}
function bL(t) {
    const {children: e, id: n, root: r, preserveTabOrder: o=!0} = t
      , l = vL({
        id: n,
        root: r
    })
      , [a,u] = T.useState(null)
      , f = T.useRef(null)
      , h = T.useRef(null)
      , p = T.useRef(null)
      , m = T.useRef(null)
      , y = a?.modal
      , b = a?.open
      , C = !!a && !a.modal && a.open && o && !!(r || l);
    return T.useEffect( () => {
        if (!l || !o || y)
            return;
        function S(w) {
            l && tm(w) && (w.type === "focusin" ? BC : vD)(l)
        }
        return l.addEventListener("focusin", S, !0),
        l.addEventListener("focusout", S, !0),
        () => {
            l.removeEventListener("focusin", S, !0),
            l.removeEventListener("focusout", S, !0)
        }
    }
    , [l, o, y]),
    T.useEffect( () => {
        l && (b || BC(l))
    }
    , [b, l]),
    E.jsxs(P4.Provider, {
        value: T.useMemo( () => ({
            preserveTabOrder: o,
            beforeOutsideRef: f,
            afterOutsideRef: h,
            beforeInsideRef: p,
            afterInsideRef: m,
            portalNode: l,
            setFocusManagerState: u
        }), [o, l]),
        children: [C && l && E.jsx(XC, {
            "data-type": "outside",
            ref: f,
            onFocus: S => {
                if (tm(S, l)) {
                    var w;
                    (w = p.current) == null || w.focus()
                } else {
                    const k = a ? a.domReference : null
                      , A = yD(k);
                    A?.focus()
                }
            }
        }), C && l && E.jsx("span", {
            "aria-owns": l.id,
            style: yL
        }), l && Mf.createPortal(e, l), C && l && E.jsx(XC, {
            "data-type": "outside",
            ref: h,
            onFocus: S => {
                if (tm(S, l)) {
                    var w;
                    (w = m.current) == null || w.focus()
                } else {
                    const k = a ? a.domReference : null
                      , A = gD(k);
                    A?.focus(),
                    a?.closeOnFocusOut && a?.onOpenChange(!1, S.nativeEvent, "focus-out")
                }
            }
        })]
    })
}
const CL = () => T.useContext(P4)
  , SL = {
    pointerdown: "onPointerDown",
    mousedown: "onMouseDown",
    click: "onClick"
}
  , xL = {
    pointerdown: "onPointerDownCapture",
    mousedown: "onMouseDownCapture",
    click: "onClickCapture"
}
  , QC = t => {
    var e, n;
    return {
        escapeKey: typeof t == "boolean" ? t : (e = t?.escapeKey) != null ? e : !1,
        outsidePress: typeof t == "boolean" ? t : (n = t?.outsidePress) != null ? n : !0
    }
}
;
function wL(t, e) {
    e === void 0 && (e = {});
    const {open: n, onOpenChange: r, elements: o, dataRef: l} = t
      , {enabled: a=!0, escapeKey: u=!0, outsidePress: f=!0, outsidePressEvent: h="pointerdown", referencePress: p=!1, referencePressEvent: m="pointerdown", ancestorScroll: y=!1, bubbles: b, capture: C} = e
      , S = mg()
      , w = Fn(typeof f == "function" ? f : () => !1)
      , k = typeof f == "function" ? w : f
      , A = T.useRef(!1)
      , {escapeKey: O, outsidePress: B} = QC(b)
      , {escapeKey: z, outsidePress: $} = QC(C)
      , _ = T.useRef(!1)
      , W = Fn(Q => {
        var ae;
        if (!n || !a || !u || Q.key !== "Escape" || _.current)
            return;
        const j = (ae = l.current.floatingContext) == null ? void 0 : ae.nodeId
          , P = S ? Eu(S.nodesRef.current, j) : [];
        if (!O && (Q.stopPropagation(),
        P.length > 0)) {
            let q = !0;
            if (P.forEach(ee => {
                var ie;
                if ((ie = ee.context) != null && ie.open && !ee.context.dataRef.current.__escapeKeyBubbles) {
                    q = !1;
                    return
                }
            }
            ),
            !q)
                return
        }
        r(!1, uD(Q) ? Q.nativeEvent : Q, "escape-key")
    }
    )
      , ne = Fn(Q => {
        var ae;
        const j = () => {
            var P;
            W(Q),
            (P = El(Q)) == null || P.removeEventListener("keydown", j)
        }
        ;
        (ae = El(Q)) == null || ae.addEventListener("keydown", j)
    }
    )
      , de = Fn(Q => {
        var ae;
        const j = l.current.insideReactTree;
        l.current.insideReactTree = !1;
        const P = A.current;
        if (A.current = !1,
        h === "click" && P || j || typeof k == "function" && !k(Q))
            return;
        const q = El(Q)
          , ee = "[" + Aa("inert") + "]"
          , ie = Yn(o.floating).querySelectorAll(ee);
        let R = Ge(q) ? q : null;
        for (; R && !Rr(R); ) {
            const ce = Or(R);
            if (Rr(ce) || !Ge(ce))
                break;
            R = ce
        }
        if (ie.length && Ge(q) && !lD(q) && !Hl(q, o.floating) && Array.from(ie).every(ce => !Hl(R, ce)))
            return;
        if (dn(q) && be) {
            const ce = Rr(q)
              , ge = Rn(q)
              , Se = /auto|scroll/
              , lt = ce || Se.test(ge.overflowX)
              , qe = ce || Se.test(ge.overflowY)
              , er = lt && q.clientWidth > 0 && q.scrollWidth > q.clientWidth
              , Br = qe && q.clientHeight > 0 && q.scrollHeight > q.clientHeight
              , Ii = ge.direction === "rtl"
              , tr = Br && (Ii ? Q.offsetX <= q.offsetWidth - q.clientWidth : Q.offsetX > q.clientWidth)
              , nr = er && Q.offsetY > q.clientHeight;
            if (tr || nr)
                return
        }
        const U = (ae = l.current.floatingContext) == null ? void 0 : ae.nodeId
          , X = S && Eu(S.nodesRef.current, U).some(ce => {
            var ge;
            return em(Q, (ge = ce.context) == null ? void 0 : ge.elements.floating)
        }
        );
        if (em(Q, o.floating) || em(Q, o.domReference) || X)
            return;
        const re = S ? Eu(S.nodesRef.current, U) : [];
        if (re.length > 0) {
            let ce = !0;
            if (re.forEach(ge => {
                var Se;
                if ((Se = ge.context) != null && Se.open && !ge.context.dataRef.current.__outsidePressBubbles) {
                    ce = !1;
                    return
                }
            }
            ),
            !ce)
                return
        }
        r(!1, Q, "outside-press")
    }
    )
      , ve = Fn(Q => {
        var ae;
        const j = () => {
            var P;
            de(Q),
            (P = El(Q)) == null || P.removeEventListener(h, j)
        }
        ;
        (ae = El(Q)) == null || ae.addEventListener(h, j)
    }
    );
    T.useEffect( () => {
        if (!n || !a)
            return;
        l.current.__escapeKeyBubbles = O,
        l.current.__outsidePressBubbles = B;
        let Q = -1;
        function ae(ie) {
            r(!1, ie, "ancestor-scroll")
        }
        function j() {
            window.clearTimeout(Q),
            _.current = !0
        }
        function P() {
            Q = window.setTimeout( () => {
                _.current = !1
            }
            , Yf() ? 5 : 0)
        }
        const q = Yn(o.floating);
        u && (q.addEventListener("keydown", z ? ne : W, z),
        q.addEventListener("compositionstart", j),
        q.addEventListener("compositionend", P)),
        k && q.addEventListener(h, $ ? ve : de, $);
        let ee = [];
        return y && (Ge(o.domReference) && (ee = Ti(o.domReference)),
        Ge(o.floating) && (ee = ee.concat(Ti(o.floating))),
        !Ge(o.reference) && o.reference && o.reference.contextElement && (ee = ee.concat(Ti(o.reference.contextElement)))),
        ee = ee.filter(ie => {
            var R;
            return ie !== ((R = q.defaultView) == null ? void 0 : R.visualViewport)
        }
        ),
        ee.forEach(ie => {
            ie.addEventListener("scroll", ae, {
                passive: !0
            })
        }
        ),
        () => {
            u && (q.removeEventListener("keydown", z ? ne : W, z),
            q.removeEventListener("compositionstart", j),
            q.removeEventListener("compositionend", P)),
            k && q.removeEventListener(h, $ ? ve : de, $),
            ee.forEach(ie => {
                ie.removeEventListener("scroll", ae)
            }
            ),
            window.clearTimeout(Q)
        }
    }
    , [l, o, u, k, h, n, r, y, a, O, B, W, z, ne, de, $, ve]),
    T.useEffect( () => {
        l.current.insideReactTree = !1
    }
    , [l, k, h]);
    const pe = T.useMemo( () => ({
        onKeyDown: W,
        ...p && {
            [SL[m]]: Q => {
                r(!1, Q.nativeEvent, "reference-press")
            }
            ,
            ...m !== "click" && {
                onClick(Q) {
                    r(!1, Q.nativeEvent, "reference-press")
                }
            }
        }
    }), [W, r, p, m])
      , be = T.useMemo( () => ({
        onKeyDown: W,
        onMouseDown() {
            A.current = !0
        },
        onMouseUp() {
            A.current = !0
        },
        [xL[h]]: () => {
            l.current.insideReactTree = !0
        }
    }), [W, h, l]);
    return T.useMemo( () => a ? {
        reference: pe,
        floating: be
    } : {}, [a, pe, be])
}
function EL(t) {
    const {open: e=!1, onOpenChange: n, elements: r} = t
      , o = hg()
      , l = T.useRef({})
      , [a] = T.useState( () => uL())
      , u = pg() != null
      , [f,h] = T.useState(r.reference)
      , p = Fn( (b, C, S) => {
        l.current.openEvent = b ? C : void 0,
        a.emit("openchange", {
            open: b,
            event: C,
            reason: S,
            nested: u
        }),
        n?.(b, C, S)
    }
    )
      , m = T.useMemo( () => ({
        setPositionReference: h
    }), [])
      , y = T.useMemo( () => ({
        reference: f || r.reference || null,
        floating: r.floating || null,
        domReference: r.reference
    }), [f, r.reference, r.floating]);
    return T.useMemo( () => ({
        dataRef: l,
        open: e,
        onOpenChange: p,
        elements: y,
        events: a,
        floatingId: o,
        refs: m
    }), [e, p, y, a, o, m])
}
function TL(t) {
    t === void 0 && (t = {});
    const {nodeId: e} = t
      , n = EL({
        ...t,
        elements: {
            reference: null,
            floating: null,
            ...t.elements
        }
    })
      , r = t.rootContext || n
      , o = r.elements
      , [l,a] = T.useState(null)
      , [u,f] = T.useState(null)
      , p = o?.domReference || l
      , m = T.useRef(null)
      , y = mg();
    Bn( () => {
        p && (m.current = p)
    }
    , [p]);
    const b = j4({
        ...t,
        elements: {
            ...o,
            ...u && {
                reference: u
            }
        }
    })
      , C = T.useCallback(O => {
        const B = Ge(O) ? {
            getBoundingClientRect: () => O.getBoundingClientRect(),
            getClientRects: () => O.getClientRects(),
            contextElement: O
        } : O;
        f(B),
        b.refs.setReference(B)
    }
    , [b.refs])
      , S = T.useCallback(O => {
        (Ge(O) || O === null) && (m.current = O,
        a(O)),
        (Ge(b.refs.reference.current) || b.refs.reference.current === null || O !== null && !Ge(O)) && b.refs.setReference(O)
    }
    , [b.refs])
      , w = T.useMemo( () => ({
        ...b.refs,
        setReference: S,
        setPositionReference: C,
        domReference: m
    }), [b.refs, S, C])
      , k = T.useMemo( () => ({
        ...b.elements,
        domReference: p
    }), [b.elements, p])
      , A = T.useMemo( () => ({
        ...b,
        ...r,
        refs: w,
        elements: k,
        nodeId: e
    }), [b, w, k, e, r]);
    return Bn( () => {
        r.dataRef.current.floatingContext = A;
        const O = y?.nodesRef.current.find(B => B.id === e);
        O && (O.context = A)
    }
    ),
    T.useMemo( () => ({
        ...b,
        context: A,
        refs: w,
        elements: k
    }), [b, w, k, A])
}
function lm() {
    return rD() && T4()
}
function kL(t, e) {
    e === void 0 && (e = {});
    const {open: n, onOpenChange: r, events: o, dataRef: l, elements: a} = t
      , {enabled: u=!0, visibleOnly: f=!0} = e
      , h = T.useRef(!1)
      , p = T.useRef(-1)
      , m = T.useRef(!0);
    T.useEffect( () => {
        if (!u)
            return;
        const b = Xt(a.domReference);
        function C() {
            !n && dn(a.domReference) && a.domReference === o1(Yn(a.domReference)) && (h.current = !0)
        }
        function S() {
            m.current = !0
        }
        function w() {
            m.current = !1
        }
        return b.addEventListener("blur", C),
        lm() && (b.addEventListener("keydown", S, !0),
        b.addEventListener("pointerdown", w, !0)),
        () => {
            b.removeEventListener("blur", C),
            lm() && (b.removeEventListener("keydown", S, !0),
            b.removeEventListener("pointerdown", w, !0))
        }
    }
    , [a.domReference, n, u]),
    T.useEffect( () => {
        if (!u)
            return;
        function b(C) {
            let {reason: S} = C;
            (S === "reference-press" || S === "escape-key") && (h.current = !0)
        }
        return o.on("openchange", b),
        () => {
            o.off("openchange", b)
        }
    }
    , [o, u]),
    T.useEffect( () => () => {
        En(p)
    }
    , []);
    const y = T.useMemo( () => ({
        onMouseLeave() {
            h.current = !1
        },
        onFocus(b) {
            if (h.current)
                return;
            const C = El(b.nativeEvent);
            if (f && Ge(C)) {
                if (lm() && !b.relatedTarget) {
                    if (!m.current && !sD(C))
                        return
                } else if (!aD(C))
                    return
            }
            r(!0, b.nativeEvent, "focus")
        },
        onBlur(b) {
            h.current = !1;
            const C = b.relatedTarget
              , S = b.nativeEvent
              , w = Ge(C) && C.hasAttribute(Aa("focus-guard")) && C.getAttribute("data-type") === "outside";
            p.current = window.setTimeout( () => {
                var k;
                const A = o1(a.domReference ? a.domReference.ownerDocument : document);
                !C && A === a.domReference || Hl((k = l.current.floatingContext) == null ? void 0 : k.refs.floating.current, A) || Hl(a.domReference, A) || w || r(!1, S, "focus")
            }
            )
        }
    }), [l, a.domReference, r, f]);
    return T.useMemo( () => u ? {
        reference: y
    } : {}, [u, y])
}
function sm(t, e, n) {
    const r = new Map
      , o = n === "item";
    let l = t;
    if (o && t) {
        const {[FC]: a, [KC]: u, ...f} = t;
        l = f
    }
    return {
        ...n === "floating" && {
            tabIndex: -1,
            [oL]: ""
        },
        ...l,
        ...e.map(a => {
            const u = a ? a[n] : null;
            return typeof u == "function" ? t ? u(t) : null : u
        }
        ).concat(t).reduce( (a, u) => (u && Object.entries(u).forEach(f => {
            let[h,p] = f;
            if (!(o && [FC, KC].includes(h)))
                if (h.indexOf("on") === 0) {
                    if (r.has(h) || r.set(h, []),
                    typeof p == "function") {
                        var m;
                        (m = r.get(h)) == null || m.push(p),
                        a[h] = function() {
                            for (var y, b = arguments.length, C = new Array(b), S = 0; S < b; S++)
                                C[S] = arguments[S];
                            return (y = r.get(h)) == null ? void 0 : y.map(w => w(...C)).find(w => w !== void 0)
                        }
                    }
                } else
                    a[h] = p
        }
        ),
        a), {})
    }
}
function ML(t) {
    t === void 0 && (t = []);
    const e = t.map(u => u?.reference)
      , n = t.map(u => u?.floating)
      , r = t.map(u => u?.item)
      , o = T.useCallback(u => sm(u, t, "reference"), e)
      , l = T.useCallback(u => sm(u, t, "floating"), n)
      , a = T.useCallback(u => sm(u, t, "item"), r);
    return T.useMemo( () => ({
        getReferenceProps: o,
        getFloatingProps: l,
        getItemProps: a
    }), [o, l, a])
}
const AL = new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function NL(t, e) {
    var n, r;
    e === void 0 && (e = {});
    const {open: o, elements: l, floatingId: a} = t
      , {enabled: u=!0, role: f="dialog"} = e
      , h = hg()
      , p = ((n = l.domReference) == null ? void 0 : n.id) || h
      , m = T.useMemo( () => {
        var A;
        return ((A = cD(l.floating)) == null ? void 0 : A.id) || a
    }
    , [l.floating, a])
      , y = (r = AL.get(f)) != null ? r : f
      , C = pg() != null
      , S = T.useMemo( () => y === "tooltip" || f === "label" ? {
        ["aria-" + (f === "label" ? "labelledby" : "describedby")]: o ? m : void 0
    } : {
        "aria-expanded": o ? "true" : "false",
        "aria-haspopup": y === "alertdialog" ? "dialog" : y,
        "aria-controls": o ? m : void 0,
        ...y === "listbox" && {
            role: "combobox"
        },
        ...y === "menu" && {
            id: p
        },
        ...y === "menu" && C && {
            role: "menuitem"
        },
        ...f === "select" && {
            "aria-autocomplete": "none"
        },
        ...f === "combobox" && {
            "aria-autocomplete": "list"
        }
    }, [y, m, C, o, p, f])
      , w = T.useMemo( () => {
        const A = {
            id: m,
            ...y && {
                role: y
            }
        };
        return y === "tooltip" || f === "label" ? A : {
            ...A,
            ...y === "menu" && {
                "aria-labelledby": p
            }
        }
    }
    , [y, m, p, f])
      , k = T.useCallback(A => {
        let {active: O, selected: B} = A;
        const z = {
            role: "option",
            ...O && {
                id: m + "-fui-option"
            }
        };
        switch (f) {
        case "select":
        case "combobox":
            return {
                ...z,
                "aria-selected": B
            }
        }
        return {}
    }
    , [m, f]);
    return T.useMemo( () => u ? {
        reference: S,
        floating: w,
        item: k
    } : {}, [u, S, w, k])
}
function RL({initialOpen: t=!1, placement: e="top", open: n, onOpenChange: r, delay: o=600, closeDelay: l=0}={}) {
    const [a,u] = T.useState(t)
      , f = n ?? a
      , h = r ?? u
      , p = TL({
        placement: e,
        open: f,
        onOpenChange: h,
        whileElementsMounted: _4,
        middleware: [H4(4), V4({
            crossAxis: e.includes("-"),
            fallbackAxisSideDirection: "start",
            padding: 4
        }), I4({
            padding: 4
        })]
    })
      , m = p.context
      , y = hL(m, {
        mouseOnly: !0,
        move: !1,
        restMs: o,
        enabled: n == null,
        delay: {
            close: l
        }
    })
      , b = kL(m, {
        enabled: n == null
    })
      , C = wL(m)
      , S = NL(m, {
        role: "tooltip"
    })
      , w = ML([y, b, C, S]);
    return T.useMemo( () => ({
        open: f,
        setOpen: h,
        ...w,
        ...p
    }), [f, h, w, p])
}
const s1 = T.createContext(null);
function q4() {
    const t = T.useContext(s1);
    if (t == null)
        throw new Error("Tooltip components must be wrapped in <TooltipProvider />");
    return t
}
function $4({children: t, ...e}) {
    const n = RL(e);
    return e.useDelayGroup ? E.jsx(mL, {
        delay: {
            open: e.delay ?? 0,
            close: e.closeDelay ?? 0
        },
        timeoutMs: e.timeout,
        children: E.jsx(s1.Provider, {
            value: n,
            children: t
        })
    }) : E.jsx(s1.Provider, {
        value: n,
        children: t
    })
}
const F4 = T.forwardRef(function({children: e, asChild: n=!1, ...r}, o) {
    const l = q4()
      , a = T.isValidElement(e) ? parseInt(T.version, 10) >= 19 ? e.props.ref : e.ref : void 0
      , u = U4([l.refs.setReference, o, a]);
    if (n && T.isValidElement(e)) {
        const f = {
            "data-tooltip-state": l.open ? "open" : "closed"
        };
        return T.cloneElement(e, l.getReferenceProps({
            ref: u,
            ...r,
            ...typeof e.props == "object" ? e.props : {},
            ...f
        }))
    }
    return E.jsx("button", {
        ref: u,
        "data-tooltip-state": l.open ? "open" : "closed",
        ...l.getReferenceProps(r),
        children: e
    })
})
  , K4 = T.forwardRef(function({style: e, children: n, portal: r=!0, portalProps: o={}, ...l}, a) {
    const u = q4()
      , f = U4([u.refs.setFloating, a]);
    if (!u.open)
        return null;
    const h = E.jsx("div", {
        ref: f,
        style: {
            ...u.floatingStyles,
            ...e
        },
        ...u.getFloatingProps(l),
        className: "tiptap-tooltip",
        children: n
    });
    return r ? E.jsx(bL, {
        ...o,
        children: h
    }) : h
});
$4.displayName = "Tooltip";
F4.displayName = "TooltipTrigger";
K4.displayName = "TooltipContent";
const OL = ({shortcuts: t}) => t.length === 0 ? null : E.jsx("div", {
    children: t.map( (e, n) => E.jsxs(T.Fragment, {
        children: [n > 0 && E.jsx("kbd", {
            children: "+"
        }), E.jsx("kbd", {
            children: e
        })]
    }, n))
})
  , Bt = T.forwardRef( ({className: t, children: e, tooltip: n, showTooltip: r=!0, shortcutKeys: o, "aria-label": l, ...a}, u) => {
    const f = T.useMemo( () => No({
        shortcutKeys: o
    }), [o]);
    return !n || !r ? E.jsx("button", {
        className: It("tiptap-button", t),
        ref: u,
        "aria-label": l,
        ...a,
        children: e
    }) : E.jsxs($4, {
        delay: 200,
        children: [E.jsx(F4, {
            className: It("tiptap-button", t),
            ref: u,
            "aria-label": l,
            ...a,
            children: e
        }), E.jsxs(K4, {
            children: [n, E.jsx(OL, {
                shortcuts: f
            })]
        })]
    })
}
);
Bt.displayName = "Button";
const a1 = T.forwardRef( ({className: t, children: e, orientation: n="vertical", ...r}, o) => E.jsx("div", {
    ref: o,
    className: It("tiptap-button-group", t),
    "data-orientation": n,
    role: "group",
    ...r,
    children: e
}));
a1.displayName = "ButtonGroup";
const Oo = T.forwardRef( ({variant: t, size: e="default", appearance: n="default", trimText: r=!1, className: o, children: l, ...a}, u) => E.jsx("div", {
    ref: u,
    className: `tiptap-badge ${o || ""}`,
    "data-style": t,
    "data-size": e,
    "data-appearance": n,
    "data-text-trim": r ? "on" : "off",
    ...a,
    children: l
}));
Oo.displayName = "Badge";
function Vt(t) {
    const {editor: e} = s8()
      , n = T.useMemo( () => t || e, [t, e]);
    return O3({
        editor: n,
        selector(o) {
            return o.editor ? {
                editor: o.editor,
                editorState: o.editor.state,
                canCommand: o.editor.can
            } : {
                editor: null,
                editorState: void 0,
                canCommand: void 0
            }
        }
    }) || {
        editor: null
    }
}
function DL({level: t, shortcutKeys: e=Q4[t]}) {
    return E.jsx(Oo, {
        children: No({
            shortcutKeys: e
        })
    })
}
const Ws = T.forwardRef( ({editor: t, level: e, text: n, hideWhenUnavailable: r=!1, onToggled: o, showShortcut: l=!1, onClick: a, children: u, ...f}, h) => {
    const {editor: p} = Vt(t)
      , {isVisible: m, canToggle: y, isActive: b, handleToggle: C, label: S, Icon: w, shortcutKeys: k} = jL({
        editor: p,
        level: e,
        hideWhenUnavailable: r,
        onToggled: o
    })
      , A = T.useCallback(O => {
        a?.(O),
        !O.defaultPrevented && C()
    }
    , [C, a]);
    return m ? E.jsx(Bt, {
        type: "button",
        "data-style": "ghost",
        "data-active-state": b ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !y,
        "data-disabled": !y,
        "aria-label": S,
        "aria-pressed": b,
        tooltip: S,
        onClick: A,
        ...f,
        ref: h,
        children: u ?? E.jsxs(E.Fragment, {
            children: [E.jsx(w, {
                className: "tiptap-button-icon"
            }), n && E.jsx("span", {
                className: "tiptap-button-text",
                children: n
            }), l && E.jsx(DL, {
                level: e,
                shortcutKeys: k
            })]
        })
    }) : null
}
);
Ws.displayName = "HeadingButton";
const G4 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M21.0001 10C21.0001 9.63121 20.7971 9.29235 20.472 9.11833C20.1468 8.94431 19.7523 8.96338 19.4454 9.16795L16.4454 11.168C15.9859 11.4743 15.8617 12.0952 16.1681 12.5547C16.4744 13.0142 17.0953 13.1384 17.5548 12.8321L19.0001 11.8685V18C19.0001 18.5523 19.4478 19 20.0001 19C20.5524 19 21.0001 18.5523 21.0001 18V10Z",
        fill: "currentColor"
    })]
}));
G4.displayName = "HeadingOneIcon";
const Y4 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M22.0001 12C22.0001 10.7611 21.1663 9.79297 20.0663 9.42632C18.9547 9.05578 17.6171 9.28724 16.4001 10.2C15.9582 10.5314 15.8687 11.1582 16.2001 11.6C16.5314 12.0418 17.1582 12.1314 17.6001 11.8C18.383 11.2128 19.0455 11.1942 19.4338 11.3237C19.8339 11.457 20.0001 11.7389 20.0001 12C20.0001 12.4839 19.8554 12.7379 19.6537 12.9481C19.4275 13.1837 19.1378 13.363 18.7055 13.6307C18.6313 13.6767 18.553 13.7252 18.4701 13.777C17.9572 14.0975 17.3128 14.5261 16.8163 15.2087C16.3007 15.9177 16.0001 16.8183 16.0001 18C16.0001 18.5523 16.4478 19 17.0001 19H21.0001C21.5523 19 22.0001 18.5523 22.0001 18C22.0001 17.4477 21.5523 17 21.0001 17H18.131C18.21 16.742 18.3176 16.5448 18.4338 16.385C18.6873 16.0364 19.0429 15.7775 19.5301 15.473C19.5898 15.4357 19.6536 15.3966 19.7205 15.3556C20.139 15.0992 20.6783 14.7687 21.0964 14.3332C21.6447 13.7621 22.0001 13.0161 22.0001 12Z",
        fill: "currentColor"
    })]
}));
Y4.displayName = "HeadingTwoIcon";
const Z4 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M4 5C4.55228 5 5 5.44772 5 6V11H11V6C11 5.44772 11.4477 5 12 5C12.5523 5 13 5.44772 13 6V18C13 18.5523 12.5523 19 12 19C11.4477 19 11 18.5523 11 18V13H5V18C5 18.5523 4.55228 19 4 19C3.44772 19 3 18.5523 3 18V6C3 5.44772 3.44772 5 4 5Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M19.4608 11.2169C19.1135 11.0531 18.5876 11.0204 18.0069 11.3619C17.5309 11.642 16.918 11.4831 16.638 11.007C16.358 10.531 16.5169 9.91809 16.9929 9.63807C18.1123 8.97962 19.3364 8.94691 20.314 9.40808C21.2839 9.86558 21.9999 10.818 21.9999 12C21.9999 12.7957 21.6838 13.5587 21.1212 14.1213C20.5586 14.6839 19.7956 15 18.9999 15C18.4476 15 17.9999 14.5523 17.9999 14C17.9999 13.4477 18.4476 13 18.9999 13C19.2651 13 19.5195 12.8947 19.707 12.7071C19.8946 12.5196 19.9999 12.2652 19.9999 12C19.9999 11.6821 19.8159 11.3844 19.4608 11.2169Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M18.0001 14C18.0001 13.4477 18.4478 13 19.0001 13C19.7957 13 20.5588 13.3161 21.1214 13.8787C21.684 14.4413 22.0001 15.2043 22.0001 16C22.0001 17.2853 21.2767 18.3971 20.1604 18.8994C19.0257 19.41 17.642 19.2315 16.4001 18.3C15.9582 17.9686 15.8687 17.3418 16.2001 16.9C16.5314 16.4582 17.1582 16.3686 17.6001 16.7C18.3581 17.2685 18.9744 17.24 19.3397 17.0756C19.7234 16.9029 20.0001 16.5147 20.0001 16C20.0001 15.7348 19.8947 15.4804 19.7072 15.2929C19.5196 15.1054 19.2653 15 19.0001 15C18.4478 15 18.0001 14.5523 18.0001 14Z",
        fill: "currentColor"
    })]
}));
Z4.displayName = "HeadingThreeIcon";
const W4 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M4 5C4.55228 5 5 5.44772 5 6V11H11V6C11 5.44772 11.4477 5 12 5C12.5523 5 13 5.44772 13 6V18C13 18.5523 12.5523 19 12 19C11.4477 19 11 18.5523 11 18V13H5V18C5 18.5523 4.55228 19 4 19C3.44772 19 3 18.5523 3 18V6C3 5.44772 3.44772 5 4 5Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M17 9C17.5523 9 18 9.44772 18 10V13H20V10C20 9.44772 20.4477 9 21 9C21.5523 9 22 9.44772 22 10V18C22 18.5523 21.5523 19 21 19C20.4477 19 20 18.5523 20 18V15H17C16.4477 15 16 14.5523 16 14V10C16 9.44772 16.4477 9 17 9Z",
        fill: "currentColor"
    })]
}));
W4.displayName = "HeadingFourIcon";
const X4 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M16 10C16 9.44772 16.4477 9 17 9H21C21.5523 9 22 9.44772 22 10C22 10.5523 21.5523 11 21 11H18V12H18.3C20.2754 12 22 13.4739 22 15.5C22 17.5261 20.2754 19 18.3 19C17.6457 19 17.0925 18.8643 16.5528 18.5944C16.0588 18.3474 15.8586 17.7468 16.1055 17.2528C16.3525 16.7588 16.9532 16.5586 17.4472 16.8056C17.7074 16.9357 17.9542 17 18.3 17C19.3246 17 20 16.2739 20 15.5C20 14.7261 19.3246 14 18.3 14H17C16.4477 14 16 13.5523 16 13L16 12.9928V10Z",
        fill: "currentColor"
    })]
}));
X4.displayName = "HeadingFiveIcon";
const J4 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M5 6C5 5.44772 4.55228 5 4 5C3.44772 5 3 5.44772 3 6V18C3 18.5523 3.44772 19 4 19C4.55228 19 5 18.5523 5 18V13H11V18C11 18.5523 11.4477 19 12 19C12.5523 19 13 18.5523 13 18V6C13 5.44772 12.5523 5 12 5C11.4477 5 11 5.44772 11 6V11H5V6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M20.7071 9.29289C21.0976 9.68342 21.0976 10.3166 20.7071 10.7071C19.8392 11.575 19.2179 12.2949 18.7889 13.0073C18.8587 13.0025 18.929 13 19 13C20.6569 13 22 14.3431 22 16C22 17.6569 20.6569 19 19 19C17.3431 19 16 17.6569 16 16C16 14.6007 16.2837 13.4368 16.8676 12.3419C17.4384 11.2717 18.2728 10.3129 19.2929 9.29289C19.6834 8.90237 20.3166 8.90237 20.7071 9.29289ZM19 17C18.4477 17 18 16.5523 18 16C18 15.4477 18.4477 15 19 15C19.5523 15 20 15.4477 20 16C20 16.5523 19.5523 17 19 17Z",
        fill: "currentColor"
    })]
}));
J4.displayName = "HeadingSixIcon";
const LL = {
    1: G4,
    2: Y4,
    3: Z4,
    4: W4,
    5: X4,
    6: J4
}
  , Q4 = {
    1: "ctrl+alt+1",
    2: "ctrl+alt+2",
    3: "ctrl+alt+3",
    4: "ctrl+alt+4",
    5: "ctrl+alt+5",
    6: "ctrl+alt+6"
};
function Tf(t, e, n=!0) {
    return !t || !t.isEditable || !_i("heading", t) || Ro(t, ["image"]) ? !1 : n ? Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) ? e ? t.can().setNode("heading", {
        level: e
    }) || t.can().clearNodes() : t.can().setNode("heading") || t.can().clearNodes() : !1 : e ? t.can().setNode("heading", {
        level: e
    }) : t.can().setNode("heading")
}
function zL(t, e) {
    return !t || !t.isEditable ? !1 : Array.isArray(e) ? e.some(n => t.isActive("heading", {
        level: n
    })) : e ? t.isActive("heading", {
        level: e
    }) : t.isActive("heading")
}
function _L(t, e) {
    if (!t || !t.isEditable)
        return !1;
    const n = Array.isArray(e) ? e : [e]
      , r = n.find(o => Tf(t, o));
    if (!r)
        return !1;
    try {
        const o = t.view;
        let l = o.state
          , a = l.tr;
        const u = Ff(t)
          , f = Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) && u.length === 1;
        if ((l.selection.empty || l.selection instanceof se) && f) {
            const b = $f({
                editor: t,
                node: l.selection.$anchor.node(1)
            })?.pos;
            if (!ka(b))
                return !1;
            a = a.setSelection(le.create(l.doc, b)),
            o.dispatch(a),
            l = o.state
        }
        const h = l.selection;
        let p = t.chain().focus();
        if (h instanceof le) {
            const b = h.node.firstChild?.firstChild
              , C = h.node.lastChild?.lastChild
              , S = b ? h.from + b.nodeSize : h.from + 1
              , w = C ? h.to - C.nodeSize : h.to - 1
              , k = l.doc.resolve(S)
              , A = l.doc.resolve(w);
            p = p.setTextSelection(se.between(k, A)).clearNodes()
        }
        return (n.some(b => t.isActive("heading", {
            level: b
        })) ? p.setNode("paragraph") : p.setNode("heading", {
            level: r
        })).run(),
        t.chain().focus().selectTextblockEnd().run(),
        !0
    } catch {
        return !1
    }
}
function BL(t) {
    const {editor: e, level: n, hideWhenUnavailable: r} = t;
    return !e || !e.isEditable || !_i("heading", e) ? !1 : r && !e.isActive("code") ? Array.isArray(n) ? n.some(o => Tf(e, o)) : Tf(e, n) : !0
}
function jL(t) {
    const {editor: e, level: n, hideWhenUnavailable: r=!1, onToggled: o} = t
      , {editor: l} = Vt(e)
      , [a,u] = T.useState(!0)
      , f = Tf(l, n)
      , h = zL(l, n);
    T.useEffect( () => {
        if (!l)
            return;
        const m = () => {
            u(BL({
                editor: l,
                level: n,
                hideWhenUnavailable: r
            }))
        }
        ;
        return m(),
        l.on("selectionUpdate", m),
        () => {
            l.off("selectionUpdate", m)
        }
    }
    , [l, n, r]);
    const p = T.useCallback( () => {
        if (!l)
            return !1;
        const m = _L(l, n);
        return m && o?.(),
        m
    }
    , [l, n, o]);
    return {
        isVisible: a,
        isActive: h,
        handleToggle: p,
        canToggle: f,
        label: ` ${n}`,
        shortcutKeys: Q4[n],
        Icon: LL[n]
    }
}
function HL({type: t, shortcutKeys: e=s5[t]}) {
    return E.jsx(Oo, {
        children: No({
            shortcutKeys: e
        })
    })
}
const Tl = T.forwardRef( ({editor: t, type: e, text: n, hideWhenUnavailable: r=!1, onToggled: o, showShortcut: l=!1, onClick: a, children: u, ...f}, h) => {
    const {editor: p} = Vt(t)
      , {isVisible: m, handleMark: y, label: b, canToggle: C, isActive: S, Icon: w, shortcutKeys: k} = FL({
        editor: p,
        type: e,
        hideWhenUnavailable: r,
        onToggled: o
    })
      , A = T.useCallback(O => {
        a?.(O),
        !O.defaultPrevented && y()
    }
    , [y, a]);
    return m ? E.jsx(Bt, {
        type: "button",
        disabled: !C,
        "data-style": "ghost",
        "data-active-state": S ? "on" : "off",
        "data-disabled": !C,
        role: "button",
        tabIndex: -1,
        "aria-label": b,
        "aria-pressed": S,
        tooltip: b,
        onClick: A,
        ...f,
        ref: h,
        children: u ?? E.jsxs(E.Fragment, {
            children: [E.jsx(w, {
                className: "tiptap-button-icon"
            }), n && E.jsx("span", {
                className: "tiptap-button-text",
                children: n
            }), l && E.jsx(HL, {
                type: e,
                shortcutKeys: k
            })]
        })
    }) : null
}
);
Tl.displayName = "MarkButton";
const e5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6 2.5C5.17157 2.5 4.5 3.17157 4.5 4V20C4.5 20.8284 5.17157 21.5 6 21.5H15C16.4587 21.5 17.8576 20.9205 18.8891 19.8891C19.9205 18.8576 20.5 17.4587 20.5 16C20.5 14.5413 19.9205 13.1424 18.8891 12.1109C18.6781 11.9 18.4518 11.7079 18.2128 11.5359C19.041 10.5492 19.5 9.29829 19.5 8C19.5 6.54131 18.9205 5.14236 17.8891 4.11091C16.8576 3.07946 15.4587 2.5 14 2.5H6ZM14 10.5C14.663 10.5 15.2989 10.2366 15.7678 9.76777C16.2366 9.29893 16.5 8.66304 16.5 8C16.5 7.33696 16.2366 6.70107 15.7678 6.23223C15.2989 5.76339 14.663 5.5 14 5.5H7.5V10.5H14ZM7.5 18.5V13.5H15C15.663 13.5 16.2989 13.7634 16.7678 14.2322C17.2366 14.7011 17.5 15.337 17.5 16C17.5 16.663 17.2366 17.2989 16.7678 17.7678C16.2989 18.2366 15.663 18.5 15 18.5H7.5Z",
        fill: "currentColor"
    })
}));
e5.displayName = "BoldIcon";
const t5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M15.4545 4.2983C15.6192 3.77115 15.3254 3.21028 14.7983 3.04554C14.2712 2.88081 13.7103 3.1746 13.5455 3.70175L8.54554 19.7017C8.38081 20.2289 8.6746 20.7898 9.20175 20.9545C9.72889 21.1192 10.2898 20.8254 10.4545 20.2983L15.4545 4.2983Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M6.70711 7.29289C7.09763 7.68342 7.09763 8.31658 6.70711 8.70711L3.41421 12L6.70711 15.2929C7.09763 15.6834 7.09763 16.3166 6.70711 16.7071C6.31658 17.0976 5.68342 17.0976 5.29289 16.7071L1.29289 12.7071C0.902369 12.3166 0.902369 11.6834 1.29289 11.2929L5.29289 7.29289C5.68342 6.90237 6.31658 6.90237 6.70711 7.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M17.2929 7.29289C17.6834 6.90237 18.3166 6.90237 18.7071 7.29289L22.7071 11.2929C23.0976 11.6834 23.0976 12.3166 22.7071 12.7071L18.7071 16.7071C18.3166 17.0976 17.6834 17.0976 17.2929 16.7071C16.9024 16.3166 16.9024 15.6834 17.2929 15.2929L20.5858 12L17.2929 8.70711C16.9024 8.31658 16.9024 7.68342 17.2929 7.29289Z",
        fill: "currentColor"
    })]
}));
t5.displayName = "Code2Icon";
const n5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        d: "M15.0222 3H19C19.5523 3 20 3.44772 20 4C20 4.55228 19.5523 5 19 5H15.693L10.443 19H14C14.5523 19 15 19.4477 15 20C15 20.5523 14.5523 21 14 21H9.02418C9.00802 21.0004 8.99181 21.0004 8.97557 21H5C4.44772 21 4 20.5523 4 20C4 19.4477 4.44772 19 5 19H8.30704L13.557 5H10C9.44772 5 9 4.55228 9 4C9 3.44772 9.44772 3 10 3H14.9782C14.9928 2.99968 15.0075 2.99967 15.0222 3Z",
        fill: "currentColor"
    })
}));
n5.displayName = "ItalicIcon";
const r5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M9.00039 3H16.0001C16.5524 3 17.0001 3.44772 17.0001 4C17.0001 4.55229 16.5524 5 16.0001 5H9.00011C8.68006 4.99983 8.36412 5.07648 8.07983 5.22349C7.79555 5.37051 7.55069 5.5836 7.36585 5.84487C7.181 6.10614 7.06155 6.40796 7.01754 6.72497C6.97352 7.04198 7.00623 7.36492 7.11292 7.66667C7.29701 8.18737 7.02414 8.75872 6.50344 8.94281C5.98274 9.1269 5.4114 8.85403 5.2273 8.33333C5.01393 7.72984 4.94851 7.08396 5.03654 6.44994C5.12456 5.81592 5.36346 5.21229 5.73316 4.68974C6.10285 4.1672 6.59256 3.74101 7.16113 3.44698C7.72955 3.15303 8.36047 2.99975 9.00039 3Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M18 13H20C20.5523 13 21 12.5523 21 12C21 11.4477 20.5523 11 20 11H4C3.44772 11 3 11.4477 3 12C3 12.5523 3.44772 13 4 13H14C14.7956 13 15.5587 13.3161 16.1213 13.8787C16.6839 14.4413 17 15.2044 17 16C17 16.7956 16.6839 17.5587 16.1213 18.1213C15.5587 18.6839 14.7956 19 14 19H6C5.44772 19 5 19.4477 5 20C5 20.5523 5.44772 21 6 21H14C15.3261 21 16.5979 20.4732 17.5355 19.5355C18.4732 18.5979 19 17.3261 19 16C19 14.9119 18.6453 13.8604 18 13Z",
        fill: "currentColor"
    })]
}));
r5.displayName = "StrikeIcon";
const i5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M3.29289 7.29289C3.68342 6.90237 4.31658 6.90237 4.70711 7.29289L12.7071 15.2929C13.0976 15.6834 13.0976 16.3166 12.7071 16.7071C12.3166 17.0976 11.6834 17.0976 11.2929 16.7071L3.29289 8.70711C2.90237 8.31658 2.90237 7.68342 3.29289 7.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12.7071 7.29289C13.0976 7.68342 13.0976 8.31658 12.7071 8.70711L4.70711 16.7071C4.31658 17.0976 3.68342 17.0976 3.29289 16.7071C2.90237 16.3166 2.90237 15.6834 3.29289 15.2929L11.2929 7.29289C11.6834 6.90237 12.3166 6.90237 12.7071 7.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M17.4079 14.3995C18.0284 14.0487 18.7506 13.9217 19.4536 14.0397C20.1566 14.1578 20.7977 14.5138 21.2696 15.0481L21.2779 15.0574L21.2778 15.0575C21.7439 15.5988 22 16.2903 22 17C22 18.0823 21.3962 18.8401 20.7744 19.3404C20.194 19.8073 19.4858 20.141 18.9828 20.378C18.9638 20.387 18.9451 20.3958 18.9266 20.4045C18.4473 20.6306 18.2804 20.7817 18.1922 20.918C18.1773 20.9412 18.1619 20.9681 18.1467 21H21C21.5523 21 22 21.4477 22 22C22 22.5523 21.5523 23 21 23H17C16.4477 23 16 22.5523 16 22C16 21.1708 16.1176 20.4431 16.5128 19.832C16.9096 19.2184 17.4928 18.8695 18.0734 18.5956C18.6279 18.334 19.138 18.0901 19.5207 17.7821C19.8838 17.49 20 17.2477 20 17C20 16.7718 19.9176 16.5452 19.7663 16.3672C19.5983 16.1792 19.3712 16.0539 19.1224 16.0121C18.8722 15.9701 18.6152 16.015 18.3942 16.1394C18.1794 16.2628 18.0205 16.4549 17.9422 16.675C17.7572 17.1954 17.1854 17.4673 16.665 17.2822C16.1446 17.0972 15.8728 16.5254 16.0578 16.005C16.2993 15.3259 16.7797 14.7584 17.4039 14.4018L17.4079 14.3995L17.4079 14.3995Z",
        fill: "currentColor"
    })]
}));
i5.displayName = "SubscriptIcon";
const o5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12.7071 7.29289C13.0976 7.68342 13.0976 8.31658 12.7071 8.70711L4.70711 16.7071C4.31658 17.0976 3.68342 17.0976 3.29289 16.7071C2.90237 16.3166 2.90237 15.6834 3.29289 15.2929L11.2929 7.29289C11.6834 6.90237 12.3166 6.90237 12.7071 7.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M3.29289 7.29289C3.68342 6.90237 4.31658 6.90237 4.70711 7.29289L12.7071 15.2929C13.0976 15.6834 13.0976 16.3166 12.7071 16.7071C12.3166 17.0976 11.6834 17.0976 11.2929 16.7071L3.29289 8.70711C2.90237 8.31658 2.90237 7.68342 3.29289 7.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M17.405 1.40657C18.0246 1.05456 18.7463 0.92634 19.4492 1.04344C20.1521 1.16054 20.7933 1.51583 21.2652 2.0497L21.2697 2.05469L21.2696 2.05471C21.7431 2.5975 22 3.28922 22 4.00203C22 5.08579 21.3952 5.84326 20.7727 6.34289C20.1966 6.80531 19.4941 7.13675 18.9941 7.37261C18.9714 7.38332 18.9491 7.39383 18.9273 7.40415C18.4487 7.63034 18.2814 7.78152 18.1927 7.91844C18.1778 7.94155 18.1625 7.96834 18.1473 8.00003H21C21.5523 8.00003 22 8.44774 22 9.00003C22 9.55231 21.5523 10 21 10H17C16.4477 10 16 9.55231 16 9.00003C16 8.17007 16.1183 7.44255 16.5138 6.83161C16.9107 6.21854 17.4934 5.86971 18.0728 5.59591C18.6281 5.33347 19.1376 5.09075 19.5208 4.78316C19.8838 4.49179 20 4.25026 20 4.00203C20 3.77192 19.9178 3.54865 19.7646 3.37182C19.5968 3.18324 19.3696 3.05774 19.1205 3.01625C18.8705 2.97459 18.6137 3.02017 18.3933 3.14533C18.1762 3.26898 18.0191 3.45826 17.9406 3.67557C17.7531 4.19504 17.18 4.46414 16.6605 4.27662C16.141 4.0891 15.8719 3.51596 16.0594 2.99649C16.303 2.3219 16.7817 1.76125 17.4045 1.40689L17.405 1.40657Z",
        fill: "currentColor"
    })]
}));
o5.displayName = "SuperscriptIcon";
const l5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7 4C7 3.44772 6.55228 3 6 3C5.44772 3 5 3.44772 5 4V10C5 11.8565 5.7375 13.637 7.05025 14.9497C8.36301 16.2625 10.1435 17 12 17C13.8565 17 15.637 16.2625 16.9497 14.9497C18.2625 13.637 19 11.8565 19 10V4C19 3.44772 18.5523 3 18 3C17.4477 3 17 3.44772 17 4V10C17 11.3261 16.4732 12.5979 15.5355 13.5355C14.5979 14.4732 13.3261 15 12 15C10.6739 15 9.40215 14.4732 8.46447 13.5355C7.52678 12.5979 7 11.3261 7 10V4ZM4 19C3.44772 19 3 19.4477 3 20C3 20.5523 3.44772 21 4 21H20C20.5523 21 21 20.5523 21 20C21 19.4477 20.5523 19 20 19H4Z",
        fill: "currentColor"
    })
}));
l5.displayName = "UnderlineIcon";
const IL = {
    bold: e5,
    italic: n5,
    underline: l5,
    strike: r5,
    code: t5,
    superscript: o5,
    subscript: i5
}
  , s5 = {
    bold: "mod+b",
    italic: "mod+i",
    underline: "mod+u",
    strike: "mod+shift+s",
    code: "mod+e",
    superscript: "mod+.",
    subscript: "mod+,"
};
function gg(t, e) {
    return !t || !t.isEditable || !og(e, t) || Ro(t, ["image"]) ? !1 : t.can().toggleMark(e)
}
function VL(t, e) {
    return !t || !t.isEditable ? !1 : t.isActive(e)
}
function UL(t, e) {
    return !t || !t.isEditable || !gg(t, e) ? !1 : t.chain().focus().toggleMark(e).run()
}
function PL(t) {
    const {editor: e, type: n, hideWhenUnavailable: r} = t;
    return !e || !e.isEditable || !og(n, e) ? !1 : r && !e.isActive("code") ? gg(e, n) : !0
}
const qL = {
    bold: "",
    italic: "",
    underline: "",
    strike: "",
    code: "",
    superscript: "",
    subscript: ""
};
function $L(t) {
    return qL[t]
}
function FL(t) {
    const {editor: e, type: n, hideWhenUnavailable: r=!1, onToggled: o} = t
      , {editor: l} = Vt(e)
      , [a,u] = T.useState(!0)
      , f = gg(l, n)
      , h = VL(l, n);
    T.useEffect( () => {
        if (!l)
            return;
        const m = () => {
            u(PL({
                editor: l,
                type: n,
                hideWhenUnavailable: r
            }))
        }
        ;
        return m(),
        l.on("selectionUpdate", m),
        () => {
            l.off("selectionUpdate", m)
        }
    }
    , [l, n, r]);
    const p = T.useCallback( () => {
        if (!l)
            return !1;
        const m = UL(l, n);
        return m && o?.(),
        m
    }
    , [l, n, o]);
    return {
        isVisible: a,
        isActive: h,
        handleMark: p,
        canToggle: f,
        label: $L(n),
        shortcutKeys: s5[n],
        Icon: IL[n]
    }
}
function KL({type: t, shortcutKeys: e=f5[t]}) {
    return E.jsx(Oo, {
        children: No({
            shortcutKeys: e
        })
    })
}
const c1 = T.forwardRef( ({editor: t, type: e, text: n, hideWhenUnavailable: r=!1, onToggled: o, showShortcut: l=!1, onClick: a, children: u, ...f}, h) => {
    const {editor: p} = Vt(t)
      , {isVisible: m, canToggle: y, isActive: b, handleToggle: C, label: S, shortcutKeys: w, Icon: k} = JL({
        editor: p,
        type: e,
        hideWhenUnavailable: r,
        onToggled: o
    })
      , A = T.useCallback(O => {
        a?.(O),
        !O.defaultPrevented && C()
    }
    , [C, a]);
    return m ? E.jsx(Bt, {
        type: "button",
        "data-style": "ghost",
        "data-active-state": b ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !y,
        "data-disabled": !y,
        "aria-label": S,
        "aria-pressed": b,
        tooltip: S,
        onClick: A,
        ...f,
        ref: h,
        children: u ?? E.jsxs(E.Fragment, {
            children: [E.jsx(k, {
                className: "tiptap-button-icon"
            }), n && E.jsx("span", {
                className: "tiptap-button-text",
                children: n
            }), l && E.jsx(KL, {
                type: e,
                shortcutKeys: w
            })]
        })
    }) : null
}
);
c1.displayName = "ListButton";
const a5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7 6C7 5.44772 7.44772 5 8 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H8C7.44772 7 7 6.55228 7 6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7 12C7 11.4477 7.44772 11 8 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H8C7.44772 13 7 12.5523 7 12Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7 18C7 17.4477 7.44772 17 8 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H8C7.44772 19 7 18.5523 7 18Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2 6C2 5.44772 2.44772 5 3 5H3.01C3.56228 5 4.01 5.44772 4.01 6C4.01 6.55228 3.56228 7 3.01 7H3C2.44772 7 2 6.55228 2 6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2 12C2 11.4477 2.44772 11 3 11H3.01C3.56228 11 4.01 11.4477 4.01 12C4.01 12.5523 3.56228 13 3.01 13H3C2.44772 13 2 12.5523 2 12Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2 18C2 17.4477 2.44772 17 3 17H3.01C3.56228 17 4.01 17.4477 4.01 18C4.01 18.5523 3.56228 19 3.01 19H3C2.44772 19 2 18.5523 2 18Z",
        fill: "currentColor"
    })]
}));
a5.displayName = "ListIcon";
const c5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9 6C9 5.44772 9.44772 5 10 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H10C9.44772 7 9 6.55228 9 6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9 12C9 11.4477 9.44772 11 10 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H10C9.44772 13 9 12.5523 9 12Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9 18C9 17.4477 9.44772 17 10 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H10C9.44772 19 9 18.5523 9 18Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M3 6C3 5.44772 3.44772 5 4 5H5C5.55228 5 6 5.44772 6 6V10C6 10.5523 5.55228 11 5 11C4.44772 11 4 10.5523 4 10V7C3.44772 7 3 6.55228 3 6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M3 10C3 9.44772 3.44772 9 4 9H6C6.55228 9 7 9.44772 7 10C7 10.5523 6.55228 11 6 11H4C3.44772 11 3 10.5523 3 10Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M5.82219 13.0431C6.54543 13.4047 6.99997 14.1319 6.99997 15C6.99997 15.5763 6.71806 16.0426 6.48747 16.35C6.31395 16.5814 6.1052 16.8044 5.91309 17H5.99997C6.55226 17 6.99997 17.4477 6.99997 18C6.99997 18.5523 6.55226 19 5.99997 19H3.99997C3.44769 19 2.99997 18.5523 2.99997 18C2.99997 17.4237 3.28189 16.9575 3.51247 16.65C3.74323 16.3424 4.03626 16.0494 4.26965 15.8161C4.27745 15.8083 4.2852 15.8006 4.29287 15.7929C4.55594 15.5298 4.75095 15.3321 4.88748 15.15C4.96287 15.0495 4.99021 14.9922 4.99911 14.9714C4.99535 14.9112 4.9803 14.882 4.9739 14.8715C4.96613 14.8588 4.95382 14.845 4.92776 14.8319C4.87723 14.8067 4.71156 14.7623 4.44719 14.8944C3.95321 15.1414 3.35254 14.9412 3.10555 14.4472C2.85856 13.9533 3.05878 13.3526 3.55276 13.1056C4.28839 12.7378 5.12272 12.6934 5.82219 13.0431Z",
        fill: "currentColor"
    })]
}));
c5.displayName = "ListOrderedIcon";
const u5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M2 6C2 4.89543 2.89543 4 4 4H8C9.10457 4 10 4.89543 10 6V10C10 11.1046 9.10457 12 8 12H4C2.89543 12 2 11.1046 2 10V6ZM8 6H4V10H8V6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.70711 14.2929C10.0976 14.6834 10.0976 15.3166 9.70711 15.7071L5.70711 19.7071C5.31658 20.0976 4.68342 20.0976 4.29289 19.7071L2.29289 17.7071C1.90237 17.3166 1.90237 16.6834 2.29289 16.2929C2.68342 15.9024 3.31658 15.9024 3.70711 16.2929L5 17.5858L8.29289 14.2929C8.68342 13.9024 9.31658 13.9024 9.70711 14.2929Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12 6C12 5.44772 12.4477 5 13 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H13C12.4477 7 12 6.55228 12 6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12 12C12 11.4477 12.4477 11 13 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H13C12.4477 13 12 12.5523 12 12Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12 18C12 17.4477 12.4477 17 13 17H21C21.5523 17 22 17.4477 22 18C22 18.5523 21.5523 19 21 19H13C12.4477 19 12 18.5523 12 18Z",
        fill: "currentColor"
    })]
}));
u5.displayName = "ListTodoIcon";
const GL = {
    bulletList: a5,
    orderedList: c5,
    taskList: u5
}
  , YL = {
    bulletList: " ",
    orderedList: " ",
    taskList: " "
}
  , f5 = {
    bulletList: "mod+shift+8",
    orderedList: "mod+shift+7",
    taskList: "mod+shift+9"
};
function yg(t, e, n=!0) {
    if (!t || !t.isEditable || !_i(e, t) || Ro(t, ["image"]))
        return !1;
    if (!n)
        switch (e) {
        case "bulletList":
            return t.can().toggleBulletList();
        case "orderedList":
            return t.can().toggleOrderedList();
        case "taskList":
            return t.can().toggleList("taskList", "taskItem");
        default:
            return !1
        }
    if (!Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]))
        return !1;
    switch (e) {
    case "bulletList":
        return t.can().toggleBulletList() || t.can().clearNodes();
    case "orderedList":
        return t.can().toggleOrderedList() || t.can().clearNodes();
    case "taskList":
        return t.can().toggleList("taskList", "taskItem") || t.can().clearNodes();
    default:
        return !1
    }
}
function ZL(t, e) {
    if (!t || !t.isEditable)
        return !1;
    switch (e) {
    case "bulletList":
        return t.isActive("bulletList");
    case "orderedList":
        return t.isActive("orderedList");
    case "taskList":
        return t.isActive("taskList");
    default:
        return !1
    }
}
function WL(t, e) {
    if (!t || !t.isEditable || !yg(t, e))
        return !1;
    try {
        const n = t.view;
        let r = n.state
          , o = r.tr;
        const l = Ff(t)
          , a = Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) && l.length === 1;
        if ((r.selection.empty || r.selection instanceof se) && a) {
            const h = $f({
                editor: t,
                node: r.selection.$anchor.node(1)
            })?.pos;
            if (!ka(h))
                return !1;
            o = o.setSelection(le.create(r.doc, h)),
            n.dispatch(o),
            r = n.state
        }
        const u = r.selection;
        let f = t.chain().focus();
        if (u instanceof le) {
            const h = u.node.firstChild?.firstChild
              , p = u.node.lastChild?.lastChild
              , m = h ? u.from + h.nodeSize : u.from + 1
              , y = p ? u.to - p.nodeSize : u.to - 1
              , b = r.doc.resolve(m)
              , C = r.doc.resolve(y);
            f = f.setTextSelection(se.between(b, C)).clearNodes()
        }
        if (t.isActive(e))
            f.liftListItem("listItem").lift("bulletList").lift("orderedList").lift("taskList").run();
        else {
            const p = {
                bulletList: () => f.toggleBulletList(),
                orderedList: () => f.toggleOrderedList(),
                taskList: () => f.toggleList("taskList", "taskItem")
            }[e];
            if (!p)
                return !1;
            p().run()
        }
        return t.chain().focus().selectTextblockEnd().run(),
        !0
    } catch {
        return !1
    }
}
function XL(t) {
    const {editor: e, type: n, hideWhenUnavailable: r} = t;
    return !e || !e.isEditable || !_i(n, e) ? !1 : r && !e.isActive("code") ? yg(e, n) : !0
}
function JL(t) {
    const {editor: e, type: n, hideWhenUnavailable: r=!1, onToggled: o} = t
      , {editor: l} = Vt(e)
      , [a,u] = T.useState(!0)
      , f = yg(l, n)
      , h = ZL(l, n);
    T.useEffect( () => {
        if (!l)
            return;
        const m = () => {
            u(XL({
                editor: l,
                type: n,
                hideWhenUnavailable: r
            }))
        }
        ;
        return m(),
        l.on("selectionUpdate", m),
        () => {
            l.off("selectionUpdate", m)
        }
    }
    , [l, n, r]);
    const p = T.useCallback( () => {
        if (!l)
            return !1;
        const m = WL(l, n);
        return m && o?.(),
        m
    }
    , [l, n, o]);
    return {
        isVisible: a,
        isActive: h,
        handleToggle: p,
        canToggle: f,
        label: YL[n],
        shortcutKeys: f5[n],
        Icon: GL[n]
    }
}
function QL({shortcutKeys: t=p5}) {
    return E.jsx(Oo, {
        children: No({
            shortcutKeys: t
        })
    })
}
const d5 = T.forwardRef( ({editor: t, text: e, hideWhenUnavailable: n=!1, onToggled: r, showShortcut: o=!1, onClick: l, children: a, ...u}, f) => {
    const {editor: h} = Vt(t)
      , {isVisible: p, canToggle: m, isActive: y, handleToggle: b, label: C, shortcutKeys: S, Icon: w} = nz({
        editor: h,
        hideWhenUnavailable: n,
        onToggled: r
    })
      , k = T.useCallback(A => {
        l?.(A),
        !A.defaultPrevented && b()
    }
    , [b, l]);
    return p ? E.jsx(Bt, {
        type: "button",
        "data-style": "ghost",
        "data-active-state": y ? "on" : "off",
        role: "button",
        tabIndex: -1,
        disabled: !m,
        "data-disabled": !m,
        "aria-label": C,
        "aria-pressed": y,
        tooltip: "",
        onClick: k,
        ...u,
        ref: f,
        children: a ?? E.jsxs(E.Fragment, {
            children: [E.jsx(w, {
                className: "tiptap-button-icon"
            }), e && E.jsx("span", {
                className: "tiptap-button-text",
                children: e
            }), o && E.jsx(QL, {
                shortcutKeys: S
            })]
        })
    }) : null
}
);
d5.displayName = "BlockquoteButton";
const h5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M8 6C8 5.44772 8.44772 5 9 5H16C16.5523 5 17 5.44772 17 6C17 6.55228 16.5523 7 16 7H9C8.44772 7 8 6.55228 8 6Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M4 3C4.55228 3 5 3.44772 5 4L5 20C5 20.5523 4.55229 21 4 21C3.44772 21 3 20.5523 3 20L3 4C3 3.44772 3.44772 3 4 3Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M8 12C8 11.4477 8.44772 11 9 11H20C20.5523 11 21 11.4477 21 12C21 12.5523 20.5523 13 20 13H9C8.44772 13 8 12.5523 8 12Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M8 18C8 17.4477 8.44772 17 9 17H16C16.5523 17 17 17.4477 17 18C17 18.5523 16.5523 19 16 19H9C8.44772 19 8 18.5523 8 18Z",
        fill: "currentColor"
    })]
}));
h5.displayName = "BlockquoteIcon";
const p5 = "mod+shift+b";
function vg(t, e=!0) {
    return !t || !t.isEditable || !_i("blockquote", t) || Ro(t, ["image"]) ? !1 : e ? Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) ? t.can().toggleWrap("blockquote") || t.can().clearNodes() : !1 : t.can().toggleWrap("blockquote")
}
function ez(t) {
    if (!t || !t.isEditable || !vg(t))
        return !1;
    try {
        const e = t.view;
        let n = e.state
          , r = n.tr;
        const o = Ff(t)
          , l = Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) && o.length === 1;
        if ((n.selection.empty || n.selection instanceof se) && l) {
            const h = $f({
                editor: t,
                node: n.selection.$anchor.node(1)
            })?.pos;
            if (!ka(h))
                return !1;
            r = r.setSelection(le.create(n.doc, h)),
            e.dispatch(r),
            n = e.state
        }
        const a = n.selection;
        let u = t.chain().focus();
        if (a instanceof le) {
            const h = a.node.firstChild?.firstChild
              , p = a.node.lastChild?.lastChild
              , m = h ? a.from + h.nodeSize : a.from + 1
              , y = p ? a.to - p.nodeSize : a.to - 1
              , b = n.doc.resolve(m)
              , C = n.doc.resolve(y);
            u = u.setTextSelection(se.between(b, C)).clearNodes()
        }
        return (t.isActive("blockquote") ? u.lift("blockquote") : u.wrapIn("blockquote")).run(),
        t.chain().focus().selectTextblockEnd().run(),
        !0
    } catch {
        return !1
    }
}
function tz(t) {
    const {editor: e, hideWhenUnavailable: n} = t;
    return !e || !e.isEditable || !_i("blockquote", e) ? !1 : n && !e.isActive("code") ? vg(e) : !0
}
function nz(t) {
    const {editor: e, hideWhenUnavailable: n=!1, onToggled: r} = t || {}
      , {editor: o} = Vt(e)
      , [l,a] = T.useState(!0)
      , u = vg(o)
      , f = o?.isActive("blockquote") || !1;
    T.useEffect( () => {
        if (!o)
            return;
        const p = () => {
            a(tz({
                editor: o,
                hideWhenUnavailable: n
            }))
        }
        ;
        return p(),
        o.on("selectionUpdate", p),
        () => {
            o.off("selectionUpdate", p)
        }
    }
    , [o, n]);
    const h = T.useCallback( () => {
        if (!o)
            return !1;
        const p = ez(o);
        return p && r?.(),
        p
    }
    , [o, r]);
    return {
        isVisible: l,
        isActive: f,
        handleToggle: h,
        canToggle: u,
        label: "",
        shortcutKeys: p5,
        Icon: h5
    }
}
function rz({shortcutKeys: t=y5}) {
    return E.jsx(Oo, {
        children: No({
            shortcutKeys: t
        })
    })
}
const m5 = T.forwardRef( ({editor: t, text: e, hideWhenUnavailable: n=!1, onToggled: r, showShortcut: o=!1, onClick: l, children: a, ...u}, f) => {
    const {editor: h} = Vt(t)
      , {isVisible: p, canToggle: m, isActive: y, handleToggle: b, label: C, shortcutKeys: S, Icon: w} = lz({
        editor: h,
        hideWhenUnavailable: n,
        onToggled: r
    })
      , k = T.useCallback(A => {
        l?.(A),
        !A.defaultPrevented && b()
    }
    , [b, l]);
    return p ? E.jsx(Bt, {
        type: "button",
        "data-style": "ghost",
        "data-active-state": y ? "on" : "off",
        role: "button",
        disabled: !m,
        "data-disabled": !m,
        tabIndex: -1,
        "aria-label": C,
        "aria-pressed": y,
        tooltip: " ",
        onClick: k,
        ...u,
        ref: f,
        children: a ?? E.jsxs(E.Fragment, {
            children: [E.jsx(w, {
                className: "tiptap-button-icon"
            }), e && E.jsx("span", {
                className: "tiptap-button-text",
                children: e
            }), o && E.jsx(rz, {
                shortcutKeys: S
            })]
        })
    }) : null
}
);
m5.displayName = "CodeBlockButton";
const g5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M6.70711 2.29289C7.09763 2.68342 7.09763 3.31658 6.70711 3.70711L4.41421 6L6.70711 8.29289C7.09763 8.68342 7.09763 9.31658 6.70711 9.70711C6.31658 10.0976 5.68342 10.0976 5.29289 9.70711L2.29289 6.70711C1.90237 6.31658 1.90237 5.68342 2.29289 5.29289L5.29289 2.29289C5.68342 1.90237 6.31658 1.90237 6.70711 2.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M10.2929 2.29289C10.6834 1.90237 11.3166 1.90237 11.7071 2.29289L14.7071 5.29289C15.0976 5.68342 15.0976 6.31658 14.7071 6.70711L11.7071 9.70711C11.3166 10.0976 10.6834 10.0976 10.2929 9.70711C9.90237 9.31658 9.90237 8.68342 10.2929 8.29289L12.5858 6L10.2929 3.70711C9.90237 3.31658 9.90237 2.68342 10.2929 2.29289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M17 4C17 3.44772 17.4477 3 18 3H19C20.6569 3 22 4.34315 22 6V18C22 19.6569 20.6569 21 19 21H5C3.34315 21 2 19.6569 2 18V12C2 11.4477 2.44772 11 3 11C3.55228 11 4 11.4477 4 12V18C4 18.5523 4.44772 19 5 19H19C19.5523 19 20 18.5523 20 18V6C20 5.44772 19.5523 5 19 5H18C17.4477 5 17 4.55228 17 4Z",
        fill: "currentColor"
    })]
}));
g5.displayName = "CodeBlockIcon";
const y5 = "mod+alt+c";
function bg(t, e=!0) {
    return !t || !t.isEditable || !_i("codeBlock", t) || Ro(t, ["image"]) ? !1 : e ? Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) ? t.can().toggleNode("codeBlock", "paragraph") || t.can().clearNodes() : !1 : t.can().toggleNode("codeBlock", "paragraph")
}
function iz(t) {
    if (!t || !t.isEditable || !bg(t))
        return !1;
    try {
        const e = t.view;
        let n = e.state
          , r = n.tr;
        const o = Ff(t)
          , l = Bi(t, ["paragraph", "heading", "bulletList", "orderedList", "taskList", "blockquote", "codeBlock"]) && o.length === 1;
        if ((n.selection.empty || n.selection instanceof se) && l) {
            const h = $f({
                editor: t,
                node: n.selection.$anchor.node(1)
            })?.pos;
            if (!ka(h))
                return !1;
            r = r.setSelection(le.create(n.doc, h)),
            e.dispatch(r),
            n = e.state
        }
        const a = n.selection;
        let u = t.chain().focus();
        if (a instanceof le) {
            const h = a.node.firstChild?.firstChild
              , p = a.node.lastChild?.lastChild
              , m = h ? a.from + h.nodeSize : a.from + 1
              , y = p ? a.to - p.nodeSize : a.to - 1
              , b = n.doc.resolve(m)
              , C = n.doc.resolve(y);
            u = u.setTextSelection(se.between(b, C)).clearNodes()
        }
        return (t.isActive("codeBlock") ? u.setNode("paragraph") : u.toggleNode("codeBlock", "paragraph")).run(),
        t.chain().focus().selectTextblockEnd().run(),
        !0
    } catch {
        return !1
    }
}
function oz(t) {
    const {editor: e, hideWhenUnavailable: n} = t;
    return !e || !e.isEditable || !_i("codeBlock", e) ? !1 : n && !e.isActive("code") ? bg(e) : !0
}
function lz(t) {
    const {editor: e, hideWhenUnavailable: n=!1, onToggled: r} = t || {}
      , {editor: o} = Vt(e)
      , [l,a] = T.useState(!0)
      , u = bg(o)
      , f = o?.isActive("codeBlock") || !1;
    T.useEffect( () => {
        if (!o)
            return;
        const p = () => {
            a(oz({
                editor: o,
                hideWhenUnavailable: n
            }))
        }
        ;
        return p(),
        o.on("selectionUpdate", p),
        () => {
            o.off("selectionUpdate", p)
        }
    }
    , [o, n]);
    const h = T.useCallback( () => {
        if (!o)
            return !1;
        const p = iz(o);
        return p && r?.(),
        p
    }
    , [o, r]);
    return {
        isVisible: l,
        isActive: f,
        handleToggle: h,
        canToggle: u,
        label: " ",
        shortcutKeys: y5,
        Icon: g5
    }
}
function sz({action: t, shortcutKeys: e=C5[t]}) {
    return E.jsx(Oo, {
        children: No({
            shortcutKeys: e
        })
    })
}
const u1 = T.forwardRef( ({editor: t, action: e, text: n, hideWhenUnavailable: r=!1, onExecuted: o, showShortcut: l=!1, onClick: a, children: u, ...f}, h) => {
    const {editor: p} = Vt(t)
      , {isVisible: m, handleAction: y, label: b, canExecute: C, Icon: S, shortcutKeys: w} = dz({
        editor: p,
        action: e,
        hideWhenUnavailable: r,
        onExecuted: o
    })
      , k = T.useCallback(A => {
        a?.(A),
        !A.defaultPrevented && y()
    }
    , [y, a]);
    return m ? E.jsx(Bt, {
        type: "button",
        disabled: !C,
        "data-style": "ghost",
        "data-disabled": !C,
        role: "button",
        tabIndex: -1,
        "aria-label": b,
        tooltip: b,
        onClick: k,
        ...f,
        ref: h,
        children: u ?? E.jsxs(E.Fragment, {
            children: [E.jsx(S, {
                className: "tiptap-button-icon"
            }), n && E.jsx("span", {
                className: "tiptap-button-text",
                children: n
            }), l && E.jsx(sz, {
                action: e,
                shortcutKeys: w
            })]
        })
    }) : null
}
);
u1.displayName = "UndoRedoButton";
const v5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M15.7071 2.29289C15.3166 1.90237 14.6834 1.90237 14.2929 2.29289C13.9024 2.68342 13.9024 3.31658 14.2929 3.70711L17.5858 7H9.5C7.77609 7 6.12279 7.68482 4.90381 8.90381C3.68482 10.1228 3 11.7761 3 13.5C3 14.3536 3.16813 15.1988 3.49478 15.9874C3.82144 16.7761 4.30023 17.4926 4.90381 18.0962C6.12279 19.3152 7.77609 20 9.5 20H13C13.5523 20 14 19.5523 14 19C14 18.4477 13.5523 18 13 18H9.5C8.30653 18 7.16193 17.5259 6.31802 16.682C5.90016 16.2641 5.56869 15.768 5.34254 15.2221C5.1164 14.6761 5 14.0909 5 13.5C5 12.3065 5.47411 11.1619 6.31802 10.318C7.16193 9.47411 8.30653 9 9.5 9H17.5858L14.2929 12.2929C13.9024 12.6834 13.9024 13.3166 14.2929 13.7071C14.6834 14.0976 15.3166 14.0976 15.7071 13.7071L20.7071 8.70711C21.0976 8.31658 21.0976 7.68342 20.7071 7.29289L15.7071 2.29289Z",
        fill: "currentColor"
    })
}));
v5.displayName = "Redo2Icon";
const b5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M9.70711 3.70711C10.0976 3.31658 10.0976 2.68342 9.70711 2.29289C9.31658 1.90237 8.68342 1.90237 8.29289 2.29289L3.29289 7.29289C2.90237 7.68342 2.90237 8.31658 3.29289 8.70711L8.29289 13.7071C8.68342 14.0976 9.31658 14.0976 9.70711 13.7071C10.0976 13.3166 10.0976 12.6834 9.70711 12.2929L6.41421 9H14.5C15.0909 9 15.6761 9.1164 16.2221 9.34254C16.768 9.56869 17.2641 9.90016 17.682 10.318C18.0998 10.7359 18.4313 11.232 18.6575 11.7779C18.8836 12.3239 19 12.9091 19 13.5C19 14.0909 18.8836 14.6761 18.6575 15.2221C18.4313 15.768 18.0998 16.2641 17.682 16.682C17.2641 17.0998 16.768 17.4313 16.2221 17.6575C15.6761 17.8836 15.0909 18 14.5 18H11C10.4477 18 10 18.4477 10 19C10 19.5523 10.4477 20 11 20H14.5C15.3536 20 16.1988 19.8319 16.9874 19.5052C17.7761 19.1786 18.4926 18.6998 19.0962 18.0962C19.6998 17.4926 20.1786 16.7761 20.5052 15.9874C20.8319 15.1988 21 14.3536 21 13.5C21 12.6464 20.8319 11.8012 20.5052 11.0126C20.1786 10.2239 19.6998 9.50739 19.0962 8.90381C18.4926 8.30022 17.7761 7.82144 16.9874 7.49478C16.1988 7.16813 15.3536 7 14.5 7H6.41421L9.70711 3.70711Z",
        fill: "currentColor"
    })
}));
b5.displayName = "Undo2Icon";
const C5 = {
    undo: "mod+z",
    redo: "mod+shift+z"
}
  , az = {
    undo: "",
    redo: ""
}
  , cz = {
    undo: b5,
    redo: v5
};
function Cg(t, e) {
    return !t || !t.isEditable || Ro(t, ["image"]) ? !1 : e === "undo" ? t.can().undo() : t.can().redo()
}
function uz(t, e) {
    if (!t || !t.isEditable || !Cg(t, e))
        return !1;
    const n = t.chain().focus();
    return e === "undo" ? n.undo().run() : n.redo().run()
}
function fz(t) {
    const {editor: e, hideWhenUnavailable: n, action: r} = t;
    return !e || !e.isEditable ? !1 : n && !e.isActive("code") ? Cg(e, r) : !0
}
function dz(t) {
    const {editor: e, action: n, hideWhenUnavailable: r=!1, onExecuted: o} = t
      , {editor: l} = Vt(e)
      , [a,u] = T.useState(!0)
      , f = Cg(l, n);
    T.useEffect( () => {
        if (!l)
            return;
        const p = () => {
            u(fz({
                editor: l,
                hideWhenUnavailable: r,
                action: n
            }))
        }
        ;
        return p(),
        l.on("transaction", p),
        () => {
            l.off("transaction", p)
        }
    }
    , [l, r, n]);
    const h = T.useCallback( () => {
        if (!l)
            return !1;
        const p = uz(l, n);
        return p && o?.(),
        p
    }
    , [l, n, o]);
    return {
        isVisible: a,
        handleAction: h,
        canExecute: f,
        label: az[n],
        shortcutKeys: C5[n],
        Icon: cz[n]
    }
}
function hz(t="max", e=768) {
    const [n,r] = T.useState(void 0);
    return T.useEffect( () => {
        const o = t === "min" ? `(min-width: ${e}px)` : `(max-width: ${e - 1}px)`
          , l = window.matchMedia(o)
          , a = u => r(u.matches);
        return r(l.matches),
        l.addEventListener("change", a),
        () => l.removeEventListener("change", a)
    }
    , [t, e]),
    !!n
}
const S5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M21 4C21 3.44772 20.5523 3 20 3C19.4477 3 19 3.44772 19 4V11C19 11.7956 18.6839 12.5587 18.1213 13.1213C17.5587 13.6839 16.7956 14 16 14H6.41421L9.70711 10.7071C10.0976 10.3166 10.0976 9.68342 9.70711 9.29289C9.31658 8.90237 8.68342 8.90237 8.29289 9.29289L3.29289 14.2929C2.90237 14.6834 2.90237 15.3166 3.29289 15.7071L8.29289 20.7071C8.68342 21.0976 9.31658 21.0976 9.70711 20.7071C10.0976 20.3166 10.0976 19.6834 9.70711 19.2929L6.41421 16H16C17.3261 16 18.5979 15.4732 19.5355 14.5355C20.4732 13.5979 21 12.3261 21 11V4Z",
        fill: "currentColor"
    })
}));
S5.displayName = "CornerDownLeftIcon";
const x5 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M14 3C14 2.44772 14.4477 2 15 2H21C21.5523 2 22 2.44772 22 3V9C22 9.55228 21.5523 10 21 10C20.4477 10 20 9.55228 20 9V5.41421L10.7071 14.7071C10.3166 15.0976 9.68342 15.0976 9.29289 14.7071C8.90237 14.3166 8.90237 13.6834 9.29289 13.2929L18.5858 4H15C14.4477 4 14 3.55228 14 3Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M4.29289 7.29289C4.48043 7.10536 4.73478 7 5 7H11C11.5523 7 12 6.55228 12 6C12 5.44772 11.5523 5 11 5H5C4.20435 5 3.44129 5.31607 2.87868 5.87868C2.31607 6.44129 2 7.20435 2 8V19C2 19.7957 2.31607 20.5587 2.87868 21.1213C3.44129 21.6839 4.20435 22 5 22H16C16.7957 22 17.5587 21.6839 18.1213 21.1213C18.6839 20.5587 19 19.7957 19 19V13C19 12.4477 18.5523 12 18 12C17.4477 12 17 12.4477 17 13V19C17 19.2652 16.8946 19.5196 16.7071 19.7071C16.5196 19.8946 16.2652 20 16 20H5C4.73478 20 4.48043 19.8946 4.29289 19.7071C4.10536 19.5196 4 19.2652 4 19V8C4 7.73478 4.10536 7.48043 4.29289 7.29289Z",
        fill: "currentColor"
    })]
}));
x5.displayName = "ExternalLinkIcon";
const Sg = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M16.9958 1.06669C15.4226 1.05302 13.907 1.65779 12.7753 2.75074L12.765 2.76086L11.045 4.47086C10.6534 4.86024 10.6515 5.49341 11.0409 5.88507C11.4303 6.27673 12.0634 6.27858 12.4551 5.88919L14.1697 4.18456C14.9236 3.45893 15.9319 3.05752 16.9784 3.06662C18.0272 3.07573 19.0304 3.49641 19.772 4.23804C20.5137 4.97967 20.9344 5.98292 20.9435 7.03171C20.9526 8.07776 20.5515 9.08563 19.8265 9.83941L16.833 12.8329C16.4274 13.2386 15.9393 13.5524 15.4019 13.7529C14.8645 13.9533 14.2903 14.0359 13.7181 13.9949C13.146 13.9539 12.5894 13.7904 12.0861 13.5154C11.5827 13.2404 11.1444 12.8604 10.8008 12.401C10.47 11.9588 9.84333 11.8685 9.40108 12.1993C8.95883 12.5301 8.86849 13.1568 9.1993 13.599C9.71464 14.288 10.3721 14.858 11.1272 15.2705C11.8822 15.683 12.7171 15.9283 13.5753 15.9898C14.4334 16.0513 15.2948 15.9274 16.1009 15.6267C16.907 15.326 17.639 14.8555 18.2473 14.247L21.2472 11.2471L21.2593 11.2347C22.3523 10.1031 22.9571 8.58751 22.9434 7.01433C22.9297 5.44115 22.2987 3.93628 21.1863 2.82383C20.0738 1.71138 18.5689 1.08036 16.9958 1.06669Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M10.4247 8.0102C9.56657 7.94874 8.70522 8.07256 7.89911 8.37326C7.09305 8.67395 6.36096 9.14458 5.75272 9.753L2.75285 12.7529L2.74067 12.7653C1.64772 13.8969 1.04295 15.4125 1.05662 16.9857C1.07029 18.5589 1.70131 20.0637 2.81376 21.1762C3.9262 22.2886 5.43108 22.9196 7.00426 22.9333C8.57744 22.947 10.0931 22.3422 11.2247 21.2493L11.2371 21.2371L12.9471 19.5271C13.3376 19.1366 13.3376 18.5034 12.9471 18.1129C12.5565 17.7223 11.9234 17.7223 11.5328 18.1129L9.82932 19.8164C9.07555 20.5414 8.06768 20.9425 7.02164 20.9334C5.97285 20.9243 4.9696 20.5036 4.22797 19.762C3.48634 19.0203 3.06566 18.0171 3.05655 16.9683C3.04746 15.9222 3.44851 14.9144 4.17355 14.1606L7.16719 11.167C7.5727 10.7613 8.06071 10.4476 8.59811 10.2471C9.13552 10.0467 9.70976 9.96412 10.2819 10.0051C10.854 10.0461 11.4106 10.2096 11.9139 10.4846C12.4173 10.7596 12.8556 11.1397 13.1992 11.599C13.53 12.0412 14.1567 12.1316 14.5989 11.8007C15.0412 11.4699 15.1315 10.8433 14.8007 10.401C14.2854 9.71205 13.6279 9.14198 12.8729 8.72948C12.1178 8.31697 11.2829 8.07166 10.4247 8.0102Z",
        fill: "currentColor"
    })]
}));
Sg.displayName = "LinkIcon";
const w5 = T.memo( ({className: t, ...e}) => E.jsx("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7 5V4C7 3.17477 7.40255 2.43324 7.91789 1.91789C8.43324 1.40255 9.17477 1 10 1H14C14.8252 1 15.5668 1.40255 16.0821 1.91789C16.5975 2.43324 17 3.17477 17 4V5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H20V20C20 20.8252 19.5975 21.5668 19.0821 22.0821C18.5668 22.5975 17.8252 23 17 23H7C6.17477 23 5.43324 22.5975 4.91789 22.0821C4.40255 21.5668 4 20.8252 4 20V7H3C2.44772 7 2 6.55228 2 6C2 5.44772 2.44772 5 3 5H7ZM9 4C9 3.82523 9.09745 3.56676 9.33211 3.33211C9.56676 3.09745 9.82523 3 10 3H14C14.1748 3 14.4332 3.09745 14.6679 3.33211C14.9025 3.56676 15 3.82523 15 4V5H9V4ZM6 7V20C6 20.1748 6.09745 20.4332 6.33211 20.6679C6.56676 20.9025 6.82523 21 7 21H17C17.1748 21 17.4332 20.9025 17.6679 20.6679C17.9025 20.4332 18 20.1748 18 20V7H6Z",
        fill: "currentColor"
    })
}));
w5.displayName = "TrashIcon";
function ki(t, e, {checkForDefaultPrevented: n=!0}={}) {
    return function(o) {
        if (t?.(o),
        n === !1 || !o.defaultPrevented)
            return e?.(o)
    }
}
function eS(t, e) {
    if (typeof t == "function")
        return t(e);
    t != null && (t.current = e)
}
function E5(...t) {
    return e => {
        let n = !1;
        const r = t.map(o => {
            const l = eS(o, e);
            return !n && typeof l == "function" && (n = !0),
            l
        }
        );
        if (n)
            return () => {
                for (let o = 0; o < r.length; o++) {
                    const l = r[o];
                    typeof l == "function" ? l() : eS(t[o], null)
                }
            }
    }
}
function ji(...t) {
    return T.useCallback(E5(...t), t)
}
function T5(t, e=[]) {
    let n = [];
    function r(l, a) {
        const u = T.createContext(a)
          , f = n.length;
        n = [...n, a];
        const h = m => {
            const {scope: y, children: b, ...C} = m
              , S = y?.[t]?.[f] || u
              , w = T.useMemo( () => C, Object.values(C));
            return E.jsx(S.Provider, {
                value: w,
                children: b
            })
        }
        ;
        h.displayName = l + "Provider";
        function p(m, y) {
            const b = y?.[t]?.[f] || u
              , C = T.useContext(b);
            if (C)
                return C;
            if (a !== void 0)
                return a;
            throw new Error(`\`${m}\` must be used within \`${l}\``)
        }
        return [h, p]
    }
    const o = () => {
        const l = n.map(a => T.createContext(a));
        return function(u) {
            const f = u?.[t] || l;
            return T.useMemo( () => ({
                [`__scope${t}`]: {
                    ...u,
                    [t]: f
                }
            }), [u, f])
        }
    }
    ;
    return o.scopeName = t,
    [r, pz(o, ...e)]
}
function pz(...t) {
    const e = t[0];
    if (t.length === 1)
        return e;
    const n = () => {
        const r = t.map(o => ({
            useScope: o(),
            scopeName: o.scopeName
        }));
        return function(l) {
            const a = r.reduce( (u, {useScope: f, scopeName: h}) => {
                const m = f(l)[`__scope${h}`];
                return {
                    ...u,
                    ...m
                }
            }
            , {});
            return T.useMemo( () => ({
                [`__scope${e.scopeName}`]: a
            }), [a])
        }
    }
    ;
    return n.scopeName = e.scopeName,
    n
}
function k5(t) {
    const e = mz(t)
      , n = T.forwardRef( (r, o) => {
        const {children: l, ...a} = r
          , u = T.Children.toArray(l)
          , f = u.find(yz);
        if (f) {
            const h = f.props.children
              , p = u.map(m => m === f ? T.Children.count(h) > 1 ? T.Children.only(null) : T.isValidElement(h) ? h.props.children : null : m);
            return E.jsx(e, {
                ...a,
                ref: o,
                children: T.isValidElement(h) ? T.cloneElement(h, void 0, p) : null
            })
        }
        return E.jsx(e, {
            ...a,
            ref: o,
            children: l
        })
    }
    );
    return n.displayName = `${t}.Slot`,
    n
}
function mz(t) {
    const e = T.forwardRef( (n, r) => {
        const {children: o, ...l} = n;
        if (T.isValidElement(o)) {
            const a = bz(o)
              , u = vz(l, o.props);
            return o.type !== T.Fragment && (u.ref = r ? E5(r, a) : a),
            T.cloneElement(o, u)
        }
        return T.Children.count(o) > 1 ? T.Children.only(null) : null
    }
    );
    return e.displayName = `${t}.SlotClone`,
    e
}
var gz = Symbol("radix.slottable");
function yz(t) {
    return T.isValidElement(t) && typeof t.type == "function" && "__radixId"in t.type && t.type.__radixId === gz
}
function vz(t, e) {
    const n = {
        ...e
    };
    for (const r in e) {
        const o = t[r]
          , l = e[r];
        /^on[A-Z]/.test(r) ? o && l ? n[r] = (...u) => {
            const f = l(...u);
            return o(...u),
            f
        }
        : o && (n[r] = o) : r === "style" ? n[r] = {
            ...o,
            ...l
        } : r === "className" && (n[r] = [o, l].filter(Boolean).join(" "))
    }
    return {
        ...t,
        ...n
    }
}
function bz(t) {
    let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get
      , n = e && "isReactWarning"in e && e.isReactWarning;
    return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get,
    n = e && "isReactWarning"in e && e.isReactWarning,
    n ? t.props.ref : t.props.ref || t.ref)
}
var Cz = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"]
  , _r = Cz.reduce( (t, e) => {
    const n = k5(`Primitive.${e}`)
      , r = T.forwardRef( (o, l) => {
        const {asChild: a, ...u} = o
          , f = a ? n : e;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        E.jsx(f, {
            ...u,
            ref: l
        })
    }
    );
    return r.displayName = `Primitive.${e}`,
    {
        ...t,
        [e]: r
    }
}
, {});
function Sz(t, e) {
    t && Mf.flushSync( () => t.dispatchEvent(e))
}
function Il(t) {
    const e = T.useRef(t);
    return T.useEffect( () => {
        e.current = t
    }
    ),
    T.useMemo( () => (...n) => e.current?.(...n), [])
}
function xz(t, e=globalThis?.document) {
    const n = Il(t);
    T.useEffect( () => {
        const r = o => {
            o.key === "Escape" && n(o)
        }
        ;
        return e.addEventListener("keydown", r, {
            capture: !0
        }),
        () => e.removeEventListener("keydown", r, {
            capture: !0
        })
    }
    , [n, e])
}
var wz = "DismissableLayer", f1 = "dismissableLayer.update", Ez = "dismissableLayer.pointerDownOutside", Tz = "dismissableLayer.focusOutside", tS, M5 = T.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), A5 = T.forwardRef( (t, e) => {
    const {disableOutsidePointerEvents: n=!1, onEscapeKeyDown: r, onPointerDownOutside: o, onFocusOutside: l, onInteractOutside: a, onDismiss: u, ...f} = t
      , h = T.useContext(M5)
      , [p,m] = T.useState(null)
      , y = p?.ownerDocument ?? globalThis?.document
      , [,b] = T.useState({})
      , C = ji(e, _ => m(_))
      , S = Array.from(h.layers)
      , [w] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1)
      , k = S.indexOf(w)
      , A = p ? S.indexOf(p) : -1
      , O = h.layersWithOutsidePointerEventsDisabled.size > 0
      , B = A >= k
      , z = Az(_ => {
        const W = _.target
          , ne = [...h.branches].some(de => de.contains(W));
        !B || ne || (o?.(_),
        a?.(_),
        _.defaultPrevented || u?.())
    }
    , y)
      , $ = Nz(_ => {
        const W = _.target;
        [...h.branches].some(de => de.contains(W)) || (l?.(_),
        a?.(_),
        _.defaultPrevented || u?.())
    }
    , y);
    return xz(_ => {
        A === h.layers.size - 1 && (r?.(_),
        !_.defaultPrevented && u && (_.preventDefault(),
        u()))
    }
    , y),
    T.useEffect( () => {
        if (p)
            return n && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (tS = y.body.style.pointerEvents,
            y.body.style.pointerEvents = "none"),
            h.layersWithOutsidePointerEventsDisabled.add(p)),
            h.layers.add(p),
            nS(),
            () => {
                n && h.layersWithOutsidePointerEventsDisabled.size === 1 && (y.body.style.pointerEvents = tS)
            }
    }
    , [p, y, n, h]),
    T.useEffect( () => () => {
        p && (h.layers.delete(p),
        h.layersWithOutsidePointerEventsDisabled.delete(p),
        nS())
    }
    , [p, h]),
    T.useEffect( () => {
        const _ = () => b({});
        return document.addEventListener(f1, _),
        () => document.removeEventListener(f1, _)
    }
    , []),
    E.jsx(_r.div, {
        ...f,
        ref: C,
        style: {
            pointerEvents: O ? B ? "auto" : "none" : void 0,
            ...t.style
        },
        onFocusCapture: ki(t.onFocusCapture, $.onFocusCapture),
        onBlurCapture: ki(t.onBlurCapture, $.onBlurCapture),
        onPointerDownCapture: ki(t.onPointerDownCapture, z.onPointerDownCapture)
    })
}
);
A5.displayName = wz;
var kz = "DismissableLayerBranch"
  , Mz = T.forwardRef( (t, e) => {
    const n = T.useContext(M5)
      , r = T.useRef(null)
      , o = ji(e, r);
    return T.useEffect( () => {
        const l = r.current;
        if (l)
            return n.branches.add(l),
            () => {
                n.branches.delete(l)
            }
    }
    , [n.branches]),
    E.jsx(_r.div, {
        ...t,
        ref: o
    })
}
);
Mz.displayName = kz;
function Az(t, e=globalThis?.document) {
    const n = Il(t)
      , r = T.useRef(!1)
      , o = T.useRef( () => {}
    );
    return T.useEffect( () => {
        const l = u => {
            if (u.target && !r.current) {
                let f = function() {
                    N5(Ez, n, h, {
                        discrete: !0
                    })
                };
                const h = {
                    originalEvent: u
                };
                u.pointerType === "touch" ? (e.removeEventListener("click", o.current),
                o.current = f,
                e.addEventListener("click", o.current, {
                    once: !0
                })) : f()
            } else
                e.removeEventListener("click", o.current);
            r.current = !1
        }
          , a = window.setTimeout( () => {
            e.addEventListener("pointerdown", l)
        }
        , 0);
        return () => {
            window.clearTimeout(a),
            e.removeEventListener("pointerdown", l),
            e.removeEventListener("click", o.current)
        }
    }
    , [e, n]),
    {
        onPointerDownCapture: () => r.current = !0
    }
}
function Nz(t, e=globalThis?.document) {
    const n = Il(t)
      , r = T.useRef(!1);
    return T.useEffect( () => {
        const o = l => {
            l.target && !r.current && N5(Tz, n, {
                originalEvent: l
            }, {
                discrete: !1
            })
        }
        ;
        return e.addEventListener("focusin", o),
        () => e.removeEventListener("focusin", o)
    }
    , [e, n]),
    {
        onFocusCapture: () => r.current = !0,
        onBlurCapture: () => r.current = !1
    }
}
function nS() {
    const t = new CustomEvent(f1);
    document.dispatchEvent(t)
}
function N5(t, e, n, {discrete: r}) {
    const o = n.originalEvent.target
      , l = new CustomEvent(t,{
        bubbles: !1,
        cancelable: !0,
        detail: n
    });
    e && o.addEventListener(t, e, {
        once: !0
    }),
    r ? Sz(o, l) : o.dispatchEvent(l)
}
var am = 0;
function Rz() {
    T.useEffect( () => {
        const t = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", t[0] ?? rS()),
        document.body.insertAdjacentElement("beforeend", t[1] ?? rS()),
        am++,
        () => {
            am === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()),
            am--
        }
    }
    , [])
}
function rS() {
    const t = document.createElement("span");
    return t.setAttribute("data-radix-focus-guard", ""),
    t.tabIndex = 0,
    t.style.outline = "none",
    t.style.opacity = "0",
    t.style.position = "fixed",
    t.style.pointerEvents = "none",
    t
}
var cm = "focusScope.autoFocusOnMount"
  , um = "focusScope.autoFocusOnUnmount"
  , iS = {
    bubbles: !1,
    cancelable: !0
}
  , Oz = "FocusScope"
  , R5 = T.forwardRef( (t, e) => {
    const {loop: n=!1, trapped: r=!1, onMountAutoFocus: o, onUnmountAutoFocus: l, ...a} = t
      , [u,f] = T.useState(null)
      , h = Il(o)
      , p = Il(l)
      , m = T.useRef(null)
      , y = ji(e, S => f(S))
      , b = T.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    T.useEffect( () => {
        if (r) {
            let S = function(O) {
                if (b.paused || !u)
                    return;
                const B = O.target;
                u.contains(B) ? m.current = B : ui(m.current, {
                    select: !0
                })
            }
              , w = function(O) {
                if (b.paused || !u)
                    return;
                const B = O.relatedTarget;
                B !== null && (u.contains(B) || ui(m.current, {
                    select: !0
                }))
            }
              , k = function(O) {
                if (document.activeElement === document.body)
                    for (const z of O)
                        z.removedNodes.length > 0 && ui(u)
            };
            document.addEventListener("focusin", S),
            document.addEventListener("focusout", w);
            const A = new MutationObserver(k);
            return u && A.observe(u, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", S),
                document.removeEventListener("focusout", w),
                A.disconnect()
            }
        }
    }
    , [r, u, b.paused]),
    T.useEffect( () => {
        if (u) {
            lS.add(b);
            const S = document.activeElement;
            if (!u.contains(S)) {
                const k = new CustomEvent(cm,iS);
                u.addEventListener(cm, h),
                u.dispatchEvent(k),
                k.defaultPrevented || (Dz(jz(O5(u)), {
                    select: !0
                }),
                document.activeElement === S && ui(u))
            }
            return () => {
                u.removeEventListener(cm, h),
                setTimeout( () => {
                    const k = new CustomEvent(um,iS);
                    u.addEventListener(um, p),
                    u.dispatchEvent(k),
                    k.defaultPrevented || ui(S ?? document.body, {
                        select: !0
                    }),
                    u.removeEventListener(um, p),
                    lS.remove(b)
                }
                , 0)
            }
        }
    }
    , [u, h, p, b]);
    const C = T.useCallback(S => {
        if (!n && !r || b.paused)
            return;
        const w = S.key === "Tab" && !S.altKey && !S.ctrlKey && !S.metaKey
          , k = document.activeElement;
        if (w && k) {
            const A = S.currentTarget
              , [O,B] = Lz(A);
            O && B ? !S.shiftKey && k === B ? (S.preventDefault(),
            n && ui(O, {
                select: !0
            })) : S.shiftKey && k === O && (S.preventDefault(),
            n && ui(B, {
                select: !0
            })) : k === A && S.preventDefault()
        }
    }
    , [n, r, b.paused]);
    return E.jsx(_r.div, {
        tabIndex: -1,
        ...a,
        ref: y,
        onKeyDown: C
    })
}
);
R5.displayName = Oz;
function Dz(t, {select: e=!1}={}) {
    const n = document.activeElement;
    for (const r of t)
        if (ui(r, {
            select: e
        }),
        document.activeElement !== n)
            return
}
function Lz(t) {
    const e = O5(t)
      , n = oS(e, t)
      , r = oS(e.reverse(), t);
    return [n, r]
}
function O5(t) {
    const e = []
      , n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: r => {
            const o = r.tagName === "INPUT" && r.type === "hidden";
            return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; n.nextNode(); )
        e.push(n.currentNode);
    return e
}
function oS(t, e) {
    for (const n of t)
        if (!zz(n, {
            upTo: e
        }))
            return n
}
function zz(t, {upTo: e}) {
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    for (; t; ) {
        if (e !== void 0 && t === e)
            return !1;
        if (getComputedStyle(t).display === "none")
            return !0;
        t = t.parentElement
    }
    return !1
}
function _z(t) {
    return t instanceof HTMLInputElement && "select"in t
}
function ui(t, {select: e=!1}={}) {
    if (t && t.focus) {
        const n = document.activeElement;
        t.focus({
            preventScroll: !0
        }),
        t !== n && _z(t) && e && t.select()
    }
}
var lS = Bz();
function Bz() {
    let t = [];
    return {
        add(e) {
            const n = t[0];
            e !== n && n?.pause(),
            t = sS(t, e),
            t.unshift(e)
        },
        remove(e) {
            t = sS(t, e),
            t[0]?.resume()
        }
    }
}
function sS(t, e) {
    const n = [...t]
      , r = n.indexOf(e);
    return r !== -1 && n.splice(r, 1),
    n
}
function jz(t) {
    return t.filter(e => e.tagName !== "A")
}
var Oi = globalThis?.document ? T.useLayoutEffect : () => {}
  , Hz = kf[" useId ".trim().toString()] || ( () => {}
)
  , Iz = 0;
function Vz(t) {
    const [e,n] = T.useState(Hz());
    return Oi( () => {
        n(r => r ?? String(Iz++))
    }
    , [t]),
    t || (e ? `radix-${e}` : "")
}
var Uz = "Arrow"
  , D5 = T.forwardRef( (t, e) => {
    const {children: n, width: r=10, height: o=5, ...l} = t;
    return E.jsx(_r.svg, {
        ...l,
        ref: e,
        width: r,
        height: o,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: t.asChild ? n : E.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
D5.displayName = Uz;
var Pz = D5;
function qz(t) {
    const [e,n] = T.useState(void 0);
    return Oi( () => {
        if (t) {
            n({
                width: t.offsetWidth,
                height: t.offsetHeight
            });
            const r = new ResizeObserver(o => {
                if (!Array.isArray(o) || !o.length)
                    return;
                const l = o[0];
                let a, u;
                if ("borderBoxSize"in l) {
                    const f = l.borderBoxSize
                      , h = Array.isArray(f) ? f[0] : f;
                    a = h.inlineSize,
                    u = h.blockSize
                } else
                    a = t.offsetWidth,
                    u = t.offsetHeight;
                n({
                    width: a,
                    height: u
                })
            }
            );
            return r.observe(t, {
                box: "border-box"
            }),
            () => r.unobserve(t)
        } else
            n(void 0)
    }
    , [t]),
    e
}
var xg = "Popper"
  , [L5,z5] = T5(xg)
  , [$z,_5] = L5(xg)
  , B5 = t => {
    const {__scopePopper: e, children: n} = t
      , [r,o] = T.useState(null);
    return E.jsx($z, {
        scope: e,
        anchor: r,
        onAnchorChange: o,
        children: n
    })
}
;
B5.displayName = xg;
var j5 = "PopperAnchor"
  , H5 = T.forwardRef( (t, e) => {
    const {__scopePopper: n, virtualRef: r, ...o} = t
      , l = _5(j5, n)
      , a = T.useRef(null)
      , u = ji(e, a)
      , f = T.useRef(null);
    return T.useEffect( () => {
        const h = f.current;
        f.current = r?.current || a.current,
        h !== f.current && l.onAnchorChange(f.current)
    }
    ),
    r ? null : E.jsx(_r.div, {
        ...o,
        ref: u
    })
}
);
H5.displayName = j5;
var wg = "PopperContent"
  , [Fz,Kz] = L5(wg)
  , I5 = T.forwardRef( (t, e) => {
    const {__scopePopper: n, side: r="bottom", sideOffset: o=0, align: l="center", alignOffset: a=0, arrowPadding: u=0, avoidCollisions: f=!0, collisionBoundary: h=[], collisionPadding: p=0, sticky: m="partial", hideWhenDetached: y=!1, updatePositionStrategy: b="optimized", onPlaced: C, ...S} = t
      , w = _5(wg, n)
      , [k,A] = T.useState(null)
      , O = ji(e, Se => A(Se))
      , [B,z] = T.useState(null)
      , $ = qz(B)
      , _ = $?.width ?? 0
      , W = $?.height ?? 0
      , ne = r + (l !== "center" ? "-" + l : "")
      , de = typeof p == "number" ? p : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...p
    }
      , ve = Array.isArray(h) ? h : [h]
      , pe = ve.length > 0
      , be = {
        padding: de,
        boundary: ve.filter(Yz),
        altBoundary: pe
    }
      , {refs: Q, floatingStyles: ae, placement: j, isPositioned: P, middlewareData: q} = j4({
        strategy: "fixed",
        placement: ne,
        whileElementsMounted: (...Se) => _4(...Se, {
            animationFrame: b === "always"
        }),
        elements: {
            reference: w.anchor
        },
        middleware: [H4({
            mainAxis: o + W,
            alignmentAxis: a
        }), f && I4({
            mainAxis: !0,
            crossAxis: !1,
            limiter: m === "partial" ? tL() : void 0,
            ...be
        }), f && V4({
            ...be
        }), nL({
            ...be,
            apply: ({elements: Se, rects: lt, availableWidth: qe, availableHeight: er}) => {
                const {width: Br, height: Ii} = lt.reference
                  , tr = Se.floating.style;
                tr.setProperty("--radix-popper-available-width", `${qe}px`),
                tr.setProperty("--radix-popper-available-height", `${er}px`),
                tr.setProperty("--radix-popper-anchor-width", `${Br}px`),
                tr.setProperty("--radix-popper-anchor-height", `${Ii}px`)
            }
        }), B && iL({
            element: B,
            padding: u
        }), Zz({
            arrowWidth: _,
            arrowHeight: W
        }), y && rL({
            strategy: "referenceHidden",
            ...be
        })]
    })
      , [ee,ie] = P5(j)
      , R = Il(C);
    Oi( () => {
        P && R?.()
    }
    , [P, R]);
    const U = q.arrow?.x
      , X = q.arrow?.y
      , re = q.arrow?.centerOffset !== 0
      , [ce,ge] = T.useState();
    return Oi( () => {
        k && ge(window.getComputedStyle(k).zIndex)
    }
    , [k]),
    E.jsx("div", {
        ref: Q.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...ae,
            transform: P ? ae.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: ce,
            "--radix-popper-transform-origin": [q.transformOrigin?.x, q.transformOrigin?.y].join(" "),
            ...q.hide?.referenceHidden && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: t.dir,
        children: E.jsx(Fz, {
            scope: n,
            placedSide: ee,
            onArrowChange: z,
            arrowX: U,
            arrowY: X,
            shouldHideArrow: re,
            children: E.jsx(_r.div, {
                "data-side": ee,
                "data-align": ie,
                ...S,
                ref: O,
                style: {
                    ...S.style,
                    animation: P ? void 0 : "none"
                }
            })
        })
    })
}
);
I5.displayName = wg;
var V5 = "PopperArrow"
  , Gz = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , U5 = T.forwardRef(function(e, n) {
    const {__scopePopper: r, ...o} = e
      , l = Kz(V5, r)
      , a = Gz[l.placedSide];
    return E.jsx("span", {
        ref: l.onArrowChange,
        style: {
            position: "absolute",
            left: l.arrowX,
            top: l.arrowY,
            [a]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[l.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[l.placedSide],
            visibility: l.shouldHideArrow ? "hidden" : void 0
        },
        children: E.jsx(Pz, {
            ...o,
            ref: n,
            style: {
                ...o.style,
                display: "block"
            }
        })
    })
});
U5.displayName = V5;
function Yz(t) {
    return t !== null
}
var Zz = t => ({
    name: "transformOrigin",
    options: t,
    fn(e) {
        const {placement: n, rects: r, middlewareData: o} = e
          , a = o.arrow?.centerOffset !== 0
          , u = a ? 0 : t.arrowWidth
          , f = a ? 0 : t.arrowHeight
          , [h,p] = P5(n)
          , m = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[p]
          , y = (o.arrow?.x ?? 0) + u / 2
          , b = (o.arrow?.y ?? 0) + f / 2;
        let C = ""
          , S = "";
        return h === "bottom" ? (C = a ? m : `${y}px`,
        S = `${-f}px`) : h === "top" ? (C = a ? m : `${y}px`,
        S = `${r.floating.height + f}px`) : h === "right" ? (C = `${-f}px`,
        S = a ? m : `${b}px`) : h === "left" && (C = `${r.floating.width + f}px`,
        S = a ? m : `${b}px`),
        {
            data: {
                x: C,
                y: S
            }
        }
    }
});
function P5(t) {
    const [e,n="center"] = t.split("-");
    return [e, n]
}
var Wz = B5
  , q5 = H5
  , Xz = I5
  , Jz = U5
  , Qz = "Portal"
  , $5 = T.forwardRef( (t, e) => {
    const {container: n, ...r} = t
      , [o,l] = T.useState(!1);
    Oi( () => l(!0), []);
    const a = n || o && globalThis?.document?.body;
    return a ? bS.createPortal(E.jsx(_r.div, {
        ...r,
        ref: e
    }), a) : null
}
);
$5.displayName = Qz;
function e_(t, e) {
    return T.useReducer( (n, r) => e[n][r] ?? n, t)
}
var Eg = t => {
    const {present: e, children: n} = t
      , r = t_(e)
      , o = typeof n == "function" ? n({
        present: r.isPresent
    }) : T.Children.only(n)
      , l = ji(r.ref, n_(o));
    return typeof n == "function" || r.isPresent ? T.cloneElement(o, {
        ref: l
    }) : null
}
;
Eg.displayName = "Presence";
function t_(t) {
    const [e,n] = T.useState()
      , r = T.useRef(null)
      , o = T.useRef(t)
      , l = T.useRef("none")
      , a = t ? "mounted" : "unmounted"
      , [u,f] = e_(a, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return T.useEffect( () => {
        const h = du(r.current);
        l.current = u === "mounted" ? h : "none"
    }
    , [u]),
    Oi( () => {
        const h = r.current
          , p = o.current;
        if (p !== t) {
            const y = l.current
              , b = du(h);
            t ? f("MOUNT") : b === "none" || h?.display === "none" ? f("UNMOUNT") : f(p && y !== b ? "ANIMATION_OUT" : "UNMOUNT"),
            o.current = t
        }
    }
    , [t, f]),
    Oi( () => {
        if (e) {
            let h;
            const p = e.ownerDocument.defaultView ?? window
              , m = b => {
                const S = du(r.current).includes(CSS.escape(b.animationName));
                if (b.target === e && S && (f("ANIMATION_END"),
                !o.current)) {
                    const w = e.style.animationFillMode;
                    e.style.animationFillMode = "forwards",
                    h = p.setTimeout( () => {
                        e.style.animationFillMode === "forwards" && (e.style.animationFillMode = w)
                    }
                    )
                }
            }
              , y = b => {
                b.target === e && (l.current = du(r.current))
            }
            ;
            return e.addEventListener("animationstart", y),
            e.addEventListener("animationcancel", m),
            e.addEventListener("animationend", m),
            () => {
                p.clearTimeout(h),
                e.removeEventListener("animationstart", y),
                e.removeEventListener("animationcancel", m),
                e.removeEventListener("animationend", m)
            }
        } else
            f("ANIMATION_END")
    }
    , [e, f]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(u),
        ref: T.useCallback(h => {
            r.current = h ? getComputedStyle(h) : null,
            n(h)
        }
        , [])
    }
}
function du(t) {
    return t?.animationName || "none"
}
function n_(t) {
    let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get
      , n = e && "isReactWarning"in e && e.isReactWarning;
    return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get,
    n = e && "isReactWarning"in e && e.isReactWarning,
    n ? t.props.ref : t.props.ref || t.ref)
}
var r_ = kf[" useInsertionEffect ".trim().toString()] || Oi;
function i_({prop: t, defaultProp: e, onChange: n= () => {}
, caller: r}) {
    const [o,l,a] = o_({
        defaultProp: e,
        onChange: n
    })
      , u = t !== void 0
      , f = u ? t : o;
    {
        const p = T.useRef(t !== void 0);
        T.useEffect( () => {
            const m = p.current;
            m !== u && console.warn(`${r} is changing from ${m ? "controlled" : "uncontrolled"} to ${u ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),
            p.current = u
        }
        , [u, r])
    }
    const h = T.useCallback(p => {
        if (u) {
            const m = l_(p) ? p(t) : p;
            m !== t && a.current?.(m)
        } else
            l(p)
    }
    , [u, t, l, a]);
    return [f, h]
}
function o_({defaultProp: t, onChange: e}) {
    const [n,r] = T.useState(t)
      , o = T.useRef(n)
      , l = T.useRef(e);
    return r_( () => {
        l.current = e
    }
    , [e]),
    T.useEffect( () => {
        o.current !== n && (l.current?.(n),
        o.current = n)
    }
    , [n, o]),
    [n, r, l]
}
function l_(t) {
    return typeof t == "function"
}
var s_ = function(t) {
    if (typeof document > "u")
        return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body
}
  , vl = new WeakMap
  , hu = new WeakMap
  , pu = {}
  , fm = 0
  , F5 = function(t) {
    return t && (t.host || F5(t.parentNode))
}
  , a_ = function(t, e) {
    return e.map(function(n) {
        if (t.contains(n))
            return n;
        var r = F5(n);
        return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"),
        null)
    }).filter(function(n) {
        return !!n
    })
}
  , c_ = function(t, e, n, r) {
    var o = a_(e, Array.isArray(t) ? t : [t]);
    pu[n] || (pu[n] = new WeakMap);
    var l = pu[n]
      , a = []
      , u = new Set
      , f = new Set(o)
      , h = function(m) {
        !m || u.has(m) || (u.add(m),
        h(m.parentNode))
    };
    o.forEach(h);
    var p = function(m) {
        !m || f.has(m) || Array.prototype.forEach.call(m.children, function(y) {
            if (u.has(y))
                p(y);
            else
                try {
                    var b = y.getAttribute(r)
                      , C = b !== null && b !== "false"
                      , S = (vl.get(y) || 0) + 1
                      , w = (l.get(y) || 0) + 1;
                    vl.set(y, S),
                    l.set(y, w),
                    a.push(y),
                    S === 1 && C && hu.set(y, !0),
                    w === 1 && y.setAttribute(n, "true"),
                    C || y.setAttribute(r, "true")
                } catch (k) {
                    console.error("aria-hidden: cannot operate on ", y, k)
                }
        })
    };
    return p(e),
    u.clear(),
    fm++,
    function() {
        a.forEach(function(m) {
            var y = vl.get(m) - 1
              , b = l.get(m) - 1;
            vl.set(m, y),
            l.set(m, b),
            y || (hu.has(m) || m.removeAttribute(r),
            hu.delete(m)),
            b || m.removeAttribute(n)
        }),
        fm--,
        fm || (vl = new WeakMap,
        vl = new WeakMap,
        hu = new WeakMap,
        pu = {})
    }
}
  , u_ = function(t, e, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(t) ? t : [t])
      , o = s_(t);
    return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))),
    c_(r, o, n, "aria-hidden")) : function() {
        return null
    }
}
  , Kn = function() {
    return Kn = Object.assign || function(e) {
        for (var n, r = 1, o = arguments.length; r < o; r++) {
            n = arguments[r];
            for (var l in n)
                Object.prototype.hasOwnProperty.call(n, l) && (e[l] = n[l])
        }
        return e
    }
    ,
    Kn.apply(this, arguments)
};
function K5(t, e) {
    var n = {};
    for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
            e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
    return n
}
function f_(t, e, n) {
    if (n || arguments.length === 2)
        for (var r = 0, o = e.length, l; r < o; r++)
            (l || !(r in e)) && (l || (l = Array.prototype.slice.call(e, 0, r)),
            l[r] = e[r]);
    return t.concat(l || Array.prototype.slice.call(e))
}
var ku = "right-scroll-bar-position"
  , Mu = "width-before-scroll-bar"
  , d_ = "with-scroll-bars-hidden"
  , h_ = "--removed-body-scroll-bar-size";
function dm(t, e) {
    return typeof t == "function" ? t(e) : t && (t.current = e),
    t
}
function p_(t, e) {
    var n = T.useState(function() {
        return {
            value: t,
            callback: e,
            facade: {
                get current() {
                    return n.value
                },
                set current(r) {
                    var o = n.value;
                    o !== r && (n.value = r,
                    n.callback(r, o))
                }
            }
        }
    })[0];
    return n.callback = e,
    n.facade
}
var m_ = typeof window < "u" ? T.useLayoutEffect : T.useEffect
  , aS = new WeakMap;
function g_(t, e) {
    var n = p_(null, function(r) {
        return t.forEach(function(o) {
            return dm(o, r)
        })
    });
    return m_(function() {
        var r = aS.get(n);
        if (r) {
            var o = new Set(r)
              , l = new Set(t)
              , a = n.current;
            o.forEach(function(u) {
                l.has(u) || dm(u, null)
            }),
            l.forEach(function(u) {
                o.has(u) || dm(u, a)
            })
        }
        aS.set(n, t)
    }, [t]),
    n
}
function y_(t) {
    return t
}
function v_(t, e) {
    e === void 0 && (e = y_);
    var n = []
      , r = !1
      , o = {
        read: function() {
            if (r)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return n.length ? n[n.length - 1] : t
        },
        useMedium: function(l) {
            var a = e(l, r);
            return n.push(a),
            function() {
                n = n.filter(function(u) {
                    return u !== a
                })
            }
        },
        assignSyncMedium: function(l) {
            for (r = !0; n.length; ) {
                var a = n;
                n = [],
                a.forEach(l)
            }
            n = {
                push: function(u) {
                    return l(u)
                },
                filter: function() {
                    return n
                }
            }
        },
        assignMedium: function(l) {
            r = !0;
            var a = [];
            if (n.length) {
                var u = n;
                n = [],
                u.forEach(l),
                a = n
            }
            var f = function() {
                var p = a;
                a = [],
                p.forEach(l)
            }
              , h = function() {
                return Promise.resolve().then(f)
            };
            h(),
            n = {
                push: function(p) {
                    a.push(p),
                    h()
                },
                filter: function(p) {
                    return a = a.filter(p),
                    n
                }
            }
        }
    };
    return o
}
function b_(t) {
    t === void 0 && (t = {});
    var e = v_(null);
    return e.options = Kn({
        async: !0,
        ssr: !1
    }, t),
    e
}
var G5 = function(t) {
    var e = t.sideCar
      , n = K5(t, ["sideCar"]);
    if (!e)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = e.read();
    if (!r)
        throw new Error("Sidecar medium not found");
    return T.createElement(r, Kn({}, n))
};
G5.isSideCarExport = !0;
function C_(t, e) {
    return t.useMedium(e),
    G5
}
var Y5 = b_()
  , hm = function() {}
  , Xf = T.forwardRef(function(t, e) {
    var n = T.useRef(null)
      , r = T.useState({
        onScrollCapture: hm,
        onWheelCapture: hm,
        onTouchMoveCapture: hm
    })
      , o = r[0]
      , l = r[1]
      , a = t.forwardProps
      , u = t.children
      , f = t.className
      , h = t.removeScrollBar
      , p = t.enabled
      , m = t.shards
      , y = t.sideCar
      , b = t.noRelative
      , C = t.noIsolation
      , S = t.inert
      , w = t.allowPinchZoom
      , k = t.as
      , A = k === void 0 ? "div" : k
      , O = t.gapMode
      , B = K5(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , z = y
      , $ = g_([n, e])
      , _ = Kn(Kn({}, B), o);
    return T.createElement(T.Fragment, null, p && T.createElement(z, {
        sideCar: Y5,
        removeScrollBar: h,
        shards: m,
        noRelative: b,
        noIsolation: C,
        inert: S,
        setCallbacks: l,
        allowPinchZoom: !!w,
        lockRef: n,
        gapMode: O
    }), a ? T.cloneElement(T.Children.only(u), Kn(Kn({}, _), {
        ref: $
    })) : T.createElement(A, Kn({}, _, {
        className: f,
        ref: $
    }), u))
});
Xf.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
Xf.classNames = {
    fullWidth: Mu,
    zeroRight: ku
};
var S_ = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function x_() {
    if (!document)
        return null;
    var t = document.createElement("style");
    t.type = "text/css";
    var e = S_();
    return e && t.setAttribute("nonce", e),
    t
}
function w_(t, e) {
    t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e))
}
function E_(t) {
    var e = document.head || document.getElementsByTagName("head")[0];
    e.appendChild(t)
}
var T_ = function() {
    var t = 0
      , e = null;
    return {
        add: function(n) {
            t == 0 && (e = x_()) && (w_(e, n),
            E_(e)),
            t++
        },
        remove: function() {
            t--,
            !t && e && (e.parentNode && e.parentNode.removeChild(e),
            e = null)
        }
    }
}
  , k_ = function() {
    var t = T_();
    return function(e, n) {
        T.useEffect(function() {
            return t.add(e),
            function() {
                t.remove()
            }
        }, [e && n])
    }
}
  , Z5 = function() {
    var t = k_()
      , e = function(n) {
        var r = n.styles
          , o = n.dynamic;
        return t(r, o),
        null
    };
    return e
}
  , M_ = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , pm = function(t) {
    return parseInt(t || "", 10) || 0
}
  , A_ = function(t) {
    var e = window.getComputedStyle(document.body)
      , n = e[t === "padding" ? "paddingLeft" : "marginLeft"]
      , r = e[t === "padding" ? "paddingTop" : "marginTop"]
      , o = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [pm(n), pm(r), pm(o)]
}
  , N_ = function(t) {
    if (t === void 0 && (t = "margin"),
    typeof window > "u")
        return M_;
    var e = A_(t)
      , n = document.documentElement.clientWidth
      , r = window.innerWidth;
    return {
        left: e[0],
        top: e[1],
        right: e[2],
        gap: Math.max(0, r - n + e[2] - e[0])
    }
}
  , R_ = Z5()
  , Rl = "data-scroll-locked"
  , O_ = function(t, e, n, r) {
    var o = t.left
      , l = t.top
      , a = t.right
      , u = t.gap;
    return n === void 0 && (n = "margin"),
    `
  .`.concat(d_, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(Rl, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(l, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(ku, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Mu, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(ku, " .").concat(ku, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Mu, " .").concat(Mu, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Rl, `] {
    `).concat(h_, ": ").concat(u, `px;
  }
`)
}
  , cS = function() {
    var t = parseInt(document.body.getAttribute(Rl) || "0", 10);
    return isFinite(t) ? t : 0
}
  , D_ = function() {
    T.useEffect(function() {
        return document.body.setAttribute(Rl, (cS() + 1).toString()),
        function() {
            var t = cS() - 1;
            t <= 0 ? document.body.removeAttribute(Rl) : document.body.setAttribute(Rl, t.toString())
        }
    }, [])
}
  , L_ = function(t) {
    var e = t.noRelative
      , n = t.noImportant
      , r = t.gapMode
      , o = r === void 0 ? "margin" : r;
    D_();
    var l = T.useMemo(function() {
        return N_(o)
    }, [o]);
    return T.createElement(R_, {
        styles: O_(l, !e, o, n ? "" : "!important")
    })
}
  , d1 = !1;
if (typeof window < "u")
    try {
        var mu = Object.defineProperty({}, "passive", {
            get: function() {
                return d1 = !0,
                !0
            }
        });
        window.addEventListener("test", mu, mu),
        window.removeEventListener("test", mu, mu)
    } catch {
        d1 = !1
    }
var bl = d1 ? {
    passive: !1
} : !1
  , z_ = function(t) {
    return t.tagName === "TEXTAREA"
}
  , W5 = function(t, e) {
    if (!(t instanceof Element))
        return !1;
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !z_(t) && n[e] === "visible")
}
  , __ = function(t) {
    return W5(t, "overflowY")
}
  , B_ = function(t) {
    return W5(t, "overflowX")
}
  , uS = function(t, e) {
    var n = e.ownerDocument
      , r = e;
    do {
        typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
        var o = X5(t, r);
        if (o) {
            var l = J5(t, r)
              , a = l[1]
              , u = l[2];
            if (a > u)
                return !0
        }
        r = r.parentNode
    } while (r && r !== n.body);
    return !1
}
  , j_ = function(t) {
    var e = t.scrollTop
      , n = t.scrollHeight
      , r = t.clientHeight;
    return [e, n, r]
}
  , H_ = function(t) {
    var e = t.scrollLeft
      , n = t.scrollWidth
      , r = t.clientWidth;
    return [e, n, r]
}
  , X5 = function(t, e) {
    return t === "v" ? __(e) : B_(e)
}
  , J5 = function(t, e) {
    return t === "v" ? j_(e) : H_(e)
}
  , I_ = function(t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
}
  , V_ = function(t, e, n, r, o) {
    var l = I_(t, window.getComputedStyle(e).direction)
      , a = l * r
      , u = n.target
      , f = e.contains(u)
      , h = !1
      , p = a > 0
      , m = 0
      , y = 0;
    do {
        if (!u)
            break;
        var b = J5(t, u)
          , C = b[0]
          , S = b[1]
          , w = b[2]
          , k = S - w - l * C;
        (C || k) && X5(t, u) && (m += k,
        y += C);
        var A = u.parentNode;
        u = A && A.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? A.host : A
    } while (!f && u !== document.body || f && (e.contains(u) || e === u));
    return (p && Math.abs(m) < 1 || !p && Math.abs(y) < 1) && (h = !0),
    h
}
  , gu = function(t) {
    return "changedTouches"in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
}
  , fS = function(t) {
    return [t.deltaX, t.deltaY]
}
  , dS = function(t) {
    return t && "current"in t ? t.current : t
}
  , U_ = function(t, e) {
    return t[0] === e[0] && t[1] === e[1]
}
  , P_ = function(t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}
  , q_ = 0
  , Cl = [];
function $_(t) {
    var e = T.useRef([])
      , n = T.useRef([0, 0])
      , r = T.useRef()
      , o = T.useState(q_++)[0]
      , l = T.useState(Z5)[0]
      , a = T.useRef(t);
    T.useEffect(function() {
        a.current = t
    }, [t]),
    T.useEffect(function() {
        if (t.inert) {
            document.body.classList.add("block-interactivity-".concat(o));
            var S = f_([t.lockRef.current], (t.shards || []).map(dS), !0).filter(Boolean);
            return S.forEach(function(w) {
                return w.classList.add("allow-interactivity-".concat(o))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(o)),
                S.forEach(function(w) {
                    return w.classList.remove("allow-interactivity-".concat(o))
                })
            }
        }
    }, [t.inert, t.lockRef.current, t.shards]);
    var u = T.useCallback(function(S, w) {
        if ("touches"in S && S.touches.length === 2 || S.type === "wheel" && S.ctrlKey)
            return !a.current.allowPinchZoom;
        var k = gu(S), A = n.current, O = "deltaX"in S ? S.deltaX : A[0] - k[0], B = "deltaY"in S ? S.deltaY : A[1] - k[1], z, $ = S.target, _ = Math.abs(O) > Math.abs(B) ? "h" : "v";
        if ("touches"in S && _ === "h" && $.type === "range")
            return !1;
        var W = window.getSelection()
          , ne = W && W.anchorNode
          , de = ne ? ne === $ || ne.contains($) : !1;
        if (de)
            return !1;
        var ve = uS(_, $);
        if (!ve)
            return !0;
        if (ve ? z = _ : (z = _ === "v" ? "h" : "v",
        ve = uS(_, $)),
        !ve)
            return !1;
        if (!r.current && "changedTouches"in S && (O || B) && (r.current = z),
        !z)
            return !0;
        var pe = r.current || z;
        return V_(pe, w, S, pe === "h" ? O : B)
    }, [])
      , f = T.useCallback(function(S) {
        var w = S;
        if (!(!Cl.length || Cl[Cl.length - 1] !== l)) {
            var k = "deltaY"in w ? fS(w) : gu(w)
              , A = e.current.filter(function(z) {
                return z.name === w.type && (z.target === w.target || w.target === z.shadowParent) && U_(z.delta, k)
            })[0];
            if (A && A.should) {
                w.cancelable && w.preventDefault();
                return
            }
            if (!A) {
                var O = (a.current.shards || []).map(dS).filter(Boolean).filter(function(z) {
                    return z.contains(w.target)
                })
                  , B = O.length > 0 ? u(w, O[0]) : !a.current.noIsolation;
                B && w.cancelable && w.preventDefault()
            }
        }
    }, [])
      , h = T.useCallback(function(S, w, k, A) {
        var O = {
            name: S,
            delta: w,
            target: k,
            should: A,
            shadowParent: F_(k)
        };
        e.current.push(O),
        setTimeout(function() {
            e.current = e.current.filter(function(B) {
                return B !== O
            })
        }, 1)
    }, [])
      , p = T.useCallback(function(S) {
        n.current = gu(S),
        r.current = void 0
    }, [])
      , m = T.useCallback(function(S) {
        h(S.type, fS(S), S.target, u(S, t.lockRef.current))
    }, [])
      , y = T.useCallback(function(S) {
        h(S.type, gu(S), S.target, u(S, t.lockRef.current))
    }, []);
    T.useEffect(function() {
        return Cl.push(l),
        t.setCallbacks({
            onScrollCapture: m,
            onWheelCapture: m,
            onTouchMoveCapture: y
        }),
        document.addEventListener("wheel", f, bl),
        document.addEventListener("touchmove", f, bl),
        document.addEventListener("touchstart", p, bl),
        function() {
            Cl = Cl.filter(function(S) {
                return S !== l
            }),
            document.removeEventListener("wheel", f, bl),
            document.removeEventListener("touchmove", f, bl),
            document.removeEventListener("touchstart", p, bl)
        }
    }, []);
    var b = t.removeScrollBar
      , C = t.inert;
    return T.createElement(T.Fragment, null, C ? T.createElement(l, {
        styles: P_(o)
    }) : null, b ? T.createElement(L_, {
        noRelative: t.noRelative,
        gapMode: t.gapMode
    }) : null)
}
function F_(t) {
    for (var e = null; t !== null; )
        t instanceof ShadowRoot && (e = t.host,
        t = t.host),
        t = t.parentNode;
    return e
}
const K_ = C_(Y5, $_);
var Q5 = T.forwardRef(function(t, e) {
    return T.createElement(Xf, Kn({}, t, {
        ref: e,
        sideCar: K_
    }))
});
Q5.classNames = Xf.classNames;
var Jf = "Popover"
  , [e7] = T5(Jf, [z5])
  , Na = z5()
  , [G_,Hi] = e7(Jf)
  , t7 = t => {
    const {__scopePopover: e, children: n, open: r, defaultOpen: o, onOpenChange: l, modal: a=!1} = t
      , u = Na(e)
      , f = T.useRef(null)
      , [h,p] = T.useState(!1)
      , [m,y] = i_({
        prop: r,
        defaultProp: o ?? !1,
        onChange: l,
        caller: Jf
    });
    return E.jsx(Wz, {
        ...u,
        children: E.jsx(G_, {
            scope: e,
            contentId: Vz(),
            triggerRef: f,
            open: m,
            onOpenChange: y,
            onOpenToggle: T.useCallback( () => y(b => !b), [y]),
            hasCustomAnchor: h,
            onCustomAnchorAdd: T.useCallback( () => p(!0), []),
            onCustomAnchorRemove: T.useCallback( () => p(!1), []),
            modal: a,
            children: n
        })
    })
}
;
t7.displayName = Jf;
var n7 = "PopoverAnchor"
  , Y_ = T.forwardRef( (t, e) => {
    const {__scopePopover: n, ...r} = t
      , o = Hi(n7, n)
      , l = Na(n)
      , {onCustomAnchorAdd: a, onCustomAnchorRemove: u} = o;
    return T.useEffect( () => (a(),
    () => u()), [a, u]),
    E.jsx(q5, {
        ...l,
        ...r,
        ref: e
    })
}
);
Y_.displayName = n7;
var r7 = "PopoverTrigger"
  , i7 = T.forwardRef( (t, e) => {
    const {__scopePopover: n, ...r} = t
      , o = Hi(r7, n)
      , l = Na(n)
      , a = ji(e, o.triggerRef)
      , u = E.jsx(_r.button, {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": c7(o.open),
        ...r,
        ref: a,
        onClick: ki(t.onClick, o.onOpenToggle)
    });
    return o.hasCustomAnchor ? u : E.jsx(q5, {
        asChild: !0,
        ...l,
        children: u
    })
}
);
i7.displayName = r7;
var Tg = "PopoverPortal"
  , [Z_,W_] = e7(Tg, {
    forceMount: void 0
})
  , o7 = t => {
    const {__scopePopover: e, forceMount: n, children: r, container: o} = t
      , l = Hi(Tg, e);
    return E.jsx(Z_, {
        scope: e,
        forceMount: n,
        children: E.jsx(Eg, {
            present: n || l.open,
            children: E.jsx($5, {
                asChild: !0,
                container: o,
                children: r
            })
        })
    })
}
;
o7.displayName = Tg;
var Vl = "PopoverContent"
  , l7 = T.forwardRef( (t, e) => {
    const n = W_(Vl, t.__scopePopover)
      , {forceMount: r=n.forceMount, ...o} = t
      , l = Hi(Vl, t.__scopePopover);
    return E.jsx(Eg, {
        present: r || l.open,
        children: l.modal ? E.jsx(J_, {
            ...o,
            ref: e
        }) : E.jsx(Q_, {
            ...o,
            ref: e
        })
    })
}
);
l7.displayName = Vl;
var X_ = k5("PopoverContent.RemoveScroll")
  , J_ = T.forwardRef( (t, e) => {
    const n = Hi(Vl, t.__scopePopover)
      , r = T.useRef(null)
      , o = ji(e, r)
      , l = T.useRef(!1);
    return T.useEffect( () => {
        const a = r.current;
        if (a)
            return u_(a)
    }
    , []),
    E.jsx(Q5, {
        as: X_,
        allowPinchZoom: !0,
        children: E.jsx(s7, {
            ...t,
            ref: o,
            trapFocus: n.open,
            disableOutsidePointerEvents: !0,
            onCloseAutoFocus: ki(t.onCloseAutoFocus, a => {
                a.preventDefault(),
                l.current || n.triggerRef.current?.focus()
            }
            ),
            onPointerDownOutside: ki(t.onPointerDownOutside, a => {
                const u = a.detail.originalEvent
                  , f = u.button === 0 && u.ctrlKey === !0
                  , h = u.button === 2 || f;
                l.current = h
            }
            , {
                checkForDefaultPrevented: !1
            }),
            onFocusOutside: ki(t.onFocusOutside, a => a.preventDefault(), {
                checkForDefaultPrevented: !1
            })
        })
    })
}
)
  , Q_ = T.forwardRef( (t, e) => {
    const n = Hi(Vl, t.__scopePopover)
      , r = T.useRef(!1)
      , o = T.useRef(!1);
    return E.jsx(s7, {
        ...t,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: l => {
            t.onCloseAutoFocus?.(l),
            l.defaultPrevented || (r.current || n.triggerRef.current?.focus(),
            l.preventDefault()),
            r.current = !1,
            o.current = !1
        }
        ,
        onInteractOutside: l => {
            t.onInteractOutside?.(l),
            l.defaultPrevented || (r.current = !0,
            l.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const a = l.target;
            n.triggerRef.current?.contains(a) && l.preventDefault(),
            l.detail.originalEvent.type === "focusin" && o.current && l.preventDefault()
        }
    })
}
)
  , s7 = T.forwardRef( (t, e) => {
    const {__scopePopover: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: l, disableOutsidePointerEvents: a, onEscapeKeyDown: u, onPointerDownOutside: f, onFocusOutside: h, onInteractOutside: p, ...m} = t
      , y = Hi(Vl, n)
      , b = Na(n);
    return Rz(),
    E.jsx(R5, {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: l,
        children: E.jsx(A5, {
            asChild: !0,
            disableOutsidePointerEvents: a,
            onInteractOutside: p,
            onEscapeKeyDown: u,
            onPointerDownOutside: f,
            onFocusOutside: h,
            onDismiss: () => y.onOpenChange(!1),
            children: E.jsx(Xz, {
                "data-state": c7(y.open),
                role: "dialog",
                id: y.contentId,
                ...b,
                ...m,
                ref: e,
                style: {
                    ...m.style,
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
            })
        })
    })
}
)
  , a7 = "PopoverClose"
  , eB = T.forwardRef( (t, e) => {
    const {__scopePopover: n, ...r} = t
      , o = Hi(a7, n);
    return E.jsx(_r.button, {
        type: "button",
        ...r,
        ref: e,
        onClick: ki(t.onClick, () => o.onOpenChange(!1))
    })
}
);
eB.displayName = a7;
var tB = "PopoverArrow"
  , nB = T.forwardRef( (t, e) => {
    const {__scopePopover: n, ...r} = t
      , o = Na(n);
    return E.jsx(Jz, {
        ...o,
        ...r,
        ref: e
    })
}
);
nB.displayName = tB;
function c7(t) {
    return t ? "open" : "closed"
}
var rB = t7
  , iB = i7
  , oB = o7
  , lB = l7;
function u7({...t}) {
    return E.jsx(rB, {
        ...t
    })
}
function f7({...t}) {
    return E.jsx(iB, {
        ...t
    })
}
function d7({className: t, align: e="center", sideOffset: n=4, ...r}) {
    return E.jsx(oB, {
        children: E.jsx(lB, {
            align: e,
            sideOffset: n,
            className: It("tiptap-popover", t),
            ...r
        })
    })
}
const h7 = T.forwardRef( ({className: t, ...e}, n) => E.jsx("div", {
    ref: n,
    className: It("tiptap-card", t),
    ...e
}));
h7.displayName = "Card";
const sB = T.forwardRef( ({className: t, ...e}, n) => E.jsx("div", {
    ref: n,
    className: It("tiptap-card-header", t),
    ...e
}));
sB.displayName = "CardHeader";
const p7 = T.forwardRef( ({className: t, ...e}, n) => E.jsx("div", {
    ref: n,
    className: It("tiptap-card-body", t),
    ...e
}));
p7.displayName = "CardBody";
const m7 = T.forwardRef( ({className: t, orientation: e="vertical", ...n}, r) => E.jsx("div", {
    ref: r,
    "data-orientation": e,
    className: It("tiptap-card-item-group", t),
    ...n
}));
m7.displayName = "CardItemGroup";
const aB = T.forwardRef( ({className: t, ...e}, n) => E.jsx("div", {
    ref: n,
    className: It("tiptap-card-group-label", t),
    ...e
}));
aB.displayName = "CardGroupLabel";
const cB = T.forwardRef( ({className: t, ...e}, n) => E.jsx("div", {
    ref: n,
    className: It("tiptap-card-footer", t),
    ...e
}));
cB.displayName = "CardFooter";
function uB({className: t, type: e, ...n}) {
    return E.jsx("input", {
        type: e,
        className: It("tiptap-input", t),
        ...n
    })
}
function fB({className: t, children: e, ...n}) {
    return E.jsx("div", {
        className: It("tiptap-input-group", t),
        ...n,
        children: e
    })
}
const g7 = T.forwardRef( ({className: t, children: e, ...n}, r) => E.jsx(Bt, {
    type: "button",
    className: t,
    "data-style": "ghost",
    role: "button",
    tabIndex: -1,
    "aria-label": "",
    tooltip: "",
    ref: r,
    ...n,
    children: e || E.jsx(Sg, {
        className: "tiptap-button-icon"
    })
}));
g7.displayName = "LinkButton";
const dB = ({url: t, setUrl: e, setLink: n, removeLink: r, openLink: o, isActive: l}) => {
    const a = hz()
      , u = f => {
        f.key === "Enter" && (f.preventDefault(),
        n())
    }
    ;
    return E.jsx(h7, {
        style: {
            ...a ? {
                boxShadow: "none",
                border: 0
            } : {}
        },
        children: E.jsx(p7, {
            style: {
                ...a ? {
                    padding: 0
                } : {}
            },
            children: E.jsxs(m7, {
                orientation: "horizontal",
                children: [E.jsx(fB, {
                    children: E.jsx(uB, {
                        type: "url",
                        placeholder: "Paste a link...",
                        value: t,
                        onChange: f => e(f.target.value),
                        onKeyDown: u,
                        autoFocus: !0,
                        autoComplete: "off",
                        autoCorrect: "off",
                        autoCapitalize: "off"
                    })
                }), E.jsx(a1, {
                    orientation: "horizontal",
                    children: E.jsx(Bt, {
                        type: "button",
                        onClick: n,
                        title: "Apply link",
                        disabled: !t && !l,
                        "data-style": "ghost",
                        children: E.jsx(S5, {
                            className: "tiptap-button-icon"
                        })
                    })
                }), E.jsx(lg, {}), E.jsxs(a1, {
                    orientation: "horizontal",
                    children: [E.jsx(Bt, {
                        type: "button",
                        onClick: o,
                        title: "Open in new window",
                        disabled: !t && !l,
                        "data-style": "ghost",
                        children: E.jsx(x5, {
                            className: "tiptap-button-icon"
                        })
                    }), E.jsx(Bt, {
                        type: "button",
                        onClick: r,
                        title: "Remove link",
                        disabled: !t && !l,
                        "data-style": "ghost",
                        children: E.jsx(w5, {
                            className: "tiptap-button-icon"
                        })
                    })]
                })]
            })
        })
    })
}
  , y7 = T.forwardRef( ({editor: t, hideWhenUnavailable: e=!1, onSetLink: n, onOpenChange: r, autoOpenOnLinkActive: o=!0, onClick: l, children: a, ...u}, f) => {
    const {editor: h} = Vt(t)
      , [p,m] = T.useState(!1)
      , {isVisible: y, canSet: b, isActive: C, url: S, setUrl: w, setLink: k, removeLink: A, openLink: O, label: B, Icon: z} = gB({
        editor: h,
        hideWhenUnavailable: e,
        onSetLink: n
    })
      , $ = T.useCallback(ne => {
        m(ne),
        r?.(ne)
    }
    , [r])
      , _ = T.useCallback( () => {
        k(),
        m(!1)
    }
    , [k])
      , W = T.useCallback(ne => {
        l?.(ne),
        !ne.defaultPrevented && m(!p)
    }
    , [l, p]);
    return T.useEffect( () => {
        o && C && m(!0)
    }
    , [o, C]),
    y ? E.jsxs(u7, {
        open: p,
        onOpenChange: $,
        children: [E.jsx(f7, {
            asChild: !0,
            children: E.jsx(g7, {
                disabled: !b,
                "data-active-state": C ? "on" : "off",
                "data-disabled": !b,
                "aria-label": B,
                "aria-pressed": C,
                onClick: W,
                ...u,
                ref: f,
                children: a ?? E.jsx(z, {
                    className: "tiptap-button-icon"
                })
            })
        }), E.jsx(d7, {
            children: E.jsx(dB, {
                url: S,
                setUrl: w,
                setLink: _,
                removeLink: A,
                openLink: O,
                isActive: C
            })
        })]
    }) : null
}
);
y7.displayName = "LinkPopover";
function v7(t) {
    return !t || !t.isEditable || Ro(t, ["image"], !0) ? !1 : t.can().setMark("link")
}
function b7(t) {
    return !t || !t.isEditable ? !1 : t.isActive("link")
}
function hB(t) {
    const {editor: e, hideWhenUnavailable: n} = t;
    return !og("link", e) || !e ? !1 : n && !e.isActive("code") ? v7(e) : !0
}
function pB(t) {
    const {editor: e, onSetLink: n} = t
      , [r,o] = T.useState(null);
    T.useEffect( () => {
        if (!e)
            return;
        const {href: f} = e.getAttributes("link");
        b7(e) && r === null && o(f || "")
    }
    , [e, r]),
    T.useEffect( () => {
        if (!e)
            return;
        const f = () => {
            const {href: h} = e.getAttributes("link");
            o(h || "")
        }
        ;
        return e.on("selectionUpdate", f),
        () => {
            e.off("selectionUpdate", f)
        }
    }
    , [e]);
    const l = T.useCallback( () => {
        if (!r || !e)
            return;
        const {selection: f} = e.state
          , h = f.empty;
        let p = e.chain().focus();
        p = p.extendMarkRange("link").setLink({
            href: r
        }),
        h && !e.isActive("link") && (p = p.insertContent({
            type: "text",
            text: r
        })),
        p.run(),
        o(null),
        n?.()
    }
    , [e, n, r])
      , a = T.useCallback( () => {
        e && (e.chain().focus().extendMarkRange("link").unsetLink().setMeta("preventAutolink", !0).run(),
        o(""))
    }
    , [e])
      , u = T.useCallback( (f="_blank", h="noopener,noreferrer") => {
        if (!r)
            return;
        const p = mO(r, window.location.href);
        p !== "#" && window.open(p, f, h)
    }
    , [r]);
    return {
        url: r || "",
        setUrl: o,
        setLink: l,
        removeLink: a,
        openLink: u
    }
}
function mB(t) {
    const {editor: e, hideWhenUnavailable: n=!1} = t
      , r = v7(e)
      , o = b7(e)
      , [l,a] = T.useState(!0);
    return T.useEffect( () => {
        if (!e)
            return;
        const u = () => {
            a(hB({
                editor: e,
                hideWhenUnavailable: n
            }))
        }
        ;
        return u(),
        e.on("selectionUpdate", u),
        () => {
            e.off("selectionUpdate", u)
        }
    }
    , [e, n]),
    {
        isVisible: l,
        canSet: r,
        isActive: o
    }
}
function gB(t) {
    const {editor: e, hideWhenUnavailable: n=!1, onSetLink: r} = t || {}
      , {editor: o} = Vt(e)
      , {isVisible: l, canSet: a, isActive: u} = mB({
        editor: o,
        hideWhenUnavailable: n
    })
      , f = pB({
        editor: o,
        onSetLink: r
    });
    return {
        isVisible: l,
        canSet: a,
        isActive: u,
        label: "",
        Icon: Sg,
        ...f
    }
}
const yB = ({className: t}) => E.jsxs("svg", {
    className: t,
    width: "18",
    height: "18",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [E.jsx("rect", {
        x: "3",
        y: "3",
        width: "18",
        height: "18",
        rx: "2"
    }), E.jsx("line", {
        x1: "3",
        y1: "9",
        x2: "21",
        y2: "9"
    }), E.jsx("line", {
        x1: "3",
        y1: "15",
        x2: "21",
        y2: "15"
    }), E.jsx("line", {
        x1: "9",
        y1: "3",
        x2: "9",
        y2: "21"
    }), E.jsx("line", {
        x1: "15",
        y1: "3",
        x2: "15",
        y2: "21"
    })]
})
  , C7 = T.forwardRef( ({editor: t}, e) => {
    const {editor: n} = Vt(t)
      , [r,o] = T.useState(!1)
      , l = n?.isActive("table") ?? !1
      , a = T.useCallback(u => {
        u(),
        o(!1)
    }
    , []);
    return n ? E.jsxs(u7, {
        open: r,
        onOpenChange: o,
        children: [E.jsx(f7, {
            asChild: !0,
            children: E.jsx(Bt, {
                type: "button",
                "data-style": "ghost",
                "data-active-state": l ? "on" : "off",
                "aria-label": "",
                tooltip: "",
                ref: e,
                onClick: () => o(!r),
                children: E.jsx(yB, {
                    className: "tiptap-button-icon"
                })
            })
        }), E.jsx(d7, {
            children: E.jsxs("div", {
                className: "table-popover-menu",
                children: [!l && E.jsx("button", {
                    className: "table-popover-item",
                    onClick: () => a( () => n.chain().focus().insertTable({
                        rows: 3,
                        cols: 3,
                        withHeaderRow: !0
                    }).run()),
                    children: " "
                }), l && E.jsxs(E.Fragment, {
                    children: [E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().addRowBefore().run()),
                        children: " "
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().addRowAfter().run()),
                        children: " "
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().addColumnBefore().run()),
                        children: " "
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().addColumnAfter().run()),
                        children: " "
                    }), E.jsx("div", {
                        className: "table-popover-separator"
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().deleteRow().run()),
                        children: " "
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().deleteColumn().run()),
                        children: " "
                    }), E.jsx("div", {
                        className: "table-popover-separator"
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().mergeCells().run()),
                        children: " "
                    }), E.jsx("button", {
                        className: "table-popover-item",
                        onClick: () => a( () => n.chain().focus().splitCell().run()),
                        children: " "
                    }), E.jsx("div", {
                        className: "table-popover-separator"
                    }), E.jsx("button", {
                        className: "table-popover-item table-popover-item--danger",
                        onClick: () => a( () => n.chain().focus().deleteTable().run()),
                        children: " "
                    })]
                })]
            })
        })]
    }) : null
}
);
C7.displayName = "TablePopover";
function vB({orientation: t="horizontal", size: e, style: n={}, ...r}) {
    const o = {
        ...n,
        ...t === "horizontal" && !e && {
            flex: 1
        },
        ...e && {
            width: t === "vertical" ? "1px" : e,
            height: t === "horizontal" ? "1px" : e
        }
    };
    return E.jsx("div", {
        ...r,
        style: o
    })
}
const S7 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M4 7V4h16v3"
    }), E.jsx("path", {
        d: "M5 20h6"
    }), E.jsx("path", {
        d: "M13 4 8 20"
    }), E.jsx("path", {
        d: "m15 15 5 5"
    }), E.jsx("path", {
        d: "m20 15-5 5"
    })]
}));
S7.displayName = "RemoveFormattingIcon";
function bB({onContentChange: t, initialContent: e, onClear: n}) {
    const r = l8({
        extensions: sO,
        content: e || "",
        editorProps: {
            transformPastedHTML(o) {
                return o = o.replace(/<p([^>]*)>\s*(<span[^>]*>\s*)?<br\s*\/?>(\s*<\/span>)?\s*<\/p>/gi, "<p$1></p>"),
                o = aO(o),
                o
            }
        },
        onUpdate: ({editor: o}) => {
            t(o.getHTML())
        }
    });
    return r ? E.jsxs("div", {
        className: "editor-wrapper",
        children: [E.jsxs(g4, {
            variant: "fixed",
            "aria-label": "Editor toolbar",
            children: [E.jsxs(lo, {
                children: [E.jsx(u1, {
                    editor: r,
                    action: "undo"
                }), E.jsx(u1, {
                    editor: r,
                    action: "redo"
                })]
            }), E.jsx(Zs, {}), E.jsxs(lo, {
                children: [E.jsx(Ws, {
                    editor: r,
                    level: 1
                }), E.jsx(Ws, {
                    editor: r,
                    level: 2
                }), E.jsx(Ws, {
                    editor: r,
                    level: 3
                }), E.jsx(Ws, {
                    editor: r,
                    level: 4
                })]
            }), E.jsx(Zs, {}), E.jsxs(lo, {
                children: [E.jsx(Tl, {
                    editor: r,
                    type: "bold"
                }), E.jsx(Tl, {
                    editor: r,
                    type: "italic"
                }), E.jsx(Tl, {
                    editor: r,
                    type: "underline"
                }), E.jsx(Tl, {
                    editor: r,
                    type: "strike"
                }), E.jsx(Tl, {
                    editor: r,
                    type: "code"
                }), E.jsx(Bt, {
                    "data-style": "ghost",
                    "aria-label": " ",
                    tooltip: " ",
                    onClick: () => r.chain().focus().unsetAllMarks().clearNodes().run(),
                    children: E.jsx(S7, {
                        className: "tiptap-button-icon"
                    })
                })]
            }), E.jsx(Zs, {}), E.jsxs(lo, {
                children: [E.jsx(c1, {
                    editor: r,
                    type: "bulletList"
                }), E.jsx(c1, {
                    editor: r,
                    type: "orderedList"
                }), E.jsx(d5, {
                    editor: r
                }), E.jsx(m5, {
                    editor: r
                }), E.jsx(C7, {
                    editor: r
                })]
            }), E.jsx(Zs, {}), E.jsx(lo, {
                children: E.jsx(y7, {
                    editor: r
                })
            }), E.jsx(vB, {}), E.jsx(lo, {
                children: E.jsx(Bt, {
                    "data-style": "ghost",
                    "aria-label": "",
                    onClick: () => {
                        r.commands.clearContent(!0),
                        n?.()
                    }
                    ,
                    children: E.jsxs("svg", {
                        width: "18",
                        height: "18",
                        viewBox: "0 0 24 24",
                        fill: "none",
                        stroke: "currentColor",
                        strokeWidth: "2",
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        children: [E.jsx("polyline", {
                            points: "3 6 5 6 21 6"
                        }), E.jsx("path", {
                            d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"
                        })]
                    })
                })
            })]
        }), E.jsx(R3, {
            editor: r,
            className: "editor-content"
        })]
    }) : null
}
const x7 = {
    "": "&copy;",
    "": "&reg;",
    "": "&trade;",
    "": "&mdash;",
    "": "&ndash;",
    "": "&laquo;",
    "": "&raquo;",
    "": "&hellip;",
    "": "&rarr;",
    "": "&larr;",
    "": "&uarr;",
    "": "&darr;",
    "": "&euro;",
    "": "&pound;",
    "": "&yen;",
    "": "&plusmn;",
    "": "&times;",
    "": "&divide;",
    "": "&deg;",
    "": "&para;",
    "": "&sect;"
}
  , CB = new RegExp(Object.keys(x7).map(t => t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|"),"g");
function SB(t, e) {
    let n = t;
    return n = n.replace(/<colgroup[\s\S]*?<\/colgroup>/gi, ""),
    e.characterEncoding && (n = n.replace(CB, r => x7[r])),
    e.removeInlineStyles && (n = n.replace(/\s*style="[^"]*"/gi, "")),
    e.removeAttributes && (n = n.replace(/\s*class="[^"]*"/gi, ""),
    n = n.replace(/\s*id="[^"]*"/gi, "")),
    e.removeAllAttributes && (n = n.replace(/<(\w+)\s+[^>]*?(\/?)>/g, "<$1$2>")),
    e.removeComments && (n = n.replace(/<!--[\s\S]*?-->/g, "")),
    e.removeSpanTags && (n = n.replace(/<span\b[^>]*>([\s\S]*?)<\/span>/gi, "$1")),
    e.removeImages && (n = n.replace(/<figure\b[^>]*>[\s\S]*?<\/figure>/gi, ""),
    n = n.replace(/<img\b[^>]*\/?>/gi, "")),
    e.removeLinks && (n = n.replace(/<a\b[^>]*>([\s\S]*?)<\/a>/gi, "$1")),
    e.convertTablesToDivs && (n = n.replace(/<table\b[^>]*>/gi, '<div class="table">'),
    n = n.replace(/<\/table>/gi, "</div>"),
    n = n.replace(/<thead\b[^>]*>/gi, '<div class="table-head">'),
    n = n.replace(/<\/thead>/gi, "</div>"),
    n = n.replace(/<tbody\b[^>]*>/gi, '<div class="table-body">'),
    n = n.replace(/<\/tbody>/gi, "</div>"),
    n = n.replace(/<tfoot\b[^>]*>/gi, '<div class="table-foot">'),
    n = n.replace(/<\/tfoot>/gi, "</div>"),
    n = n.replace(/<tr\b[^>]*>/gi, '<div class="table-row">'),
    n = n.replace(/<\/tr>/gi, "</div>"),
    n = n.replace(/<t[dh]\b[^>]*>/gi, '<div class="table-cell">'),
    n = n.replace(/<\/t[dh]>/gi, "</div>")),
    e.removeTableTags && (n = n.replace(/<\/?(table|thead|tbody|tfoot|tr|td|th)\b[^>]*>/gi, "")),
    e.removeSuccessiveNbsp && (n = n.replace(/(&nbsp;\s*){2,}/gi, "&nbsp;")),
    e.removeTagsWithNbsp && (n = n.replace(/<(p|span|div|strong|em|b|i|u)(\s[^>]*)?>(&nbsp;)<\/\1>/gi, "")),
    e.removeEmptyTags && (n = n.replace(/<(p|span|div|strong|em|b|i|u)(\s[^>]*)?>(\s|&nbsp;|<br\s*\/?>)*<\/\1>/gi, "")),
    e.removeAllTags && (n = n.replace(/<[^>]+>/g, "")),
    n
}
const hS = `<figure class="img">
<img src="" alt="img" width="">
<p class="grey-text"></p>
</figure>`;
function xB(t, e) {
    let n = t;
    return e.replaceFormulaAlerts && (n = n.replace(/<p id="gdcalert\d+"[^>]*>\s*<span[^>]*>[^<]*gd2md-html alert: equation:.*?<\/span>.*?<\/p>/gs, `<!--  -->
\\(\\)`)),
    e.replaceImageAlerts && (n = n.replace(/<td>\s*<p id="gdcalert\d+"[^>]*>.*?gd2md-html alert.*?<img src="([^"]+)"[^>]*>\s*<\/td>/gs, `<td>
${hS}
</td>`),
    n = n.replace(/<p id="gdcalert\d+"[^>]*>\s*<span[^>]*>[^<]*gd2md-html alert.*?<\/span>.*?<img src="([^"]+)"[^>]*>/gs, hS),
    n = n.replace(/<p[^>]*>\s*<p id="gdcalert\d+"[^>]*>[\s\S]*?<\/p>\s*<img src="([^"]+)"[^>]*>[\s\S]*?<\/p>/gs, `<figure class="img">
<img src="$1" alt="img">
<p class="grey-text"></p>
</figure>`)),
    n
}
const h1 = `<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M6.99581 3.99658C6.99581 6.20664 5.2042 7.99825 2.99414 7.99825C5.2042 7.99825 6.99581 9.78986 6.99581 11.9999C6.99581 9.78986 8.78741 7.99825 10.9975 7.99825C8.78741 7.99825 6.99581 6.20664 6.99581 3.99658Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
  <path fill-rule="evenodd" clip-rule="evenodd" d="M18.0021 16.0017C18.0021 13.2392 15.7626 10.9996 13 10.9996C15.7626 10.9996 18.0021 8.76013 18.0021 5.99756C18.0021 8.76013 20.2416 10.9996 23.0042 10.9996C20.2416 10.9996 18.0021 13.2392 18.0021 16.0017Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.9978 14.501C10.9978 16.711 9.20615 18.5026 6.99609 18.5026C9.20615 18.5026 10.9978 20.2942 10.9978 22.5043C10.9978 20.2942 12.7894 18.5026 14.9994 18.5026C12.7894 18.5026 10.9978 16.711 10.9978 14.501Z" stroke="#D1D0FD" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
</svg>`
  , wB = `<svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none">
  <path fill-rule="evenodd" clip-rule="evenodd" d="M12.9998 17.8658C10.971 15.8359 7.91272 15.4628 5.50472 16.7463C4.82144 17.1105 3.99609 16.6613 3.99609 15.887V6.79116C3.99609 6.1549 4.29022 5.54264 4.80843 5.17349C7.29447 3.40075 10.7689 3.62985 12.9998 5.86078C15.2308 3.62985 18.7052 3.40075 21.1913 5.17349C21.7095 5.54264 22.0036 6.1549 22.0036 6.79116V15.887C22.0036 16.6613 21.1782 17.1115 20.495 16.7463C18.087 15.4628 15.0287 15.8359 12.9998 17.8658Z" stroke="#FFF0EC" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
  <path d="M5.50391 20.8845C7.91191 19.601 10.9702 19.9741 12.999 22.004C15.0279 19.9741 18.0861 19.601 20.4941 20.8845" stroke="#FFF0EC" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
  <path d="M13.0002 17.8663V5.86133" stroke="#FFF0EC" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" />
</svg>`;
function pS(t, e, n, r) {
    return `<div class="color-container container-flex ${t}">
<div class="container-icon">
${e}
</div>
<${n}>${r}</${n}>
</div>`
}
function oo(t, e, n, r, o) {
    let l = ""
      , a = 0;
    for (; ; ) {
        const u = t.slice(a).match(e);
        if (!u || u.index === void 0) {
            l += t.slice(a);
            break
        }
        const f = a + u.index;
        l += t.slice(a, f);
        const p = t.slice(f + u[0].length).match(n);
        if (!p || p.index === void 0) {
            l += t.slice(f, f + u[0].length),
            a = f + u[0].length;
            continue
        }
        const m = f + u[0].length + p.index + p[0].length
          , b = t.slice(f + u[0].length, f + u[0].length + p.index).replace(/<br\s*\/?>/gi, "")
          , C = r + b + o;
        l += C,
        a = m
    }
    return l
}
const Ps = t => new RegExp(`<p>\\s*(<br>\\s*)?<strong>\\s*\\$${t}\\s*<\\/strong>\\s*(<br>\\s*)?<\\/p>|<strong>\\s*\\$${t}\\s*<\\/strong>\\s*(<br>\\s*)?|<p>\\s*(<br>\\s*)?\\$${t}\\s*(<br>\\s*)?<\\/p>`)
  , qs = /<p>\s*(<br>\s*)?<strong>\s*\$end\s*<\/strong>\s*(<br>\s*)?<\/p>|<strong>\s*\$end\s*<\/strong>\s*(<br>\s*)?|<p>\s*(<br>\s*)?\$end\s*(<br>\s*)?<\/p>/
  , mS = t => new RegExp(`<p[^>]*>\\s*\\$${t}[\\s\\S]*?`)
  , gS = /\$end[\s\S]*?<\/p>/;
function EB(t, e) {
    let n = t;
    if (e.transformCase && (n = oo(n, Ps("case"), qs, `<div class="block-example">
<div class="example-title"></div>`, "</div>")),
    e.transformTerm && (n = oo(n, Ps("term"), qs, '<div class="term">', "</div>"),
    n = oo(n, mS("term"), gS, '<div class="term">', "</div>")),
    e.transformCode && (n = oo(n, Ps("code"), qs, '<pre class="prettyprint"><code>', "</code></pre>")),
    e.transformImp) {
        const r = e.impBiblioWrapper
          , o = `<div class="color-container container-flex blue-container">
<div class="container-icon">
${h1}
</div>
<${r}>`
          , l = `</${r}>
</div>`;
        n = oo(n, Ps("imp"), qs, o, l),
        n = oo(n, mS("imp"), gS, o, l)
    }
    if (e.transformBiblio) {
        const r = e.impBiblioWrapper
          , o = `<div class="color-container container-flex orange-container">
<div class="container-icon">
${wB}
</div>
<${r}>`
          , l = `</${r}>
</div>`;
        n = oo(n, Ps("biblio"), qs, o, l)
    }
    if (e.transformHeadings && (n = n.replace(/<h1(\s+[^>]*)?>/g, '<div class="h1">').replace(/<\/h1>/g, "</div>").replace(/<h2(\s+[^>]*)?>/g, '<div class="h2">').replace(/<\/h2>/g, "</div>").replace(/<h3(\s+[^>]*)?>/g, '<div class="h3">').replace(/<\/h3>/g, "</div>")),
    e.transformH4 && (n = n.replace(/<h4(\s+[^>]*)?>/g, '<div class="text-problem-title">').replace(/<\/h4>/g, "</div>")),
    e.transformLists && (n = n.replace(/<ul>/g, '<ul class="list">').replace(/<ol>/g, '<ol class="ordered-list">')),
    e.transformLinks && (n = n.replace(/<a(?![^>]*target=["']_blank["'])/g, '<a target="_blank"').replace(/(<a\s)([^>]*?)(\s*rel=["'][^"']*["'])/g, "$1$2").replace(/<a(?!\s+rel=)/g, '<a rel="noopener noreferrer nofollow"')),
    e.transformTables && (n = n.replace(/<table[^>]*>/gi, `<div class="overflow-table">
<table>
<tbody>`).replace(/<\/table[^>]*>/gi, `</tbody>
</table>
</div>`)),
    e.transformCode) {
        const r = e.codeLanguage;
        n = n.replace(/<pre class="prettyprint">|<pre>/g, `<pre class="language-${r}">`)
    }
    return e.transformFormulas && (n = n.replace(/\$\$([^$]+)\$\$/g, "\\($1\\)")),
    e.wrapInMainBlock && (n = `<div class="main-block">
` + n + `
</div>`),
    n
}
function TB(t, e) {
    let n = t;
    return e.convertLegacyBlocks && (n = n.replace(/<div\b[^>]*style=["']padding:\s*20px;\s*margin:\s*20px;\s*border:\s*2px\s*solid\s*#00b43f;\s*border-radius:\s*10px;["'][^>]*>/gi, '<div class="term">'),
    n = n.replace(/<!--\s*HTML generated using hilite\.me\s*-->/gi, ""),
    n = n.replace(/<div\b[^>]*style=["']border-left:\s*5px\s*solid\s*#00b43f;\s*padding-left:\s*10px;["'][^>]*>([\s\S]*?)<\/div>/gi, "$1"),
    n = n.replace(/<div[^>]*\s*style="background:\s*#f8f8f8;\s*overflow:\s*auto;\s*width:\s*auto;\s*max-width:\s*800px;\s*border:\s*solid\s+#d1d9d7;\s*border-width:\s*\.1em;\s*border-radius:\s*10px;\s*padding:\s*\.2em\s*\.6em;\s*margin:\s*20px\s*auto\s*20px\s*auto;"\s*[^>]*>(.*?)<\/div>/gs, "$1"),
    n = n.replace(/(<pre[^>]*>)([\s\S]*?)(<\/pre>)/gi, (r, o, l, a) => o + l.replace(/<\/?span[^>]*>/g, "") + a),
    n = n.replace(/(<div style="background-color: #f5f5f5; padding: 15px;">)([\s\S]*?)(<\/div>)/, (r, o, l) => '<div class="module-author"><div class="module-author-descr">' + l + "</div></div>"),
    n = n.replace(/<div class="important">\s*<p>(.*?)<\/p>\s*<\/div>/gs, (r, o) => pS("blue-container", h1, e.impBiblioWrapper, o)),
    n = n.replace(/<div\s+class="important\s+important-filled">([\s\S]*?)<\/div>/g, (r, o) => pS("blue-container", h1, e.impBiblioWrapper, o)),
    n = n.replace(/<div\s+class="example">/g, '<div class="block-example">'),
    n = n.replace(/<figure\s+class="img">\s*<img\s+class="img-bg"\s+src="\/asset-v1:SkillFactory\+MIPTDPM\+SEPT22\+type@asset\+block@star-fill\.svg"\s+width="24"\s+height="24">\s*<\/figure>/g, ""),
    n = n.replace(/<div class="glossary">/g, '<div class="color-container blue-container">')),
    e.deleteExampleTitleDiv && (n = n.replace(/\s*<div\s+class="example-title">\s*\s*<\/div>\s*/gi, "")),
    e.cleanDivStyles && (n = n.replace(/<div(?![^>]*style="\s*position:\s*relative;\s*padding-top:\s*56\.25%;\s*width:\s*100%;\s*margin-bottom:\s*50px;\s*")[^>]*\s*style="[^"]*"\s*([^>]*)>/g, "<div$1>")),
    e.removeEmTags && (n = n.replace(/<em\b[^>]*>/gi, ""),
    n = n.replace(/<\/em>/gi, "")),
    n
}
const kB = new Set(["div", "p", "h1", "h2", "h3", "h4", "h5", "h6", "ul", "ol", "li", "table", "tr", "td", "th", "thead", "tbody", "section", "article", "blockquote", "pre", "hr", "br", "figure", "figcaption", "details", "summary", "main", "header", "footer", "nav", "aside", "form", "fieldset"])
  , MB = new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]);
function AB(t) {
    const e = t.match(/^<\/?(\w+)/);
    return e ? e[1].toLowerCase() : null
}
function NB(t) {
    const e = t.match(/(<[^>]+>)|([^<]+)/g);
    if (!e)
        return t;
    const n = [];
    let r = 0
      , o = "";
    const l = [];
    function a() {
        o.trim() && n.push("  ".repeat(r) + o.trim()),
        o = ""
    }
    for (const u of e) {
        const f = u.trim();
        if (!f)
            continue;
        const h = f.startsWith("<") ? AB(f) : null;
        if (!(h !== null && kB.has(h))) {
            o += f;
            continue
        }
        if (f.startsWith("</")) {
            const y = l.pop();
            y && n.length === y.lineIndex + 1 ? (r = Math.max(0, r - 1),
            n[y.lineIndex] += o.trim() + f,
            o = "") : (a(),
            r = Math.max(0, r - 1),
            n.push("  ".repeat(r) + f))
        } else {
            a();
            const y = n.length;
            n.push("  ".repeat(r) + f);
            const b = f.endsWith("/>")
              , C = h !== null && MB.has(h);
            !b && !C && (l.push({
                lineIndex: y
            }),
            r++)
        }
    }
    return a(),
    n.join(`
`)
}
const w7 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C22 11.5955 21.7564 11.2309 21.3827 11.0761C21.009 10.9213 20.5789 11.0069 20.2929 11.2929C19.287 12.2988 17.9226 12.864 16.5 12.864C15.0774 12.864 13.713 12.2988 12.7071 11.2929C11.7012 10.287 11.136 8.92261 11.136 7.5C11.136 6.07739 11.7012 4.71304 12.7071 3.70711C12.9931 3.42111 13.0787 2.99099 12.9239 2.61732C12.7691 2.24364 12.4045 2 12 2ZM7.55544 5.34824C8.27036 4.87055 9.05353 4.51389 9.87357 4.28778C9.39271 5.27979 9.13604 6.37666 9.13604 7.5C9.13604 9.45304 9.91189 11.3261 11.2929 12.7071C12.6739 14.0881 14.547 14.864 16.5 14.864C17.6233 14.864 18.7202 14.6073 19.7122 14.1264C19.4861 14.9465 19.1295 15.7296 18.6518 16.4446C17.7727 17.7602 16.5233 18.7855 15.0615 19.391C13.5997 19.9965 11.9911 20.155 10.4393 19.8463C8.88743 19.5376 7.46197 18.7757 6.34315 17.6569C5.22433 16.538 4.4624 15.1126 4.15372 13.5607C3.84504 12.0089 4.00347 10.4003 4.60897 8.93853C5.21447 7.47672 6.23985 6.22729 7.55544 5.34824Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M19 2C19.5523 2 20 2.44772 20 3V4H21C21.5523 4 22 4.44772 22 5C22 5.55228 21.5523 6 21 6H20V7C20 7.55228 19.5523 8 19 8C18.4477 8 18 7.55228 18 7V6H17C16.4477 6 16 5.55228 16 5C16 4.44772 16.4477 4 17 4H18V3C18 2.44772 18.4477 2 19 2Z",
        fill: "currentColor"
    })]
}));
w7.displayName = "MoonStarIcon";
const E7 = T.memo( ({className: t, ...e}) => E.jsxs("svg", {
    width: "24",
    height: "24",
    className: t,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    ...e,
    children: [E.jsx("path", {
        d: "M12 1C12.5523 1 13 1.44772 13 2V4C13 4.55228 12.5523 5 12 5C11.4477 5 11 4.55228 11 4V2C11 1.44772 11.4477 1 12 1Z",
        fill: "currentColor"
    }), E.jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M7 12C7 9.23858 9.23858 7 12 7C14.7614 7 17 9.23858 17 12C17 14.7614 14.7614 17 12 17C9.23858 17 7 14.7614 7 12ZM12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M13 20C13 19.4477 12.5523 19 12 19C11.4477 19 11 19.4477 11 20V22C11 22.5523 11.4477 23 12 23C12.5523 23 13 22.5523 13 22V20Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M4.22282 4.22289C4.61335 3.83236 5.24651 3.83236 5.63704 4.22289L7.04704 5.63289C7.43756 6.02341 7.43756 6.65658 7.04704 7.0471C6.65651 7.43762 6.02335 7.43762 5.63283 7.0471L4.22282 5.6371C3.8323 5.24658 3.8323 4.61341 4.22282 4.22289Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M18.367 16.9529C17.9765 16.5623 17.3433 16.5623 16.9528 16.9529C16.5623 17.3434 16.5623 17.9766 16.9528 18.3671L18.3628 19.7771C18.7533 20.1676 19.3865 20.1676 19.777 19.7771C20.1675 19.3866 20.1675 18.7534 19.777 18.3629L18.367 16.9529Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M1 12C1 11.4477 1.44772 11 2 11H4C4.55228 11 5 11.4477 5 12C5 12.5523 4.55228 13 4 13H2C1.44772 13 1 12.5523 1 12Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M20 11C19.4477 11 19 11.4477 19 12C19 12.5523 19.4477 13 20 13H22C22.5523 13 23 12.5523 23 12C23 11.4477 22.5523 11 22 11H20Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M7.04704 16.9529C7.43756 17.3434 7.43756 17.9766 7.04704 18.3671L5.63704 19.7771C5.24651 20.1676 4.61335 20.1676 4.22282 19.7771C3.8323 19.3866 3.8323 18.7534 4.22283 18.3629L5.63283 16.9529C6.02335 16.5623 6.65651 16.5623 7.04704 16.9529Z",
        fill: "currentColor"
    }), E.jsx("path", {
        d: "M19.777 5.6371C20.1675 5.24657 20.1675 4.61341 19.777 4.22289C19.3865 3.83236 18.7533 3.83236 18.3628 4.22289L16.9528 5.63289C16.5623 6.02341 16.5623 6.65658 16.9528 7.0471C17.3433 7.43762 17.9765 7.43762 18.367 7.0471L19.777 5.6371Z",
        fill: "currentColor"
    })]
}));
E7.displayName = "SunIcon";
const p1 = "theme";
function RB() {
    const t = localStorage.getItem(p1);
    return t === "dark" ? !0 : t === "light" ? !1 : window.matchMedia("(prefers-color-scheme: dark)").matches
}
function OB() {
    const [t,e] = T.useState(RB);
    T.useEffect( () => {
        if (localStorage.getItem(p1))
            return;
        const o = window.matchMedia("(prefers-color-scheme: dark)")
          , l = () => e(o.matches);
        return o.addEventListener("change", l),
        () => o.removeEventListener("change", l)
    }
    , []),
    T.useEffect( () => {
        document.documentElement.classList.toggle("dark", t),
        localStorage.setItem(p1, t ? "dark" : "light")
    }
    , [t]);
    const n = () => e(r => !r);
    return E.jsx(Bt, {
        onClick: n,
        "aria-label": `Switch to ${t ? "light" : "dark"} mode`,
        "data-style": "ghost",
        children: t ? E.jsx(w7, {
            className: "tiptap-button-icon"
        }) : E.jsx(E7, {
            className: "tiptap-button-icon"
        })
    })
}
function DB({htmlContent: t, settings: e, onOpenSettings: n}) {
    const [r,o] = T.useState(!0)
      , l = T.useMemo( () => {
        let f = t;
        return f = xB(f, e.skillfactory),
        f = TB(f, e.skillfactory),
        f = SB(f, e.general),
        f = EB(f, e.skillfactory),
        f
    }
    , [t, e])
      , a = T.useMemo( () => r ? NB(l) : l, [r, l])
      , u = T.useCallback(async () => {
        try {
            await navigator.clipboard.writeText(a)
        } catch (f) {
            console.error("Failed to copy:", f)
        }
    }
    , [a]);
    return E.jsxs("div", {
        className: "preview-wrapper",
        children: [E.jsxs("div", {
            className: "preview-toolbar",
            children: [E.jsx("button", {
                className: "preview-btn preview-btn--icon",
                onClick: n,
                title: " ",
                children: E.jsxs("svg", {
                    width: "20",
                    height: "20",
                    viewBox: "0 0 20 20",
                    fill: "none",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: [E.jsx("path", {
                        d: "M10 12.5C11.3807 12.5 12.5 11.3807 12.5 10C12.5 8.61929 11.3807 7.5 10 7.5C8.61929 7.5 7.5 8.61929 7.5 10C7.5 11.3807 8.61929 12.5 10 12.5Z",
                        stroke: "currentColor",
                        strokeWidth: "1.5"
                    }), E.jsx("path", {
                        d: "M16.0833 10C16.0833 9.57497 16.025 9.16664 15.9333 8.77497L17.5 7.51664L15.8333 4.64997L13.9667 5.34164C13.3417 4.8083 12.6083 4.39997 11.8083 4.14997L11.5 2.1333H8.49999L8.19166 4.14997C7.39166 4.39997 6.65833 4.8083 6.03333 5.34164L4.16666 4.64997L2.49999 7.51664L4.06666 8.77497C3.97499 9.16664 3.91666 9.57497 3.91666 10C3.91666 10.425 3.97499 10.8333 4.06666 11.225L2.49999 12.4833L4.16666 15.35L6.03333 14.6583C6.65833 15.1916 7.39166 15.6 8.19166 15.85L8.49999 17.8666H11.5L11.8083 15.85C12.6083 15.6 13.3417 15.1916 13.9667 14.6583L15.8333 15.35L17.5 12.4833L15.9333 11.225C16.025 10.8333 16.0833 10.425 16.0833 10Z",
                        stroke: "currentColor",
                        strokeWidth: "1.5"
                    })]
                })
            }), E.jsx("button", {
                className: "preview-btn",
                onClick: u,
                children: " HTML"
            }), E.jsx("button", {
                className: `preview-btn${r ? "" : " preview-btn--active"}`,
                onClick: () => o(f => !f),
                children: r ? "" : ""
            }), E.jsx("span", {
                style: {
                    marginLeft: "auto"
                },
                children: E.jsx(OB, {})
            })]
        }), E.jsx("div", {
            className: "preview-content",
            children: E.jsx("pre", {
                children: E.jsx("code", {
                    children: a
                })
            })
        })]
    })
}
const Xs = {
    general: {
        removeInlineStyles: !0,
        removeAttributes: !0,
        removeEmptyTags: !0,
        removeComments: !0,
        characterEncoding: !0,
        removeSpanTags: !0,
        removeSuccessiveNbsp: !0,
        removeTagsWithNbsp: !0,
        removeAllAttributes: !1,
        removeAllTags: !1,
        removeImages: !1,
        removeLinks: !1,
        removeTableTags: !1,
        convertTablesToDivs: !1
    },
    skillfactory: {
        wrapInMainBlock: !1,
        transformHeadings: !0,
        transformH4: !0,
        transformLists: !0,
        transformLinks: !0,
        transformTables: !0,
        transformCode: !0,
        transformTerm: !0,
        transformImp: !0,
        transformBiblio: !0,
        transformCase: !0,
        transformFormulas: !1,
        codeLanguage: "python",
        impBiblioWrapper: "span",
        convertLegacyBlocks: !0,
        deleteExampleTitleDiv: !1,
        cleanDivStyles: !1,
        removeEmTags: !1,
        replaceFormulaAlerts: !0,
        replaceImageAlerts: !0
    }
}
  , LB = [{
    value: "python",
    label: "Python"
}, {
    value: "java",
    label: "Java"
}, {
    value: "javascript",
    label: "JavaScript"
}, {
    value: "cpp",
    label: "C++"
}, {
    value: "csharp",
    label: "C#"
}, {
    value: "c",
    label: "C"
}, {
    value: "php",
    label: "PHP"
}, {
    value: "markup",
    label: "Markup"
}];
function zB({isOpen: t, settings: e, onSettingsChange: n, onClose: r}) {
    if (!t)
        return null;
    const o = (a, u) => {
        n({
            ...e,
            general: {
                ...e.general,
                [a]: u
            }
        })
    }
      , l = (a, u) => {
        n({
            ...e,
            skillfactory: {
                ...e.skillfactory,
                [a]: u
            }
        })
    }
    ;
    return E.jsx("div", {
        className: "modal-overlay",
        onClick: r,
        children: E.jsxs("div", {
            className: "modal",
            onClick: a => a.stopPropagation(),
            children: [E.jsx("h2", {
                className: "modal__title",
                children: " "
            }), E.jsxs("section", {
                className: "modal__section",
                children: [E.jsx("h3", {
                    className: "modal__section-title",
                    children: ""
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeInlineStyles,
                        onChange: a => o("removeInlineStyles", a.target.checked)
                    }), " -"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeAttributes,
                        onChange: a => o("removeAttributes", a.target.checked)
                    }), "   (class, id)"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.characterEncoding,
                        onChange: a => o("characterEncoding", a.target.checked)
                    }), "   HTML-"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeComments,
                        onChange: a => o("removeComments", a.target.checked)
                    }), " HTML-"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeSpanTags,
                        onChange: a => o("removeSpanTags", a.target.checked)
                    }), " <span> "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeSuccessiveNbsp,
                        onChange: a => o("removeSuccessiveNbsp", a.target.checked)
                    }), "   &nbsp;"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeTagsWithNbsp,
                        onChange: a => o("removeTagsWithNbsp", a.target.checked)
                    }), "    &nbsp;"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeEmptyTags,
                        onChange: a => o("removeEmptyTags", a.target.checked)
                    }), "  "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeAllAttributes,
                        onChange: a => o("removeAllAttributes", a.target.checked)
                    }), "   "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeAllTags,
                        onChange: a => o("removeAllTags", a.target.checked)
                    }), "  "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeImages,
                        onChange: a => o("removeImages", a.target.checked)
                    }), " "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeLinks,
                        onChange: a => o("removeLinks", a.target.checked)
                    }), "  ( )"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.removeTableTags,
                        onChange: a => o("removeTableTags", a.target.checked)
                    }), "  "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.general.convertTablesToDivs,
                        onChange: a => o("convertTablesToDivs", a.target.checked)
                    }), "   <div>"]
                })]
            }), E.jsxs("section", {
                className: "modal__section",
                children: [E.jsx("h3", {
                    className: "modal__section-title",
                    children: "Skillfactory"
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.wrapInMainBlock,
                        onChange: a => l("wrapInMainBlock", a.target.checked)
                    }), "   div.main-block"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformFormulas,
                        onChange: a => l("transformFormulas", a.target.checked)
                    }), "  $$...$$  \\(\\)"]
                }), E.jsx("div", {
                    className: "modal__select-group",
                    children: E.jsxs("label", {
                        className: "modal__select-label",
                        children: [" :", E.jsx("select", {
                            value: e.skillfactory.codeLanguage,
                            onChange: a => l("codeLanguage", a.target.value),
                            children: LB.map(a => E.jsx("option", {
                                value: a.value,
                                children: a.label
                            }, a.value))
                        })]
                    })
                }), E.jsx("div", {
                    className: "modal__select-group",
                    children: E.jsxs("label", {
                        className: "modal__select-label",
                        children: [" $imp/$biblio:", E.jsxs("select", {
                            value: e.skillfactory.impBiblioWrapper,
                            onChange: a => l("impBiblioWrapper", a.target.value),
                            children: [E.jsx("option", {
                                value: "span",
                                children: "<span>"
                            }), E.jsx("option", {
                                value: "div",
                                children: "<div>"
                            })]
                        })]
                    })
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.deleteExampleTitleDiv,
                        onChange: a => l("deleteExampleTitleDiv", a.target.checked)
                    }), ' <div class="example-title"></div>']
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.cleanDivStyles,
                        onChange: a => l("cleanDivStyles", a.target.checked)
                    }), "   div ( -)"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.removeEmTags,
                        onChange: a => l("removeEmTags", a.target.checked)
                    }), " <em> "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformHeadings,
                        onChange: a => l("transformHeadings", a.target.checked)
                    }), " h1-h3  div  "]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformH4,
                        onChange: a => l("transformH4", a.target.checked)
                    }), "h4  div.text-problem-title"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformLists,
                        onChange: a => l("transformLists", a.target.checked)
                    }), "ul  ul.list, ol  ol.ordered-list"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformLinks,
                        onChange: a => l("transformLinks", a.target.checked)
                    }), ': target="_blank", rel="noopener noreferrer nofollow"']
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformTables,
                        onChange: a => l("transformTables", a.target.checked)
                    }), "   div.overflow-table"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformCode,
                        onChange: a => l("transformCode", a.target.checked)
                    }), "$code...$end  <pre><code>"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformTerm,
                        onChange: a => l("transformTerm", a.target.checked)
                    }), "$term...$end  div.term"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformImp,
                        onChange: a => l("transformImp", a.target.checked)
                    }), "$imp...$end  blue-container  SVG"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformBiblio,
                        onChange: a => l("transformBiblio", a.target.checked)
                    }), "$biblio...$end  orange-container  SVG"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.transformCase,
                        onChange: a => l("transformCase", a.target.checked)
                    }), "$case...$end  div.block-example"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.replaceFormulaAlerts,
                        onChange: a => l("replaceFormulaAlerts", a.target.checked)
                    }), " gd2md-html formula alerts  \\(\\)"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.replaceImageAlerts,
                        onChange: a => l("replaceImageAlerts", a.target.checked)
                    }), " gd2md-html image alerts  <figure>"]
                }), E.jsxs("label", {
                    className: "modal__checkbox",
                    children: [E.jsx("input", {
                        type: "checkbox",
                        checked: e.skillfactory.convertLegacyBlocks,
                        onChange: a => l("convertLegacyBlocks", a.target.checked)
                    }), " legacy- (term, important, glossary  .)"]
                })]
            }), E.jsxs("div", {
                className: "modal__footer",
                children: [E.jsx("button", {
                    className: "modal__reset-btn",
                    onClick: () => n(Xs),
                    children: ""
                }), E.jsx("button", {
                    className: "modal__close-btn",
                    onClick: r,
                    children: ""
                })]
            })]
        })
    })
}
const mm = "text-to-html-content";
function _B() {
    const [t,e] = T.useState( () => localStorage.getItem(mm) || "")
      , [n,r] = T.useState( () => {
        const h = localStorage.getItem("text-to-html-settings");
        if (h)
            try {
                const p = JSON.parse(h);
                return {
                    general: {
                        ...Xs.general,
                        ...p.general
                    },
                    skillfactory: {
                        ...Xs.skillfactory,
                        ...p.skillfactory
                    }
                }
            } catch {
                return Xs
            }
        return Xs
    }
    )
      , [o,l] = T.useState(!1)
      , a = T.useCallback(h => {
        r(h),
        localStorage.setItem("text-to-html-settings", JSON.stringify(h))
    }
    , [])
      , u = T.useCallback(h => {
        e(h),
        localStorage.setItem(mm, h)
    }
    , [])
      , f = T.useCallback( () => {
        e(""),
        localStorage.removeItem(mm)
    }
    , []);
    return E.jsxs("div", {
        className: "app",
        children: [E.jsx("div", {
            className: "app__editor",
            children: E.jsx(bB, {
                onContentChange: u,
                initialContent: t,
                onClear: f
            })
        }), E.jsx("div", {
            className: "app__preview",
            children: E.jsx(DB, {
                htmlContent: t,
                settings: n,
                onOpenSettings: () => l(!0)
            })
        }), E.jsx(zB, {
            isOpen: o,
            settings: n,
            onSettingsChange: a,
            onClose: () => l(!1)
        })]
    })
}
rE.createRoot(document.getElementById("root")).render(E.jsx(T.StrictMode, {
    children: E.jsx(_B, {})
}));
